---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET Web API 2 でのグローバルエラー処理-ASP.NET 4.x
author: davidmatson
description: ASP.NET 4.x の ASP.NET Web API 2 でのグローバルエラー処理の概要について説明します。
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 94f2d6d31d0b37f9bb0077e6258c70a2dfb1918d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78448966"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="004cb-103">ASP.NET Web API 2 でのグローバルエラー処理</span><span class="sxs-lookup"><span data-stu-id="004cb-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="004cb-104">[David Matson](https://github.com/davidmatson)、 [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="004cb-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="004cb-105">このトピックでは、ASP.NET 4.x の ASP.NET Web API 2 でのグローバルエラー処理の概要について説明します。</span><span class="sxs-lookup"><span data-stu-id="004cb-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="004cb-106">現在、Web API では、エラーをグローバルに記録または処理する簡単な方法はありません。</span><span class="sxs-lookup"><span data-stu-id="004cb-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="004cb-107">一部のハンドルされない例外は[例外フィルター](exception-handling.md)を使用して処理できますが、例外フィルターが処理できないケースがいくつかあります。</span><span class="sxs-lookup"><span data-stu-id="004cb-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="004cb-108">次に例を示します。</span><span class="sxs-lookup"><span data-stu-id="004cb-108">For example:</span></span>

1. <span data-ttu-id="004cb-109">コントローラー コンストラクターからスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="004cb-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="004cb-110">メッセージ ハンドラーからスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="004cb-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="004cb-111">ルーティング中にスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="004cb-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="004cb-112">応答コンテンツのシリアル化中にスローされる例外。</span><span class="sxs-lookup"><span data-stu-id="004cb-112">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="004cb-113">これらの例外をログに記録して処理するための、簡単で一貫性のある方法を提供したいと考えています。</span><span class="sxs-lookup"><span data-stu-id="004cb-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="004cb-114">例外処理の主なケースとしては、エラー応答を送信できるケースと、例外をログに記録することだけが可能なケースがあります。</span><span class="sxs-lookup"><span data-stu-id="004cb-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="004cb-115">後者の場合の例として、ストリーミング応答コンテンツの途中で例外がスローされた場合があります。この場合は、状態コード、ヘッダー、部分的な内容が既にネットワーク経由で送信されているため、新しい応答メッセージを送信するには遅すぎます。そのため、単に接続を中止します。</span><span class="sxs-lookup"><span data-stu-id="004cb-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="004cb-116">新しい応答メッセージを生成するために例外を処理することはできませんが、例外のログ記録は引き続きサポートされています。</span><span class="sxs-lookup"><span data-stu-id="004cb-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="004cb-117">エラーを検出できる場合は、次に示すように、適切なエラー応答を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="004cb-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="004cb-118">既存のオプション</span><span class="sxs-lookup"><span data-stu-id="004cb-118">Existing Options</span></span>

<span data-ttu-id="004cb-119">[例外フィルター](exception-handling.md)に加えて、[メッセージハンドラー](../advanced/http-message-handlers.md)を使用して500レベルのすべての応答を確認できますが、元のエラーに関するコンテキストがないため、これらの応答に対して動作するのは困難です。</span><span class="sxs-lookup"><span data-stu-id="004cb-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="004cb-120">また、メッセージハンドラーには、処理できるケースに関する例外フィルターと同じ制限事項がいくつかあります。Web API には、エラー状態をキャプチャするトレースインフラストラクチャがありますが、トレースインフラストラクチャは診断のためのものであり、実稼働環境での実行には適していません。</span><span class="sxs-lookup"><span data-stu-id="004cb-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="004cb-121">グローバルな例外処理とログ記録は、運用中に実行できるサービスであり、既存の監視ソリューション ( [ELMAH](https://code.google.com/p/elmah/)など) に接続されている必要があります。</span><span class="sxs-lookup"><span data-stu-id="004cb-121">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="004cb-122">ソリューションの概要</span><span class="sxs-lookup"><span data-stu-id="004cb-122">Solution Overview</span></span>

 <span data-ttu-id="004cb-123">未処理の例外をログに記録して処理するために、 [Iexceptionlogger](../releases/whats-new-in-aspnet-web-api-21.md)と Iexceptionlogger という2つの新しいユーザー置き換え可能なサービスを提供しています。</span><span class="sxs-lookup"><span data-stu-id="004cb-123">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="004cb-124">これらのサービスは非常によく似ていますが、主に2つの違いがあります。</span><span class="sxs-lookup"><span data-stu-id="004cb-124">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="004cb-125">複数の例外ロガーの登録はサポートしていますが、例外ハンドラーは1つだけです。</span><span class="sxs-lookup"><span data-stu-id="004cb-125">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="004cb-126">接続を中止しようとしている場合でも、例外ロガーは常に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-126">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="004cb-127">例外ハンドラーは、送信する応答メッセージを選択できる場合にのみ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-127">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="004cb-128">どちらのサービスも、例外が検出されたポイントからの関連情報 (特に、 [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)、 [httprequestcontext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)、スローされた例外、例外ソース (以下の詳細) を含む) を含む例外コンテキストへのアクセスを提供します。</span><span class="sxs-lookup"><span data-stu-id="004cb-128">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="004cb-129">設計原則</span><span class="sxs-lookup"><span data-stu-id="004cb-129">Design Principles</span></span>

1. <span data-ttu-id="004cb-130">**互換性に影響する変更はありません**この機能はマイナーリリースで追加されているため、ソリューションに影響を与える重要な制約の1つは、コントラクトまたは動作に種類を指定するための重大な変更がないことです。</span><span class="sxs-lookup"><span data-stu-id="004cb-130">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="004cb-131">この制約は、例外を500の応答に変換する既存の catch ブロックの観点から実行する必要のあるクリーンアップを除外します。</span><span class="sxs-lookup"><span data-stu-id="004cb-131">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="004cb-132">この追加のクリーンアップは、後続のメジャーリリースで検討することができます。</span><span class="sxs-lookup"><span data-stu-id="004cb-132">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="004cb-133">これが重要な場合は、 [ASP.NET Web API ユーザーの声](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)で投票してください。</span><span class="sxs-lookup"><span data-stu-id="004cb-133">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="004cb-134">**WEB API コンストラクトとの一貫性の維持**Web API のフィルターパイプラインは、アクション固有のコントローラー固有またはグローバルスコープでロジックを適用する柔軟性により、横断的な懸念を処理する優れた方法です。</span><span class="sxs-lookup"><span data-stu-id="004cb-134">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="004cb-135">例外フィルターを含むフィルターには、グローバルスコープで登録されている場合でも、常にアクションおよびコントローラーコンテキストがあります。</span><span class="sxs-lookup"><span data-stu-id="004cb-135">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="004cb-136">このコントラクトはフィルターにとって理にかなっていますが、例外フィルターはグローバルにスコープが設定されている場合でも、メッセージハンドラーからの例外 (アクションやコントローラーコンテキストが存在しないなど) には適していないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="004cb-136">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="004cb-137">例外処理のためにフィルターによる柔軟なスコープ設定を使用する場合でも、例外フィルターが必要です。</span><span class="sxs-lookup"><span data-stu-id="004cb-137">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="004cb-138">ただし、コントローラーコンテキストの外部で例外を処理する必要がある場合は、完全なグローバルエラー処理 (コントローラーコンテキストとアクションコンテキスト制約のないもの) に対して個別の構成要素も必要になります。</span><span class="sxs-lookup"><span data-stu-id="004cb-138">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="004cb-139">使用する場合</span><span class="sxs-lookup"><span data-stu-id="004cb-139">When to Use</span></span>

- <span data-ttu-id="004cb-140">例外ロガーは、Web API でキャッチされた未処理の例外をすべて表示するためのソリューションです。</span><span class="sxs-lookup"><span data-stu-id="004cb-140">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="004cb-141">例外ハンドラーは、Web API でキャッチされた未処理の例外に対して可能なすべての応答をカスタマイズするためのソリューションです。</span><span class="sxs-lookup"><span data-stu-id="004cb-141">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="004cb-142">例外フィルターは、特定のアクションまたはコントローラーに関連するハンドルされない例外を処理するための最も簡単なソリューションです。</span><span class="sxs-lookup"><span data-stu-id="004cb-142">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="004cb-143">サービスの詳細</span><span class="sxs-lookup"><span data-stu-id="004cb-143">Service Details</span></span>

 <span data-ttu-id="004cb-144">例外ロガーとハンドラーサービスインターフェイスは、それぞれのコンテキストを取得する単純な非同期メソッドです。</span><span class="sxs-lookup"><span data-stu-id="004cb-144">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="004cb-145">また、これらのインターフェイスの両方に基本クラスを用意しています。</span><span class="sxs-lookup"><span data-stu-id="004cb-145">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="004cb-146">コア (同期または非同期) メソッドのオーバーライドは、推奨される時刻にログ記録または処理を行うために必要です。</span><span class="sxs-lookup"><span data-stu-id="004cb-146">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="004cb-147">ログ記録のために、`ExceptionLogger` の基本クラスでは、コアログメソッドが例外ごとに1回だけ呼び出されるようにします (後でコールスタックの上位に伝達して、再びキャッチする場合でも)。</span><span class="sxs-lookup"><span data-stu-id="004cb-147">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="004cb-148">`ExceptionHandler` 基底クラスは、呼び出し履歴の一番上にある例外に対してのみコア処理メソッドを呼び出し、従来の入れ子になった catch ブロックを無視します。</span><span class="sxs-lookup"><span data-stu-id="004cb-148">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="004cb-149">(これらの基本クラスの簡略化されたバージョンについては、以下の付録を参照してください)。`IExceptionLogger` と `IExceptionHandler` はどちらも `ExceptionContext`を介して例外に関する情報を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="004cb-149">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="004cb-150">フレームワークが例外ロガーまたは例外ハンドラーを呼び出すと、常に `Exception` と `Request`が提供されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-150">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="004cb-151">単体テスト以外にも、常に `RequestContext`が提供されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-151">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="004cb-152">`ControllerContext` と `ActionContext` が提供されることはほとんどありません (例外フィルターの catch ブロックからを呼び出す場合のみ)。</span><span class="sxs-lookup"><span data-stu-id="004cb-152">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="004cb-153">`Response`が提供されることはほとんどありません (応答を書き込もうとしているときに、特定の IIS の場合のみ)。</span><span class="sxs-lookup"><span data-stu-id="004cb-153">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="004cb-154">これらのプロパティの一部は `null` 可能性があるため、例外クラスのメンバーにアクセスする前に、コンシューマーが `null` を確認する必要があります。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="004cb-154">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="004cb-155">例外を検出した catch ブロックを示す文字列を指定します。</span><span class="sxs-lookup"><span data-stu-id="004cb-155">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="004cb-156">Catch ブロック文字列は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="004cb-156">The catch block strings are as follows:</span></span>

- <span data-ttu-id="004cb-157">HttpServer (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="004cb-157">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="004cb-158">Httpコントローラーディスパッチャー (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="004cb-158">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="004cb-159">HttpBatchHandler (SendAsync メソッド)</span><span class="sxs-lookup"><span data-stu-id="004cb-159">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="004cb-160">IExceptionFilter (ExecuteAsync での例外フィルターパイプラインの ApiController の処理)</span><span class="sxs-lookup"><span data-stu-id="004cb-160">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="004cb-161">ホストの OWIN:</span><span class="sxs-lookup"><span data-stu-id="004cb-161">OWIN host:</span></span>

    - <span data-ttu-id="004cb-162">HttpmessageBufferResponseContentAsync (出力のバッファリング用)</span><span class="sxs-lookup"><span data-stu-id="004cb-162">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="004cb-163">HttpmessageCopyResponseContentAsync (ストリーミング出力用)</span><span class="sxs-lookup"><span data-stu-id="004cb-163">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="004cb-164">Web ホスト:</span><span class="sxs-lookup"><span data-stu-id="004cb-164">Web host:</span></span>

    - <span data-ttu-id="004cb-165">Httpsystem.web.http.webhost.httpcontrollerhandler.writebufferedresponsecontentasync (出力のバッファリング用)</span><span class="sxs-lookup"><span data-stu-id="004cb-165">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="004cb-166">Httpsystem.web.http.webhost.httpcontrollerhandler.writestreamedresponsecontentasync (出力のストリーミング用)</span><span class="sxs-lookup"><span data-stu-id="004cb-166">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="004cb-167">Httpsystem.web.http.webhost.httpcontrollerhandler.writeerrorresponsecontentasync (バッファー出力モードでのエラー復旧エラー用)</span><span class="sxs-lookup"><span data-stu-id="004cb-167">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="004cb-168">Catch ブロック文字列の一覧は、静的な読み取り専用プロパティでも使用できます。</span><span class="sxs-lookup"><span data-stu-id="004cb-168">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="004cb-169">(コア catch ブロック文字列は静的な System.web.http.exceptionhandling.exceptioncatchblocks.httpserver.sendasync 上にあります。剰余は、OWIN と web ホストのそれぞれに対して1つの静的クラスに表示されます)。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="004cb-169">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="004cb-170">は、呼び出し履歴の一番上でのみ例外を処理することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="004cb-170">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="004cb-171">入れ子になった catch ブロックが発生するたびに例外を500応答に変換するのではなく、例外ハンドラーによって、ホストに表示されるまで例外を反映させることができます。</span><span class="sxs-lookup"><span data-stu-id="004cb-171">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="004cb-172">ロガーは、`ExceptionContext`に加えて、完全な `ExceptionLoggerContext`を介して1つ以上の情報を取得します。</span><span class="sxs-lookup"><span data-stu-id="004cb-172">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="004cb-173">2番目のプロパティである `CanBeHandled`を使用すると、処理できない例外を logger で識別できます。</span><span class="sxs-lookup"><span data-stu-id="004cb-173">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="004cb-174">接続を中止しようとしているときに、新しい応答メッセージを送信できない場合、ロガーは呼び出されますが、ハンドラーは呼び出さ***れず、*** logger はこのプロパティからこのシナリオを識別できます。</span><span class="sxs-lookup"><span data-stu-id="004cb-174">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="004cb-175">`ExceptionContext`に加えて、ハンドラーは、例外を処理するために、完全な `ExceptionHandlerContext` に設定できるもう1つのプロパティを取得します。</span><span class="sxs-lookup"><span data-stu-id="004cb-175">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="004cb-176">例外ハンドラーは、`Result` プロパティをアクションの結果 ( [Exceptionresult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)、 [internalservererrorresult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)、 [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)、またはカスタム結果) に設定することによって例外を処理したことを示します。</span><span class="sxs-lookup"><span data-stu-id="004cb-176">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="004cb-177">`Result` プロパティが null の場合、例外は処理されないため、元の例外が再スローされます。</span><span class="sxs-lookup"><span data-stu-id="004cb-177">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="004cb-178">呼び出し履歴の一番上にある例外については、API 呼び出し元に対して応答が適切であることを確認するための追加の手順を実行しました。</span><span class="sxs-lookup"><span data-stu-id="004cb-178">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="004cb-179">例外がホストに伝達されると、呼び出し元には、死亡の黄色の画面、または通常は HTML であり、通常は適切な API エラー応答ではないその他のホスト提供の応答が表示されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-179">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="004cb-180">このような場合、結果は null 以外の値から開始されます。また、カスタム例外ハンドラーが明示的に `null` (未処理) に設定した場合にのみ、例外がホストに反映されます。</span><span class="sxs-lookup"><span data-stu-id="004cb-180">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="004cb-181">このような場合に `Result` を `null` に設定すると、次の2つのシナリオで役に立ちます。</span><span class="sxs-lookup"><span data-stu-id="004cb-181">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="004cb-182">Web API の前/外側に登録されたカスタム例外処理ミドルウェアを使用して、OWIN にホストされる Web API を作成します。</span><span class="sxs-lookup"><span data-stu-id="004cb-182">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="004cb-183">ブラウザーを使用したローカルデバッグ。これは、実際には、ハンドルされない例外が発生した場合に、実際には、死亡の黄色い画面が役に立つ応答です。</span><span class="sxs-lookup"><span data-stu-id="004cb-183">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="004cb-184">例外ロガーと例外ハンドラーの両方について、logger またはハンドラー自体が例外をスローする場合、復旧するものはありません。</span><span class="sxs-lookup"><span data-stu-id="004cb-184">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="004cb-185">(例外が反映されないように、より適切な方法を使用している場合は、このページの下部にフィードバックを残してください。)例外ロガーとハンドラーのコントラクトは、例外が呼び出し元に伝達されないようにする必要があるということです。そうしないと、多くの場合、例外が伝達されます。これは、多くの場合、ホストに対して HTML エラー (ASP など) が発生します。ネットワークの黄色の画面) がクライアントに送り返されます (通常、JSON または XML を想定している API の呼び出し元では、このオプションは推奨されません)。</span><span class="sxs-lookup"><span data-stu-id="004cb-185">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="004cb-186">例</span><span class="sxs-lookup"><span data-stu-id="004cb-186">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="004cb-187">トレース例外ロガー</span><span class="sxs-lookup"><span data-stu-id="004cb-187">Tracing Exception Logger</span></span>

<span data-ttu-id="004cb-188">次の例外ロガーは、構成されたトレースソース (Visual Studio の [デバッグ出力] ウィンドウを含む) に例外データを送信します。</span><span class="sxs-lookup"><span data-stu-id="004cb-188">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="004cb-189">カスタムエラーメッセージ例外ハンドラー</span><span class="sxs-lookup"><span data-stu-id="004cb-189">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="004cb-190">次の例では、サポートに連絡するための電子メールアドレスを含む、クライアントに対するカスタムエラー応答を生成します。</span><span class="sxs-lookup"><span data-stu-id="004cb-190">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="004cb-191">登録 (例外フィルターを)</span><span class="sxs-lookup"><span data-stu-id="004cb-191">Registering Exception Filters</span></span>

<span data-ttu-id="004cb-192">"ASP.NET MVC 4 Web アプリケーション" プロジェクトテンプレートを使用してプロジェクトを作成する場合は、Web API 構成コードを `WebApiConfig` クラス内の*App/_Start*フォルダーに配置します。</span><span class="sxs-lookup"><span data-stu-id="004cb-192">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="004cb-193">付録: 基本クラスの詳細</span><span class="sxs-lookup"><span data-stu-id="004cb-193">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
