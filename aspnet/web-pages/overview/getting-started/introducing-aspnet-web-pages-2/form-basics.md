---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
title: web ページASP.NET紹介 - HTML フォームの基本 |マイクロソフトドキュメント
author: Rick-Anderson
description: このチュートリアルでは、入力フォームを作成する方法と、Web ページ (Razor) を ASP.NET使用するときにユーザーの入力を処理する方法の基本を示します。 そして今、あなた.
ms.author: riande
ms.date: 05/28/2015
ms.assetid: 81ed82bf-b940-44f1-b94a-555d0cb7cc98
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/form-basics
msc.type: authoredcontent
ms.openlocfilehash: f57661077ec3bb13f3d4ec41b130bda4d2fb9070
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675923"
---
# <a name="introducing-aspnet-web-pages---html-form-basics"></a>ASP.NET Web ページの概要 - HTML フォームの基本

[Tom FitzMacken](https://github.com/tfitzmac)

> このチュートリアルでは、入力フォームを作成する方法と、Web ページ (Razor) を ASP.NET使用するときにユーザーの入力を処理する方法の基本を示します。 データベースを作成したら、フォームのスキルを使用して、ユーザーがデータベース内の特定のムービーを見つけましょう。 ここでは[、Web ページを使用したデータの表示の概要 を](/aspnet/web-pages/overview/getting-started/introducing-aspnet-web-pages-2/displaying-data)通じて、このシリーズを完了ASP.NET前提としています。
> 
> ここでは、次の内容について学習します。
> 
> - 標準の HTML 要素を使用してフォームを作成する方法。
> - フォームでのユーザーの入力を読み取る方法。
> - ユーザーが指定した検索用語を使用してデータを選択的に取得する SQL クエリを作成する方法。
> - ユーザーが入力した内容を"記憶"するページのフィールドを設定する方法。
>   
> 
> 次の機能/テクノロジについて説明しました。
> 
> - `Request` オブジェクトです。
> - SQL`Where`句。

## <a name="what-youll-build"></a>作成するアプリケーション:

前のチュートリアルでは、データベースを作成し、それにデータを追加し、ヘルパーを`WebGrid`使用してデータを表示しました。 このチュートリアルでは、特定のジャンルの映画を検索したり、タイトルに入力した単語を含むムービーを検索できる検索ボックスを追加します。 (たとえば、ジャンルが "アクション" であるすべての映画や、タイトルに "ハリー" または "Adventure" が含まれているすべての映画を検索できます)。

このチュートリアルを終了すると、次のようなページが表示されます。

![ジャンルとタイトル検索を含む映画ページ](form-basics/_static/image1.png)

ページのリスト部分は、最後のチュートリアル&mdash;のグリッドと同じです。 違いは、グリッドが検索した映画のみを表示することです。

## <a name="about-html-forms"></a>HTML フォームについて

(HTML フォームの作成と と の違`GET``POST`いがある場合は、このセクションをスキップできます)。

フォームには、ユーザー入力要素&mdash;のテキスト ボックス、ボタン、ラジオ ボタン、チェック ボックス、ドロップダウン リストなどが含まれます。 ユーザーは、これらのコントロールに入力するか、選択を行い、ボタンをクリックしてフォームを送信します。

フォームの基本的な HTML 構文は、次の例で示されています。

[!code-html[Main](form-basics/samples/sample1.html)]

このマークアップがページで実行されると、次の図のような単純なフォームが作成されます。

![ブラウザでレンダリングされた基本的な HTML フォーム](form-basics/_static/image2.png)

要素`<form>`は、送信される HTML 要素を囲みます。 (簡単な間違いは、ページに要素を追加するが、`<form>`要素の内部に配置することを忘れることです。 その場合、何も提出しません。この`method`属性は、ユーザー入力の送信方法をブラウザーに指示します。 サーバーで更新を`post`実行する場合、または`get`サーバーからデータをフェッチする場合にこの設定を行います。

<a id="GET,_POST,_and_HTTP_Verb_Safety"></a>

> [!TIP] 
> 
> **取得、投稿、および HTTP 動詞の安全性**
> 
> HTTP は、ブラウザとサーバーが情報を交換するために使用するプロトコルで、基本的な操作では非常に単純です。 ブラウザは、サーバーへの要求を行うために、いくつかの動詞のみを使用します。 Web のコードを記述する場合、これらの動詞と、ブラウザーとサーバーが使用する方法を理解しておくと役に立ちます。 遠く離れて最も一般的に使用される動詞は、次のとおりです。
> 
> - `GET`. ブラウザはこの動詞を使用して、サーバーから何かをフェッチします。 たとえば、ブラウザーに URL を入力すると、ブラウザーは必要なページ`GET`を要求する操作を実行します。 ページにグラフィックスが含まれている場合、ブラウザーは`GET`画像を取得するための追加の操作を実行します。 操作で`GET`サーバーに情報を渡す必要がある場合、情報はクエリ文字列の URL の一部として渡されます。
> - `POST`. ブラウザは、`POST`サーバー上で追加または変更するデータを送信するために要求を送信します。 たとえば、この動詞`POST`は、データベース内のレコードの作成や既存のレコードの変更に使用されます。 ほとんどの場合、フォームに入力して送信ボタンをクリックすると、ブラウザが操作を`POST`実行します。 操作では`POST`、サーバーに渡されるデータはページの本文に含まれます。
> 
> これらの動詞の重要な違いは、`GET`操作がサーバー上の何かを変更しないこと、または少し抽象的な方法で配置する`GET`操作は、サーバー上の状態の変更を生じないようにすることです。 同じリソースに`GET`対して必要な回数だけ操作を実行できますが、それらのリソースは変更されません。 (操作`GET`は「安全」と言われる場合が多い、または専門用語を使用することは *、べき等です*。これに対し、もちろん、要求`POST`は操作を実行するたびにサーバー上の何かを変更します。
> 
> この違いを説明する例は2つ挙げる。 Bingや Google などのエンジンを使用して検索を実行する場合は、1 つのテキスト ボックスで構成されるフォームに入力し、検索ボタンをクリックします。 ブラウザーは操作を`GET`実行し、入力した値を URL の一部として渡します。 この種類`GET`のフォームに対する操作を使用すると、検索操作によってサーバー上のリソースが変更されるわけではなく、情報が取得されるだけなので、問題ありません。
> 
> 次に、オンラインで何かを注文するプロセスを考えてみましょう。 注文の詳細を入力し、送信ボタンをクリックします。 この操作は、新`POST`しい注文レコード、アカウント情報の変更、およびおそらく他の多くの変更など、サーバー上で変更を行うため、要求になります。 操作と`GET`は異なり、要求を`POST`繰り返すことはできません。 (このような場合、Web サイトでは、送信ボタンを複数回クリックしないように警告したり、誤ってフォームを再送信しないように送信ボタンを無効にしたりすることがよくあります)。
> 
> このチュートリアルでは、操作と`GET``POST`操作の両方を使用して HTML フォームを操作します。 使用する動詞が適切な動詞である理由を、それぞれのケースで説明します。
> 
> (HTTP 動詞の詳細については、W3C サイトの[メソッド定義](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)の記事を参照してください。

ほとんどのユーザー入力要素は`<input>`HTML 要素です。 これらの値は`<input type="type" name="name">,`、*必要*なユーザー入力コントロールの種類を示す場所の種類に似ています。 これらの要素は一般的なものです。

- テキスト ボックス:`<input type="text">`
- チェック ボックス:`<input type="check">`
- ラジオボタン：`<input type="radio">`
- ボタン：`<input type="button">`
- 送信ボタン:`<input type="submit">`

また、要素を`<textarea>`使用して複数行テキスト ボックスを作成し、`<select>`要素を使用してドロップダウン リストまたはスクロール可能なリストを作成することもできます。 (HTML フォーム要素の詳細については、W3Schools サイトの[HTML フォームと入力](http://www.w3schools.com/html/html_forms.asp)を参照してください。

この`name`属性は、後で要素の値を取得する方法なので、非常に重要です。

興味深いのは、ページ開発者がユーザーの入力で何をするかです。 これらの要素に関連付けられている組み込みの動作はありません。 代わりに、ユーザーが入力または選択した値を取得し、それらを使用して何かを行う必要があります。 このチュートリアルで学習する内容です。

> [!TIP] 
> 
> **HTML5 と入力フォーム**
> 
> ご存知のように、HTML は移行中であり、最新バージョン (HTML5) には、ユーザーが情報を入力するためのより直感的な方法のサポートが含まれています。 たとえば、HTML5 では、ユーザーに日付を入力するようにページに指示できます。 ブラウザは、ユーザーが手動で日付を入力しなくても、カレンダーを自動的に表示できます。 ただし、HTML5 は新しく、まだすべてのブラウザーでサポートされているわけではありません。
> 
> web ページASP.NET、ユーザーのブラウザーが行う範囲で HTML5 入力をサポートしています。 HTML5 の`<input>`要素の新しい属性のアイデアについては、W3Schools サイトの[HTML &lt;&gt;入力型属性](http://www.w3schools.com/html/html_form_input_types.asp)を参照してください。

## <a name="creating-the-form"></a>フォームの作成

WebMatrix の [**ファイル**] ワークスペースで *、Movies.cshtml*ページを開きます。

終了`</h1>`タグの後、および呼び`<div>`出しの`grid.GetHtml`開始タグの前に、次のマークアップを追加します。

[!code-html[Main](form-basics/samples/sample2.html)]

このマークアップは、名前のテキスト`searchGenre`ボックスと送信ボタンを持つフォームを作成します。 テキスト ボックスと送信ボタンは、属性が`<form>``method`に`get`設定されている要素で囲まれています。 (`<form>`テキスト ボックスと送信ボタンを要素内に配置しないと、ボタンをクリックしても何も送信されません。ここでは`GET`、サーバーで変更を加えないフォームを作成する場合に、この動詞を使用すると、検索が実行されるだけです。 (前のチュートリアルでは、サーバーに変更`post`を送信する方法を使用しました。 次のチュートリアルでもう一度表示されます)。

ページを実行します。 フォームの動作は定義されていませんが、次のような動作を確認できます。

![ジャンルの検索ボックスを持つ映画ページ](form-basics/_static/image3.png)

テキスト ボックスに「コメディ」などの値を入力します。 次に、[**ジャンルの検索**] をクリックします。

ページの URL を書き留めます。 要素の`<form>``method`属性を に`get`設定したため、入力した値は、次のように、URL のクエリ文字列の一部になります。

`http://localhost:45661/Movies.cshtml?searchGenre=Comedy`

## <a name="reading-form-values"></a>フォーム値の読み取り

ページには、データベース データを取得し、結果をグリッドに表示するコードが既に含まれています。 ここで、検索語を含む SQL クエリを実行できるように、テキスト ボックスの値を読み取るコードを追加する必要があります。

フォームのメソッドを に`get`設定しているため、次のようなコードを使用して、テキスト ボックスに入力された値を読み取ることができます。

`var searchTerm = Request.QueryString["searchGenre"];`

`Request.QueryString`オブジェクト (`Request`オブジェクト`QueryString`のプロパティ) には、操作の一部として送信された要素の値が`GET`含まれます。 `Request.QueryString`このプロパティには、フォームで送信される値の*コレクション*(リスト) が含まれます。 個々の値を取得するには、必要な要素の名前を指定します。 そのため、テキスト ボックスを`name`作成する`<input>`要素 (`searchTerm`) に属性を持たなければなりません。 (オブジェクトの`Request`詳細については、後で[サイドバー](#BKMK_TheRequestObject)を参照してください)。

テキスト ボックスの値を読み取るだけの簡単な方法です。 しかし、ユーザーがテキストボックスに何も入力しなかったが、とにかく**検索**をクリックした場合は、検索するものは何もないので、そのクリックは無視できます。

次のコードは、これらの条件を実装する方法を示す例です。 (このコードを追加する必要はありません。

[!code-csharp[Main](form-basics/samples/sample3.cs)]

テストは次の方法で分解されます。

- の値`Request.QueryString["searchGenre"]`を取得します。 `<input>` `searchGenre`
- `IsEmpty`メソッドを使用して、空であるかどうかを調べる。 このメソッドは、何か (たとえば、フォーム要素) に値が含まれているかどうかを判断する標準的な方法です。 しかし、本当に、あなたはそれが空*でない*場合にのみ気にします.
- テストの`!`前にオペレータを追加`IsEmpty`します。 (演算子`!`は論理 NOT を意味します)。

平易な英語では、`if`条件全体が次のように変換されます:*フォームの searchGenre 要素が空でない場合は..*

このブロックは、検索語を使用するクエリを作成する段階を設定します。 これは、次のセクションで行います。

<a id="BKMK_TheRequestObject"></a>

> [!TIP] 
> 
> **要求オブジェクト**
> 
> `Request`このオブジェクトには、ページが要求または送信されたときにブラウザーがアプリケーションに送信するすべての情報が含まれます。 このオブジェクトには、テキスト ボックスの値やアップロードするファイルなど、ユーザーが入力した情報が含まれます。 また、Cookie、URL クエリ文字列内の値 (存在する場合)、実行中のページのファイル パス、ユーザーが使用しているブラウザーの種類、ブラウザーで設定されている言語の一覧など、あらゆる種類の追加情報も含まれます。
> 
> オブジェクト`Request`は、値の*コレクション*(リスト) です。 コレクションの名前を指定して、個別の値を取得します。
> 
> `var someValue = Request["name"];`
> 
> オブジェクト`Request`は実際にいくつかのサブセットを公開します。 次に例を示します。
> 
> - `Request.Form`要求が要求の場合、送信された`<form>`要素内の要素から値`POST`を取得します。
> - `Request.QueryString`は、URL のクエリ文字列の値のみを示します。 (URL のような`http://mysite/myapp/page?searchGenre=action&page=2`URL`?searchGenre=action&page=2`では、URL のセクションはクエリ文字列です。
> - `Request.Cookies`コレクションを使用すると、ブラウザが送信した Cookie にアクセスできます。
> 
> 送信されたフォームに含まれている値を取得するには、 を使用`Request["name"]`します。 または、より具体的な`Request.Form["name"]`バージョン (要求の`POST`場合) または`Request.QueryString["name"]`(要求`GET`) を使用できます。 もちろん、*名前*は取得する項目の名前です。
> 
> 取得する項目の名前は、使用しているコレクション内で一意である必要があります。 そのため、オブジェクトは`Request`、 と`Request.Form``Request.QueryString`のようなサブセットを提供します。 ページにという名前`userName`のフォーム要素が含まれ *、という*名前`userName`のクッキーも含まれているとします。 を取得`Request["userName"]`した場合は、フォームの値または Cookie のどちらを使用するかがあいまいです。 ただし、 または`Request.Form["userName"]``Request.Cookie["userName"]`を取得した場合は、どの値を取得するかを明示的に指定します。
> 
> これは、特定の方法で、興味`Request`のある部分を使用することをお`Request.Form`勧めします。 `Request.QueryString` このチュートリアルで作成する単純なページでは、おそらく実際には何の違いもありません。 ただし、より複雑なページを作成する場合は、明示的`Request.Form`な`Request.QueryString`バージョンを使用したり、ページにフォーム (または複数のフォーム)、Cookie、クエリ文字列値などが含まれている場合に発生する問題を回避できます。

## <a name="creating-a-query-by-using-a-search-term"></a>検索用語を使用したクエリの作成

ユーザーが入力した検索語を取得する方法がわかったので、それを使用するクエリを作成できます。 すべてのムービーアイテムをデータベースから取り出すためには、次のような SQL クエリを使用することに注意してください。

`SELECT * FROM Movies`

特定のムービーのみを取得するには、句を含むクエリを使用する`Where`必要があります。 この句を使用すると、クエリによって行が返される条件を設定できます。 次に例を示します。

`SELECT * FROM Movies WHERE Genre = 'Action'`

基本的な形式は`WHERE column = value`です。 目的`=`に応じて、(より大きい`>`)、(`<`より小さい)、(`<>``<=`以下)、(以下)など、さまざまな演算子を使用できます。

疑問に思っている場合、SQL ステートメントは大文字と小文字&mdash;`SELECT`を区別しません`Select`( または`select`) と同じです。 しかし、読みやすくするために、`SELECT``WHERE`ユーザーは SQL ステートメントのキーワードを大文字にすることがよくあります。

### <a name="passing-the-search-term-as-a-parameter"></a>検索語をパラメーターとして渡す

特定のジャンルを検索するのは簡単ですが、`WHERE Genre = 'Action'`ユーザーが入力したジャンルを検索できるようにしたいと考えています。 そのためには、検索する値のプレースホルダーを含む SQL クエリとして作成します。 次のコマンドのようになります。

`SELECT * FROM Movies WHERE Genre = @0`

プレースホルダは、文字`@`の後に 0 が続きます。 ご想像のとおり、クエリには複数のプレースホルダを含めることができ、その名前`@0`は`@1`、 `@2`、などになります。

クエリを設定し、実際に値を渡すには、次のようなコードを使用します。

[!code-sql[Main](form-basics/samples/sample4.sql)]

このコードは、グリッドにデータを表示するために既に実行したコードと似ています。 唯一の違いは次のとおりです。

- クエリにプレースホルダ (`WHERE Genre = @0"`) が含まれています。
- クエリは変数に代入されます (`selectCommand`;前に、`db.Query`クエリをメソッドに直接渡しました。
- メソッドを`db.Query`呼び出すときに、クエリとプレースホルダーに使用する値の両方を渡します。 クエリに複数のプレースホルダーがある場合は、すべて個別の値としてメソッドに渡します。

これらすべての要素を組み合わせると、次のコードが表示されます。

[!code-csharp[Main](form-basics/samples/sample5.cs)]

> [!NOTE] 
> 
> **大事な！** SQL コマンドに値`@0`を渡すためにプレースホルダ ( など ) を使用することは、セキュリティにとって*非常に重要*です。 変数データのプレースホルダーを使用して、ここで表示する方法は、SQL コマンドを構築する唯一の方法です。
> 
> ユーザーから取得したリテラル テキストと値を結合して SQL ステートメントを構築しないでください。 ユーザー入力を SQL ステートメントに連結すると、サイトが*SQL インジェクション攻撃*を受け、悪意のあるユーザーがデータベースをハッキングする値をページに送信します。 (詳細については、MSDN Web サイトの[SQL インジェクション](https://msdn.microsoft.com/library/ms161953.aspx)の記事を参照してください。

## <a name="updating-the-movies-page-with-search-code"></a>検索コードを使用した映画ページの更新

これで *、Movies.cshtml*ファイルのコードを更新できます。 まず、ページの上部にあるコード ブロック内のコードを次のコードに置き換えます。

[!code-csharp[Main](form-basics/samples/sample6.cs)]

ここでの違いは、クエリを`selectCommand`変数に入れて、`db.Query`後で渡すことです。 SQL ステートメントを変数に入れることで、検索を実行するために実行するステートメントを変更できます。

また、この 2 行を削除しました。

[!code-csharp[Main](form-basics/samples/sample7.cs)]

クエリをまだ実行する (つまり、 を呼び出`db.Query`す)`WebGrid`必要はありません。 どの SQL ステートメントを実行する必要があるかを理解した後で、これらの操作を行います。

この書き換えブロックの後、検索を処理するための新しいロジックを追加できます。 完成したコードは次のようになります。 次の例に一致するように、ページのコードを更新します。

[!code-cshtml[Main](form-basics/samples/sample8.cshtml)]

これで、ページは次のように動作します。 ページが実行されるたびに、コードはデータベースを開き、`selectCommand`変数はテーブルからすべてのレコードを取得する SQL ステートメントに設定`Movies`されます。 このコードでは、変数も`searchTerm`初期化されます。

ただし、現在の要求に要素の値が`searchGenre`含まれている場合、コードは`selectCommand`別のクエリ、つまりジャンルを検索する句を`Where`含むクエリに設定します。 また、検索`searchTerm`ボックスに渡された値も設定されます (これは何もない場合もあります)。

`selectCommand`どの SQL ステートメントが含まれるかに関係なく、`db.Query`コードは クエリを実行するために呼び出`searchTerm`し、 内の任意の SQL ステートメントを渡します。 `searchTerm`に何もなければ、値を`selectCommand`渡すパラメータがないので、それは問題ではありません。

最後に、コードは、前`WebGrid`と同じように、クエリ結果を使用してヘルパーを初期化します。

SQL ステートメントと検索用語を変数に入れることで、コードに柔軟性を追加したことがわかります。 このチュートリアルの後半で説明したように、この基本的なフレームワークを使用して、さまざまな種類の検索にロジックを追加し続けることができます。

## <a name="testing-the-search-by-genre-feature"></a>ジャンル別検索機能のテスト

マトリックスで、*映画.cshtml*ページを実行します。 ジャンルのテキスト ボックスが表示されるページが表示されます。

いずれかのテスト レコードに入力したジャンルを入力し、[**検索**] をクリックします。 今回は、そのジャンルに一致する映画のリストが表示されます。

![ジャンル「コメディ」を検索した後の映画ページリスト](form-basics/_static/image4.png)

別のジャンルを入力して、もう一度検索します。 検索で大文字と小文字が区別されないのを見ることができるように、すべて小文字またはすべての大文字を使用して genre を入力してみてください。

## <a name="remembering-what-the-user-entered"></a>ユーザーが入力した内容を "記憶する"

ジャンルを入力して **[ジャンルの検索**] をクリックすると、そのジャンルの一覧が表示されます。 しかし、検索テキストボックスは空&mdash;だった、つまり、あなたが入力したものを覚えていませんでした。

この動作が発生する理由を理解することが重要です。 ページを送信すると、ブラウザーは Web サーバーに要求を送信します。 ASP.NET要求を取得すると、ページの新しいインスタンスを作成し、その中のコードを実行してから、ページをブラウザーに再びレンダリングします。 ただし、実際には、ページは、以前のバージョンのユーザーが作業していたことを知りません。 知っているのは、フォームデータが入っているリクエストを受け取ったことだけです。

ページをリクエストするたびに、初&mdash;めてリクエストする場合も、送信することで新しいページ&mdash;を取得する場合も含まれます。 Web サーバーには、最後の要求のメモリがありません。 どちらもASP.NET、ブラウザも行いません。 ページのこれらの別々のインスタンス間の接続は、それらの間で送信するデータのみです。 たとえば、ページを送信すると、新しいページ インスタンスは、以前のインスタンスによって送信されたフォーム データを取得できます。 (ページ間でデータを渡すもう 1 つの方法は、Cookie を使用することです。

この状況を記述する正式な方法は、Webページは*ステートレス*であると言うことです。 Web サーバー、ページ自体、およびページ内の要素は、ページの前の状態に関する情報を保持しません。 Web は、個々の要求の状態を維持すると、多くの場合、毎秒数千、おそらく数十万、要求を処理する Web サーバーのリソースをすぐに使い果たせるので、このように設計されました。

そのため、テキストボックスは空でした。 ページを送信した後、ASP.NETページの新しいインスタンスを作成し、コードとマークアップを実行します。 そのコードには、ASP.NETにテキスト ボックスに値を入れるように言うものは何もありませんでした。 だからASP.NETは何もせず、テキストボックスは値なしでレンダリングされました。

この問題を回避する簡単な方法は実際にあります。 テキスト ボックスに入力したジャンル*は、* のコード&mdash;で`Request.QueryString["searchGenre"]`使用できます。

次の例のように、テキスト ボックスのマークアップ`value`を更新して、属性`searchTerm`が の値を から取得するようにします。

[!code-html[Main](form-basics/samples/sample9.html?highlight=1)]

このページでは、入力した`value`ジャンルも変数に含まれているため、`searchTerm`この属性を変数に設定することもできます。 ただし、この`Request`タスクを実行するには`value`、オブジェクトを使用して属性を設定します。 (場合によっては、フィールド&mdash;に値*を含めず*にページをレンダリングする場合もあります。 それはすべてあなたのアプリで何が起こっているかによって異なります。

> [!NOTE]
> パスワードに使用するテキスト ボックスの値を "記憶" することはできません。 これは、コードを使用してパスワードフィールドに入力できるようにするセキュリティホールになります。

ページをもう一度実行し、ジャンルを入力して、[**ジャンルの検索**] をクリックします。 今回は、検索結果が表示されるだけでなく、テキスト ボックスには前回入力した内容が表示されます。

![テキスト ボックスが前のエントリを 「記憶」したことを示すページ](form-basics/_static/image5.png)

## <a name="searching-for-any-word-in-the-title"></a>タイトル内の任意の単語を検索する

ジャンルを検索できるようになりましたが、タイトルを検索することもできます。 検索時に正確に正しいタイトルを取得するのは難しいため、タイトル内の任意の場所に表示される単語を検索できます。 SQL で実行するには、演算子と構文`LIKE`を次のように使用します。

`SELECT * FROM Movies WHERE Title LIKE '%adventure%'`

このコマンドは、タイトルに 「アドベンチャー」が含まれているすべての映画を取得します。 演算子を`LIKE`使用する場合は、検索語の一`%`部としてワイルドカード文字を含めます。 検索`LIKE 'adventure%'`とは、「冒険」から始まるという意味です。 (技術的には、「文字列'adventure'」の後に何かが続くという意味です。同様に、検索語`LIKE '%adventure'`は「何でも文字列'adventure'」を意味し、「冒険で終わる」と言う別の方法です。

したがって、検索`LIKE '%adventure%'`用語は「タイトルのどこでも'冒険』を持つ」ことを意味します。 (技術的には、「タイトルの何でも、続いて『冒険』、続いて何でも」)。

要素の`<form>`内部で、ジャンル検索の終了`</div>`タグのすぐ下に次のマークアップを追加します (終了`</form>`要素の直前)。

[!code-html[Main](form-basics/samples/sample10.html)]

この検索を処理するコードは、検索を組み立てる必要がある点を除いて、ジャンル検索の`LIKE`コードに似ています。 ページ上部のコード ブロック内で、ジャンル検索のブロック`if`の直後に次`if`のブロックを追加します。

[!code-csharp[Main](form-basics/samples/sample11.cs)]

このコードは、前に確認したロジックと同じロジックを使用します`LIKE`が、検索では演算子が`%`使用され、検索語の前後に "" が記述されます。

ページに別の検索を追加する方法に注意してください。 あなたがしなければならなかったのは次のことだけです。

- 関連する`if`検索ボックスに値が含まれているかどうかを確認するためにテストしたブロックを作成します。
- 変数を`selectCommand`新しい SQL ステートメントに設定します。
- 変数に`searchTerm`クエリに渡す値を設定します。

タイトル検索の新しいロジックを含む完全なコード ブロックを次に示します。

[!code-cshtml[Main](form-basics/samples/sample12.cshtml)]

このコードの動作の概要は次のとおりです。

- 変数`searchTerm`は、`selectCommand`先頭に初期化されます。 これらの変数は、ページ内でユーザーが実行する内容に基づいて、適切な検索用語 (存在する場合) と適切な SQL コマンドに設定します。 デフォルト検索は、データベースからすべてのムービーを取得する単純なケースです。
- のテスト`searchGenre``searchTitle`と で、コードは検索`searchTerm`する値に設定されます。 これらのコード ブロックも`selectCommand`、その検索に適した SQL コマンドに設定されます。
- この`db.Query`メソッドは、SQL コマンド`selectedCommand`が含まれ、その値を使用して 1`searchTerm`回だけ呼び出されます。 検索語がない場合 (ジャンルもタイトルワードも含まれず)、の`searchTerm`値は空の文字列です。 ただし、クエリにはパラメーターが必要ないため、これは問題ではありません。

## <a name="testing-the-title-search-feature"></a>タイトル検索機能のテスト

これで、完了した検索ページをテストできます。 *ムービー.cshtml を実行します*。

ジャンルを入力し、[**ジャンルの検索**] をクリックします。 グリッドには、以前のように、そのジャンルの映画が表示されます。

タイトルワードを入力し、[**タイトルの検索**] をクリックします。 グリッドには、タイトルにその単語が含まれているムービーが表示されます。

![タイトルで 'The' を検索した後の映画ページの一覧](form-basics/_static/image6.png)

両方のテキスト ボックスを空白のままにして、いずれかのボタンをクリックします。 グリッドにすべてのムービーが表示されます。

## <a name="combining-the-queries"></a>クエリの結合

実行できる検索は排他的である場合があります。 両方の検索ボックスに値が含まれる場合でも、タイトルとジャンルを同時に検索することはできません。 たとえば、タイトルに "Adventure" が含まれているすべてのアクション ムービーを検索することはできません。 (ページがコード化されるようになったので、ジャンルとタイトルの両方に値を入力すると、タイトル検索が優先されます)。条件を組み合わせた検索を作成するには、次のような構文を持つ SQL クエリを作成する必要があります。

`SELECT * FROM Movies WHERE Genre = @0 AND Title LIKE @1`

次のようなステートメントを使用してクエリを実行する必要があります (大まかに言えば):

`var selectedData = db.Query(selectCommand, searchGenre, searchTitle);`

多くの検索条件の順列を許可するロジックを作成すると、ご覧のとおり、少し複雑になります。 したがって、ここで停止します。

## <a name="coming-up-next"></a>次に来る

次のチュートリアルでは、ユーザーがムービーをデータベースに追加できるようにフォームを使用するページを作成します。

## <a name="complete-listing-for-movie-page-updated-with-search"></a>動画ページの一覧の完了 (検索で更新)

[!code-cshtml[Main](form-basics/samples/sample13.cshtml)]

## <a name="additional-resources"></a>その他のリソース

- [Introduction to ASP.NET Web Programming Using the Razor Syntax (Razor 構文を使用した ASP.NET Web プログラミングの概要)](https://go.microsoft.com/fwlink/?LinkID=202890)
- W3Schools サイト上の[SQL WHERE 句](http://www.w3schools.com/sql/sql_where.asp)
- W3C サイトの[メソッド定義](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)に関する記事

> [!div class="step-by-step"]
> [前へ](displaying-data.md)
> [次へ](entering-data.md)
