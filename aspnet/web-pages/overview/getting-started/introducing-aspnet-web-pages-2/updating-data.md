---
uid: web-pages/overview/getting-started/introducing-aspnet-web-pages-2/updating-data
title: ASP.NET Web ページの概要-データベースデータの更新 |Microsoft Docs
author: Rick-Anderson
description: このチュートリアルでは、ASP.NET Web ページ (Razor) を使用するときに既存のデータベースエントリを更新 (変更) する方法について説明します。 ここでは、系列を完了していることを前提としています...
ms.author: riande
ms.date: 01/02/2018
ms.assetid: ac86ec9c-6b69-485b-b9e0-8b9127b13e6b
msc.legacyurl: /web-pages/overview/getting-started/introducing-aspnet-web-pages-2/updating-data
msc.type: authoredcontent
ms.openlocfilehash: 8f8bcfb7d9d2416a2699776cadbdaae8e12415ba
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78463492"
---
# <a name="introducing-aspnet-web-pages---updating-database-data"></a>ASP.NET Web ページの概要-データベースデータの更新

[Tom FitzMacken](https://github.com/tfitzmac)

> このチュートリアルでは、ASP.NET Web ページ (Razor) を使用するときに既存のデータベースエントリを更新 (変更) する方法について説明します。 [ASP.NET Web ページを使用してフォームを使用](entering-data.md)してデータを入力することによって、シリーズを完了していると想定しています。
> 
> ここでは、次の内容について学習します。
> 
> - `WebGrid` ヘルパーで個々のレコードを選択する方法。
> - データベースから1つのレコードを読み取る方法。
> - データベースレコードの値を使用してフォームをプリロードする方法。
> - データベース内の既存のレコードを更新する方法。
> - ページに情報を表示せずに保存する方法。
> - 隠しフィールドを使用して情報を格納する方法。
>   
> 
> 説明する機能/テクノロジ:
> 
> - `WebGrid` ヘルパー。
> - SQL `Update` コマンド。
> - `Database.Execute` メソッド。
> - 隠しフィールド (`<input type="hidden">`)。

## <a name="what-youll-build"></a>作成するアプリケーション:

前のチュートリアルでは、データベースにレコードを追加する方法について学習しました。 ここでは、編集のためにレコードを表示する方法について説明します。 [*ムービー* ] ページで、`WebGrid` ヘルパーを更新して、各ムービーの横に **[編集]** リンクが表示されるようにします。

![各ムービーの ' Edit ' リンクを含む WebGrid 表示](updating-data/_static/image1.png)

**[編集]** リンクをクリックすると、次のような別のページに移動します。このページでは、ムービー情報が既にフォームに含まれています。

![編集するムービーを表示するムービーページを編集する](updating-data/_static/image2.png)

任意の値を変更できます。 変更を送信すると、ページ内のコードによってデータベースが更新され、ムービーの一覧に戻ります。

プロセスのこの部分は、前のチュートリアルで作成した*Addmovie. cshtml*ページとほぼ同じように動作するため、このチュートリアルの多くは使い慣れています。

個々のムービーを編集する方法を実装するには、いくつかの方法があります。 この方法は、実装が簡単でわかりやすいために選択されています。

## <a name="adding-an-edit-link-to-the-movie-listing"></a>ムービーの一覧への編集リンクの追加

まず、ムービーの一覧に **[編集]** リンクが含まれるように、*ムービーページを*更新します。

ムービーの*cshtml*ファイルを開きます。

ページの本文で、列を追加して `WebGrid` マークアップを変更します。 変更されたマークアップを次に示します。

[!code-html[Main](updating-data/samples/sample1.html?highlight=6)]

新しい列は次のようになります。

[!code-html[Main](updating-data/samples/sample2.html)]

この列のポイントは、"Edit" というテキストを持つリンク (`<a>` 要素) を表示することです。 次の例では、ページの実行時に次のようなリンクを作成しています。ムービーごとに `id` 値が異なります。

[!code-css[Main](updating-data/samples/sample3.css)]

このリンクを実行すると、 *Editmovie*という名前のページが呼び出され、そのページに `?id=7` クエリ文字列が渡されます。

新しい列の構文は少し複雑に見えるかもしれませんが、複数の要素が組み合わされているためです。 個々の要素は単純です。 `<a>` 要素のみに専念する場合は、次のマークアップが表示されます。

[!code-html[Main](updating-data/samples/sample4.html)]

グリッドの動作についての背景がいくつかあります。グリッドには、各データベースレコードに対して1つずつ行が表示され、データベースレコードの各フィールドの列が表示されます。 各グリッド行が構築されている間、`item` オブジェクトには、その行のデータベースレコード (項目) が格納されます。 このように配置することにより、コードでその行のデータを取得できます。 ここに表示されているのは、現在のデータベース項目の ID 値を取得している `item.ID` 式です。 `item.Title`、`item.Genre`、または `item.Year`を使用すると、データベースの値 (タイトル、ジャンル、または年) を同じ方法で取得できます。

式 `"~/EditMovie?id=@item.ID` は、ターゲット URL (`~/EditMovie?id=`) のハードコーディングされた部分をこの動的な派生 ID と結合します。 (前のチュートリアルでは `~` 演算子を見ました。これは現在の web サイトルートを表す ASP.NET 演算子です)。

結果として、列のマークアップのこの部分は、実行時に次のマークアップのようなものを生成するだけです。

[!code-xml[Main](updating-data/samples/sample5.xml)]

当然ながら、`id` の実際の値は、行ごとに異なります。

## <a name="creating-a-custom-display-for-a-grid-column"></a>グリッド列のカスタム表示の作成

ここで、グリッド列に戻ります。 グリッドに最初に使用した3つの列には、データ値 (タイトル、ジャンル、および年) のみが表示されます。 この表示を指定するには、データベースの列の名前 &mdash; `grid.Column("Title")`のように指定します。

この新しい リンクの**編集**」列は異なります。 列名を指定する代わりに、`format` パラメーターを渡します。 このパラメーターを使用すると、`WebGrid` ヘルパーがレンダリングするマークアップと `item` の値を定義して、列のデータを太字または緑または任意の形式で表示できます。 たとえば、タイトルを太字で表示したい場合は、次の例のような列を作成できます。

[!code-html[Main](updating-data/samples/sample6.html)]

(`format` のプロパティに表示されるさまざまな `@` 文字は、マークアップとコード値の間の切り替えをマークします)。

`format` プロパティについて理解すると、新しい [リンクの**編集**] 列がどのように組み合わされているかを理解しやすくなります。

[!code-html[Main](updating-data/samples/sample7.html)]

この列は、リンクを表示するマークアップと、その行のデータベースレコードから抽出された情報 (ID)*だけ*で構成されます。

> [!TIP]
> 
> **メソッドの名前付きパラメーターと位置指定パラメーター**
> 
> メソッドを呼び出してパラメーターを渡すと、何度もパラメーター値がコンマで区切られて表示されます。 いくつかの例を次に示します。
> 
> `db.Execute(insertCommand, title, genre, year)`
> 
> `Validation.RequireField("title", "You must enter a title")`
> 
> この問題については、最初にこのコードを見たときには説明しませんでしたが、いずれの場合も、パラメーターを特定の順序でメソッドに渡すことになります。つまり、そのメソッドでパラメーターが定義されている順序 &mdash; ます。 `db.Execute` と `Validation.RequireFields`の場合、渡す値の順序を組み合わせると、ページの実行時にエラーメッセージが表示されます。または、少なくとも奇妙な結果が返されます。 具体的には、パラメーターを渡す順序を把握しておく必要があります。 (WebMatrix では、IntelliSense を使用して、パラメーターの名前、型、および順序を理解することができます)。
> 
> 値を順番に渡す代わりに、*名前付きパラメーター*を使用することもできます。 (パラメーターを順序どおりに渡すことは、*位置指定パラメーター*を使用すると呼ばれます)。名前付きパラメーターの場合は、その値を渡すときに、パラメーターの名前を明示的に指定します。 これらのチュートリアルでは、既に複数の名前付きパラメーターを使用しています。 次に例を示します。
> 
> [!code-csharp[Main](updating-data/samples/sample8.cs)]
> 
> and
> 
> [!code-css[Main](updating-data/samples/sample9.css)]
> 
> 名前付きパラメーターは、いくつかの状況で便利です。特に、メソッドが多数のパラメーターを受け取る場合です。 1つまたは2つのパラメーターのみを渡す必要があるが、渡す値がパラメーターリスト内の最初の位置に含まれていない場合です。 もう1つの状況は、ユーザーにとって最も意味のある順序でパラメーターを渡すことにより、コードを読みやすくすることです。
> 
> 名前付きパラメーターを使用するには、パラメーターの名前を把握しておく必要があります。 WebMatrix IntelliSense では名前が*表示*されますが、現在はそれらを入力することはできません。

## <a name="creating-the-edit-page"></a>編集ページの作成

これで、 *Editmovie*ページを作成できるようになりました。 ユーザーが **[編集]** リンクをクリックすると、このページが表示されます。

*Editmovie*という名前のページを作成し、ファイルの内容を次のマークアップに置き換えます。

[!code-cshtml[Main](updating-data/samples/sample10.cshtml)]

このマークアップとコードは、 *Addmovie*ページと似ています。 [送信] ボタンのテキストには若干の違いがあります。 *Addmovie*ページと同様に、`Html.ValidationSummary` の呼び出しによって検証エラーが表示されます。 ここでは、エラーが検証の概要に表示されるため、`Validation.Message`を呼び出すことはありません。 前のチュートリアルで説明したように、さまざまな組み合わせで検証の概要と個々のエラーメッセージを使用できます。

`<form>` 要素の `method` 属性が `post`に設定されていることを確認します。 *Addmovie. cshtml*ページと同様に、このページではデータベースを変更します。 したがって、このフォームでは `POST` 操作を実行する必要があります。 (`GET` 操作と `POST` 操作の違いの詳細については、HTML フォームに関するチュートリアルの「 [GET、POST、および HTTP 動詞の安全性](form-basics.md#GET,_POST,_and_HTTP_Verb_Safety)に関する補足記事」を参照してください)。

前のチュートリアルで見たように、テキストボックスの `value` 属性は、事前にプリロードするために Razor コードで設定されています。 ここでは、`Request.Form["title"]`ではなく、そのタスクに対して `title` や `genre` などの変数を使用しています。

`<input type="text" name="title" value="@title" />`

前と同様に、このマークアップによってテキストボックスの値がムービーの値で読み込まれます。 この時点では、`Request` オブジェクトを使用する代わりに、変数を使用すると便利です。

このページには `<input type="hidden">` 要素もあります。 この要素には、ページに表示されることなくムービー ID が格納されます。 ID が最初にページに渡されるのは、クエリ文字列の値 (`?id=7` または URL に似ています) を使用しています。 ID 値を隠しフィールドに設定すると、そのページが呼び出された元の URL にアクセスできなくなった場合でも、フォームが送信されたときに使用できるようになります。

*Addmovie*ページとは異なり、 *editmovie*ページのコードには、2つの異なる関数があります。 最初の関数は、ページが初めて表示されるとき (その後*のみ*)、コードがクエリ文字列からムービー ID を取得することです。 次に、ID を使用して、対応するムービーをデータベースから読み取り、テキストボックスに表示 (プリロード) します。

2番目の関数は、ユーザーが **[変更の送信]** ボタンをクリックしたときに、コードがテキストボックスの値を読み取って検証する必要があることです。 このコードでは、データベース項目を新しい値で更新する必要もあります。 この手法は、 *Addmovie*で見たように、レコードを追加することと似ています。

## <a name="adding-code-to-read-a-single-movie"></a>1つのムービーを読み取るコードを追加する

最初の関数を実行するには、次のコードをページの先頭に追加します。

[!code-cshtml[Main](updating-data/samples/sample11.cshtml)]

このコードのほとんどは、`if(!IsPost)`を開始するブロック内にあります。 `!` 演算子は "not" を意味します。したがって、この*要求が post 送信*ではないことを意味します。これは、この要求がこの*ページが初めて実行されたときにこの要求が行われたかどうか*を示す間接的な方法です。 前述のように、このコードはページを初めて実行するときに*のみ*実行してください。 コードを `if(!IsPost)`で囲まなかった場合は、最初にページが呼び出されるたびに、またはボタンのクリックに応答して実行されます。

このコードには `else` ブロックが含まれていることに注意してください。 前述したように、`if` ブロックを導入したときに、テストしている条件が満たされない場合は、代替コードを実行することが必要になることがあります。 ここで説明します。 条件が成功した場合 (つまり、ページに渡された ID が ok である場合)、データベースから行を読み取ります。 ただし、条件が合格しなかった場合は、`else` ブロックが実行され、コードによってエラーメッセージが設定されます。

## <a name="validating-a-value-passed-to-the-page"></a>ページに渡された値を検証しています

このコードでは、`Request.QueryString["id"]` を使用して、ページに渡される ID を取得します。 コードを使用すると、ID に対して実際に値が渡されたことを確認できます。 値が渡されなかった場合、コードは検証エラーを設定します。

このコードは、情報を検証する別の方法を示しています。 前のチュートリアルでは、`Validation` ヘルパーを使用しました。 検証するためのフィールドが登録されており、`Html.ValidationMessage` と `Html.ValidationSummary`を使用して、検証エラーと表示エラーが自動的に ASP.NET されました。 ただし、この例では、ユーザー入力を実際には検証していません。 代わりに、他の場所からページに渡された値を検証しています。 `Validation` ヘルパーはこれを行いません。

そのため、`if(!Request.QueryString["ID"].IsEmpty()`でテストして、自分で値を確認します。 問題が発生した場合は、`Validation` ヘルパーの場合と同様に、`Html.ValidationSummary`を使用してエラーを表示できます。 これを行うには、`Validation.AddFormError` を呼び出し、表示するメッセージを渡します。 `Validation.AddFormError` は、既に使い慣れている検証システムに関連付けられたカスタムメッセージを定義できる組み込みのメソッドです。 (このチュートリアルの後半で、この検証プロセスをもう少し堅牢にする方法について説明します)。

ムービーの ID があることを確認した後、コードはデータベースを読み取り、データベースアイテムを1つだけ探します。 (データベースの操作の一般的なパターンに気付きました。データベースを開き、SQL ステートメントを定義して、ステートメントを実行してください)。今回は、SQL `Select` ステートメントに `WHERE ID = @0`が含まれています。 ID は一意であるため、返されるレコードは1つだけです。

このクエリは、`db.Query`(ムービーの一覧表示に使用したように) `db.QuerySingle` を使用して実行され、コードによって `row` 変数に結果が挿入されます。 `row` 名前は任意です。変数には任意の名前を指定できます。 上部で初期化された変数は、これらの値がテキストボックスに表示されるように、ムービーの詳細を入力します。

## <a name="testing-the-edit-page-so-far"></a>編集ページのテスト (これまで)

ページをテストする場合は、今すぐ*ムービー*ページを実行し、ムービーの横にある **[編集]** リンクをクリックします。 [ *Editmovie* ] ページが表示され、選択したムービーの詳細が入力されます。

![編集するムービーを表示するムービーページを編集する](updating-data/_static/image3.png)

ページの URL に `?id=10` (またはその他の数値) のようなものが含まれていることに注意してください。 ここまでで、*ムービー*ページ内の**編集**リンクが機能していること、つまり、ページがクエリ文字列から ID を読み取っていること、および1つのムービーレコードを取得するためのデータベースクエリが機能していることをテストしました。

ムービー情報は変更できますが、 **[変更の送信]** をクリックしても何も起こりません。

## <a name="adding-code-to-update-the-movie-with-the-users-changes"></a>ユーザーの変更によってムービーを更新するコードを追加する

*Editmovie. cshtml*ファイルで、2番目の関数 (変更の保存) を実装するには、`@` ブロックの右中かっこの内側に次のコードを追加します。 (コードの配置場所が正確でない場合は、このチュートリアルの最後に表示される[[ムービーの編集] ページの完全なコードリスト](#Complete_Page_Listing_for_EditMovie)を参照してください)。

[!code-csharp[Main](updating-data/samples/sample12.cs)]

ここでも、このマークアップとコードは、 *Addmovie*のコードに似ています。 このコードは `if(IsPost)` ブロックに含まれています。このコードは、ユーザーが **[変更の送信]** ボタンをクリックしたときにのみ実行されます。その理由は、フォームがポストされたとき (およびの場合のみ) &mdash; です。 この例では、`if(IsPost && Validation.IsValid())`のようなテストを使用していません。つまり、とを使用して両方のテストを組み合わせることはありません。 このページでは、最初にフォーム送信 (`if(IsPost)`) があるかどうかを確認し、次に検証用のフィールドを登録します。 その後、検証結果 (`if(Validation.IsValid()`) をテストできます。 このフローは、 *Addmovie. cshtml*ページとは少し異なりますが、効果は同じです。

テキストボックスの値を取得するには、他の `<input>` 要素の `Request.Form["title"]` と同様のコードを使用します。 今回は、コードが隠しフィールド (`<input type="hidden">`) からムービー ID を取得することに注意してください。 ページが初めて実行されたとき、コードはクエリ文字列から ID を取り出しました。 [非表示] フィールドから値を取得して、最初に表示されたムービーの ID を取得していることを確認します。その後、クエリ文字列が何らかの変更を加えられた場合に備えています。

*Addmovie*コードとこのコードの間で本当に重要な違いは、このコードでは、`Insert Into` ステートメントの代わりに SQL `Update` ステートメントを使用することです。 次の例は、SQL `Update` ステートメントの構文を示しています。

`UPDATE table SET col1="value", col2="value", col3="value" ... WHERE ID = value`

任意の順序で任意の列を指定できます。また、必ずしも `Update` 操作中にすべての列を更新する必要はありません。 (ID 自体を更新することはできません。これは、レコードを新しいレコードとして保存し、`Update` 操作では許可されないためです)。

> [!NOTE] 
> 
> **重要**ID がの `Where` 句は、どのデータベースレコードを更新するかをデータベースが認識しているため、非常に重要です。 `Where` 句を省略した場合、データベース内の*すべて*のレコードが更新されます。 ほとんどの場合、障害が発生します。

コードでは、更新する値はプレースホルダーを使用して SQL ステートメントに渡されます。 前に説明した内容を繰り返すには: セキュリティ上の理由から、プレースホルダーを使用して SQL ステートメントに値を渡す*だけ*です。

コードで `db.Execute` を使用して `Update` ステートメントを実行すると、一覧ページにリダイレクトされ、変更内容が表示されます。

> [!TIP] 
> 
> **さまざまな SQL ステートメント、異なるメソッド**
> 
> 異なる SQL ステートメントを実行するには、少し異なる方法を使用することに気付いたかもしれません。 複数のレコードを返す可能性のある `Select` クエリを実行するには、`Query` メソッドを使用します。 データベース項目を1つだけ返すことがわかっている `Select` クエリを実行するには、`QuerySingle` メソッドを使用します。 変更を加えるがデータベース項目を返さないコマンドを実行するには、`Execute` メソッドを使用します。
> 
> `Query` と `QuerySingle`の違いについて既に説明したように、それぞれが異なる結果を返すため、異なる方法を使用する必要があります。 (`Execute` メソッドでは、実際には、コマンド &mdash; によって影響を受けたデータベース行の数 &mdash; も値を返しますが、これまでは無視しています)。
> 
> もちろん、`Query` メソッドは、1つのデータベース行だけを返す場合があります。 ただし、ASP.NET は常に `Query` メソッドの結果をコレクションとして扱います。 メソッドが1行だけを返す場合でも、コレクションからその1行を抽出する必要があります。 したがって、1つの行だけを取得することが*わかっ*ている場合は、`QuerySingle`を使用する方がもう少し便利です。
> 
> 特定の種類のデータベース操作を実行する方法は他にもいくつかあります。 データベースメソッドの一覧については、「 [ASP.NET WEB ページ API クイックリファレンス](../../api-reference/asp-net-web-pages-api-reference.md#Data)」を参照してください。

## <a name="making-validation-for-the-id-more-robust"></a>ID の検証の堅牢性を高める

ページを初めて実行するときは、クエリ文字列からムービー ID を取得して、データベースからそのムービーを取得できるようにします。 実際には、次のコードを使用して検索する値があることを確認しました。

[!code-csharp[Main](updating-data/samples/sample13.cs)]

このコードを使用し*て、最初にムービーページで*ムービーを選択せずに、 *editmovies*ページにユーザーがいた場合に、ユーザーにわかりやすいエラーメッセージが表示されるようにしています。 (それ以外の場合、ユーザーには、混同される可能性のあるエラーが表示されます)。

ただし、この検証は非常に堅牢ではありません。 次のエラーでページが呼び出されることもあります。

- ID が数値ではありません。 たとえば、`http://localhost:nnnnn/EditMovie?id=abc`のような URL を使用してページを呼び出すことができます。
- ID は数値ですが、存在しないムービー (`http://localhost:nnnnn/EditMovie?id=100934`など) を参照しています。

これらの Url によって発生したエラーを確認するには、[*ムービー* ] ページを実行します。 編集するムービーを選択し、[ *editmovie* ] ページの url を、アルファベット ID または存在しないムービーの id を含む url に変更します。

では、どうすればよいでしょうか。 最初の修正は、ページに渡される ID だけでなく、ID が整数であることを確認することです。 `!IsPost` テストのコードを次の例のように変更します。

[!code-csharp[Main](updating-data/samples/sample14.cs)]

`&&` (論理 AND) にリンクされた `IsEmpty` テストに2つ目の条件を追加しました。

[!code-csharp[Main](updating-data/samples/sample15.cs)]

[ASP.NET Web ページプログラミング](../introducing-razor-syntax-c.md)チュートリアルの概要では、`AsInt` `AsBool` などのメソッドが文字列を他のデータ型に変換する方法について説明しています。 `IsInt` メソッド (およびその他の `IsBool` や `IsDateTime`など) も似ています。 ただし、実際に変換を実行することなく、文字列を変換*できる*かどうかのみをテストします。 ここでは、基本的に、*クエリ文字列の値を整数に変換できるかどうか*を示しています。

もう1つの潜在的な問題は、存在しないムービーを探していることです。 ムービーを取得するコードは、次のコードのようになります。

[!code-csharp[Main](updating-data/samples/sample16.cs)]

実際のムービーに対応しない `QuerySingle` メソッドに `movieId` 値を渡すと、何も返されず、後続のステートメント (`title=row.Title`など) でエラーが発生します。

ここでも、簡単な修正があります。 `db.QuerySingle` メソッドが結果を返さない場合、`row` 変数は null になります。 そのため、`row` 変数が null であるかどうかを確認してから、値を取得することができます。 次のコードは、`row` オブジェクトから値を取得するステートメントの周囲に `if` ブロックを追加します。

[!code-csharp[Main](updating-data/samples/sample17.cs)]

この2つの追加の検証テストを使用すると、ページの行頭文字がより多くなります。 `!IsPost` のブランチの完全なコードは、次の例のようになります。

[!code-csharp[Main](updating-data/samples/sample18.cs)]

このタスクは、`else` ブロックに適しています。 テストが成功しなかった場合、`else` ブロックによってエラーメッセージが設定されます。

## <a name="adding-a-link-to-return-to-the-movies-page"></a>ムービーページに戻るためのリンクの追加

最終的に役に立つのは、*ムービー*ページにリンクを追加することです。 イベントの通常のフローでは、ユーザーは*ムービー*ページから開始し、 **[編集]** リンクをクリックします。 これにより、[ *Editmovie* ] ページに移動し、ムービーを編集して、ボタンをクリックすることができます。 コードによって変更が処理された後、*ムービー*ページにリダイレクトされます。

ただし

- ユーザーは何も変更しないことを決定する場合があります。
- ユーザーは、最初に [*ムービー* ] ページの **[編集]** リンクをクリックすることなく、このページを取得している可能性があります。

どちらの方法でも、メインの一覧に簡単に戻ることができます。 マークアップの終了 `</form>` タグの直後に次のマークアップを追加 &mdash; と、簡単に修正できます。

[!code-html[Main](updating-data/samples/sample19.html)]

このマークアップは、他の場所で見た `<a>` 要素に同じ構文を使用します。 URL には、"web サイトのルート" を意味する `~` が含まれています。

## <a name="testing-the-movie-update-process"></a>ムービーの更新プロセスのテスト

これで、をテストできるようになりました。 *ムービーページを*実行し、ムービーの横にある **[編集]** をクリックします。 [ *Editmovie* ] ページが表示されたら、ムービーに変更を加え、 **[変更の送信]** をクリックします。 ムービーの一覧が表示されたら、変更が表示されていることを確認します。

検証が機能していることを確認するには、別のムービーの **[編集]** をクリックします。 [ *Editmovie* ] ページが表示されたら、 **[ジャンル]** フィールド (または **[Year]** フィールドまたはその両方) をオフにして、変更を送信します。 期待どおりにエラーが表示されます。

![検証エラーが表示された [ムービーの編集] ページ](updating-data/_static/image4.png)

**[ムービーリストに戻る]** リンクをクリックして変更を破棄し、*ムービー*ページに戻ります。

## <a name="coming-up-next"></a>次へ

次のチュートリアルでは、ムービーレコードを削除する方法について説明します。

## <a name="complete-listing-for-movie-page-updated-with-edit-links"></a>[ムービーの完全な一覧表示] ページ (編集リンクを使用して更新)

[!code-cshtml[Main](updating-data/samples/sample20.cshtml)]

<a id="Complete_Page_Listing_for_EditMovie"></a>
## <a name="complete-page-listing-for-edit-movie-page"></a>[ムービーの編集] ページの完全なページリスト

[!code-cshtml[Main](updating-data/samples/sample21.cshtml)]

## <a name="additional-resources"></a>その他のリソース

- [Razor 構文を使用した ASP.NET Web プログラミングの概要](../../getting-started/introducing-razor-syntax-c.md)
- W3Schools サイトでの[SQL UPDATE ステートメント](http://www.w3schools.com/sql/sql_update.asp)

> [!div class="step-by-step"]
> [前へ](entering-data.md)
> [次へ](deleting-data.md)
