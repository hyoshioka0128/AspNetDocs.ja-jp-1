---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: SignalR での接続の有効期間イベントの理解と処理 |マイクロソフトドキュメント
author: bradygaster
description: この記事では、Hubs API によって公開されるイベントの使用方法について説明します。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675827"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="f5c0c-103">SignalR の接続有効期間イベントについて理解し、処理する</span><span class="sxs-lookup"><span data-stu-id="f5c0c-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="f5c0c-104">この記事では、処理できる SignalR 接続、再接続、および切断イベントの概要、および構成可能なタイムアウトとキープアライブ設定について説明します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="f5c0c-105">この記事では、SignalR と接続の有効期間イベントに関する知識が既にあるものとします。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="f5c0c-106">SignalR の概要については[、「SignalR の概要](../getting-started/introduction-to-signalr.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="f5c0c-107">接続の有効期間イベントの一覧については、次のリソースを参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="f5c0c-108">ハブ クラスで接続の有効期間イベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="f5c0c-109">JavaScript クライアントで接続の有効期間イベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="f5c0c-110">NET クライアントで接続の有効期間イベントを処理する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="f5c0c-111">このトピックで使用するソフトウェアバージョン</span><span class="sxs-lookup"><span data-stu-id="f5c0c-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="f5c0c-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="f5c0c-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="f5c0c-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="f5c0c-113">.NET 4.5</span></span>
> - <span data-ttu-id="f5c0c-114">シグナル・バージョン 2</span><span class="sxs-lookup"><span data-stu-id="f5c0c-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="f5c0c-115">このトピックの以前のバージョン</span><span class="sxs-lookup"><span data-stu-id="f5c0c-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="f5c0c-116">SignalR の以前のバージョンについては[、SignalR の古いバージョン](../older-versions/index.md)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="f5c0c-117">質問とコメント</span><span class="sxs-lookup"><span data-stu-id="f5c0c-117">Questions and comments</span></span>
>
> <span data-ttu-id="f5c0c-118">このチュートリアルを気に入った方法と、ページの下部にあるコメントで改善できる内容についてのフィードバックを残してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="f5c0c-119">チュートリアルに直接関連しない質問がある場合は[、ASP.NET SignalR フォーラム](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)または[StackOverflow.com](http://stackoverflow.com/)に投稿できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="f5c0c-120">概要</span><span class="sxs-lookup"><span data-stu-id="f5c0c-120">Overview</span></span>

<span data-ttu-id="f5c0c-121">このトピックの内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="f5c0c-122">接続の有効期間の用語とシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="f5c0c-123">SignalR 接続、トランスポート接続、および物理接続</span><span class="sxs-lookup"><span data-stu-id="f5c0c-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="f5c0c-124">トランスポート切断シナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="f5c0c-125">クライアント切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="f5c0c-126">サーバー切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="f5c0c-127">タイムアウトとキープアライブの設定</span><span class="sxs-lookup"><span data-stu-id="f5c0c-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="f5c0c-128">接続タイムアウト</span><span class="sxs-lookup"><span data-stu-id="f5c0c-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="f5c0c-129">切断タイムアウト</span><span class="sxs-lookup"><span data-stu-id="f5c0c-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="f5c0c-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="f5c0c-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="f5c0c-131">タイムアウトとキープアライブの設定を変更する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="f5c0c-132">切断についてユーザーに通知する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="f5c0c-133">連続的に再接続する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="f5c0c-134">サーバー コードでクライアントを切断する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="f5c0c-135">切断の理由の検出</span><span class="sxs-lookup"><span data-stu-id="f5c0c-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="f5c0c-136">API リファレンストピックへのリンクは、API の .NET 4.5 バージョンに関するトピックです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="f5c0c-137">.NET 4 を使用している場合は[、API のトピックの .NET 4 バージョンを](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="f5c0c-138">接続の有効期間の用語とシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="f5c0c-139">SignalR Hub のイベント ハンドラは`OnReconnected`、特定`OnConnected`のクライアント`OnDisconnected`に対しては実行後ではなく、直接実行できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="f5c0c-140">切断せずに再接続できる理由は、SignalR で 「接続」という単語が使用される方法が複数あるからである。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="f5c0c-141">SignalR 接続、トランスポート接続、および物理接続</span><span class="sxs-lookup"><span data-stu-id="f5c0c-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="f5c0c-142">この記事では *、SignalR 接続*、*トランスポート接続*、および*物理接続*を区別します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="f5c0c-143">**SignalR 接続**は、クライアントとサーバー URL の間の論理的な関係を指し、SignalR API によって維持され、接続 ID によって一意に識別されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="f5c0c-144">この関係に関するデータは SignalR によって維持され、トランスポート接続を確立するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="f5c0c-145">クライアントが`Stop`メソッドを呼び出したとき、または SignalR が失われたトランスポート接続を再確立しようとしているときにタイムアウト制限に達すると、関係が終了し、SignalR がデータを破棄します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="f5c0c-146">**トランスポート接続**とは、クライアントとサーバーの間の論理的な関係を指し、4 つのトランスポート API のいずれかによって維持されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="f5c0c-147">SignalR はトランスポート API を使用してトランスポート接続を作成し、トランスポート API は物理ネットワーク接続の存在に依存してトランスポート接続を作成します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="f5c0c-148">トランスポート接続は、SignalR が終了するか、トランスポート API が物理接続が切断されていることを検出したときに終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="f5c0c-149">**物理的な接続**とは、クライアント コンピュータとサーバー コンピュータ間の通信を容易にする、物理的なネットワーク リンク (ワイヤー、ワイヤレス信号、ルーターなど) を指します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="f5c0c-150">トランスポート接続を確立するには物理接続が存在し、SignalR 接続を確立するためにはトランスポート接続を確立する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="f5c0c-151">ただし、物理接続を切断しても、このトピックで後述するとおり、トランスポート接続または SignalR 接続がすぐに終了するとは限りません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="f5c0c-152">次の図では、SignalR 接続はハブ API と PersistentConnection API SignalR レイヤーで表され、トランスポート接続はトランスポート層で表され、物理的な接続はサーバーとクライアント間の線で表されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR アーキテクチャ図](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="f5c0c-154">SignalR クライアント`Start`でメソッドを呼び出すときに、サーバーへの物理的な接続を確立するために必要なすべての情報を SignalR クライアント コードを提供します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="f5c0c-155">SignalR クライアント コードは、この情報を使用して HTTP 要求を行い、4 つのトランスポート方法のいずれかを使用する物理接続を確立します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="f5c0c-156">トランスポート接続が失敗した場合やサーバーに障害が発生した場合、クライアントには、同じ SignalR URL への新しいトランスポート接続を自動的に再確立するために必要な情報が残っているため、SignalR 接続はすぐには消えません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="f5c0c-157">このシナリオでは、ユーザー アプリケーションからの介入は関係なく、SignalR クライアント コードが新しいトランスポート接続を確立するとき、新しい SignalR 接続を開始しません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="f5c0c-158">SignalR 接続の連続性は、メソッドを呼び出したときに作成される接続 ID が変更されないという`Start`事実に反映されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="f5c0c-159">ハブ`OnReconnected`のイベント ハンドラは、トランスポート接続が失われた後に自動的に再確立されたときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="f5c0c-160">イベント`OnDisconnected`ハンドラーは、SignalR 接続の終了時に実行されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="f5c0c-161">SignalR 接続は、次のいずれかの方法で終了できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="f5c0c-162">クライアントがメソッドを呼`Stop`び出した場合、停止メッセージがサーバーに送信され、クライアントとサーバーの両方がただちに SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="f5c0c-163">クライアントとサーバー間の接続が失われると、クライアントは再接続を試み、サーバーはクライアントの再接続を待機します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="f5c0c-164">再接続が失敗し、切断タイムアウト期間が終了した場合、クライアントとサーバーの両方が SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="f5c0c-165">クライアントは再接続を停止し、サーバーは SignalR 接続の表現を破棄します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="f5c0c-166">`Stop`クライアントがメソッドを呼び出す機会を持たずに実行を停止した場合、サーバーはクライアントが再接続するのを待ち、切断タイムアウト期間が経過した後に SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="f5c0c-167">サーバーが停止すると、クライアントは再接続 (トランスポート接続の再作成) を試み、切断タイムアウト期間が経過した後に SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="f5c0c-168">接続に問題がなく、ユーザー アプリケーションがメソッドを呼び出して SignalR`Stop`接続を終了すると、SignalR 接続とトランスポート接続が同じ時間に開始および終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="f5c0c-169">以降のセクションでは、その他のシナリオについて詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="f5c0c-170">トランスポート切断シナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="f5c0c-171">物理接続が遅い場合や、接続が中断される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="f5c0c-172">中断の長さなどの要因によっては、トランスポート接続がドロップされる場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="f5c0c-173">SignalR は、トランスポート接続の再確立を試みます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="f5c0c-174">トランスポート接続 API が中断を検出してトランスポート接続をドロップし、SignalR が接続が失われたことをすぐに検出することがあります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="f5c0c-175">他のシナリオでは、トランスポート接続 API も SignalR も、接続が失われたことをすぐに認識しなくなります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="f5c0c-176">長いポーリングを除くすべてのトランスポートで、SignalR クライアントは*キープアライブ*という関数を使用して、トランスポート API が検出できない接続の損失をチェックします。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="f5c0c-177">長時間ポーリング接続については、このトピックの後半の[「タイムアウトとキープアライブの設定](#timeoutkeepalive)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="f5c0c-178">接続が非アクティブの場合、サーバーは定期的にキープアライブ パケットをクライアントに送信します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="f5c0c-179">この記事が作成された時点で、デフォルトの頻度は 10 秒ごとに設定されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="f5c0c-180">これらのパケットをリッスンすることで、クライアントは接続に問題があるかどうかを知ることができます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="f5c0c-181">キープアライブ パケットが予期したタイミングで受信されない場合、しばらくするとクライアントは、低速や中断などの接続の問題があると見なします。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="f5c0c-182">キープアライブが長時間経過してもまだ受信されない場合、クライアントは接続が切断されたと見なし、再接続を試みます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="f5c0c-183">次の図は、トランスポート API ですぐに認識されない物理接続に問題がある場合に、一般的なシナリオで発生するクライアント イベントとサーバー イベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="f5c0c-184">この図は、次の状況に適用されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="f5c0c-185">トランスポートは、WebSocket、永遠のフレーム、またはサーバーから送信されるイベントです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="f5c0c-186">物理ネットワーク接続の中断の期間はさまざまです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="f5c0c-187">トランスポート API は中断を認識しないため、SignalR はキープアライブ機能に依存してそれらを検出します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![トランスポート切断](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="f5c0c-189">クライアントが再接続モードに入っても、切断タイムアウトの制限内でトランスポート接続を確立できない場合、サーバーは SignalR 接続を終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="f5c0c-190">その場合、サーバーはハブの`OnDisconnected`メソッドを実行し、クライアントが後で接続する場合に備えて、クライアントに送信する切断メッセージをキューに入れます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="f5c0c-191">その後、クライアントが再接続すると、disconnect コマンドを受け取り`Stop`、メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="f5c0c-192">このシナリオでは、`OnReconnected`クライアントが再接続したときに実行されず、クライアント`OnDisconnected`が呼び出`Stop`されたときには実行されません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="f5c0c-193">次の図は、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-193">The following diagram illustrates this scenario.</span></span>

![トランスポートの中断 - サーバー タイムアウト](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="f5c0c-195">クライアントで発生する SignalR 接続の有効期間イベントは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="f5c0c-196">`ConnectionSlow`クライアント イベント。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="f5c0c-197">最後のメッセージまたはキープアライブ ping を受信してから、キープアライブ タイムアウト期間の事前設定された割合が経過したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="f5c0c-198">既定のキープアライブ タイムアウト警告期間は、キープアライブ タイムアウトの 2/3 です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="f5c0c-199">キープアライブ タイムアウトは 20 秒なので、警告は約 13 秒で発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="f5c0c-200">デフォルトでは、サーバーはキープアライブ ping を 10 秒ごとに送信し、クライアントは約 2 秒ごとにキープアライブ ping をチェックします (キープアライブ タイムアウト値とキープアライブ タイムアウト警告値の差の 1/3)。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="f5c0c-201">トランスポート API が切断を認識した場合、キープアライブ タイムアウト警告期間が経過する前に、SignalR に切断が通知される場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="f5c0c-202">その場合、`ConnectionSlow`イベントは発生せず、SignalR はイベントに直接移動します`Reconnecting`。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="f5c0c-203">`Reconnecting`クライアント イベント。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="f5c0c-204">(a) トランスポート API が接続が失われたことを検出した場合、または (b) 最後のメッセージまたはキープアライブ ping が受信されてからキープアライブ・タイムアウト期間が経過した場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="f5c0c-205">SignalR クライアント コードが再接続を試み始めます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="f5c0c-206">トランスポート接続が失われたときにアプリケーションで何らかのアクションを実行する場合は、このイベントを処理できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="f5c0c-207">既定のキープアライブ タイムアウト期間は現在 20 秒です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="f5c0c-208">SignalR が再接続モードのときにクライアント コードがハブ メソッドを呼び出そうとすると、SignalR はコマンドの送信を試みます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="f5c0c-209">ほとんどの場合、そのような試みは失敗しますが、状況によっては成功する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="f5c0c-210">サーバー送信イベント、永遠にフレーム、および長時間ポーリング トランスポートの SignalR は、2 つの通信チャネルを使用します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="f5c0c-211">受信に使用されるチャネルは、永続的に開かれたチャネルであり、物理的な接続が中断されたときに閉じられるチャネルです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="f5c0c-212">送信に使用されるチャネルは使用可能なままであるため、物理接続が復元された場合、受信チャネルが再確立される前に、クライアントからサーバーへのメソッド呼び出しが成功する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="f5c0c-213">SignalR が受信に使用されるチャネルを再度開くまで、戻り値は受信されません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="f5c0c-214">`Reconnected`クライアント イベント。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="f5c0c-215">トランスポート接続が再確立されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="f5c0c-216">ハブ`OnReconnected`内のイベント ハンドラーが実行されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="f5c0c-217">`Closed`クライアント イベント`disconnected`( JavaScript のイベント ) 。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="f5c0c-218">トランスポート接続が切断された後に SignalR クライアント コードが再接続しようとしている間に切断タイムアウト期間が経過したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="f5c0c-219">デフォルトの切断タイムアウトは 30 秒です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="f5c0c-220">(このイベントは、メソッドが呼び出されたために`Stop`接続が終了したときにも発生します)。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="f5c0c-221">トランスポート API によって検出されず、キープアライブ のタイムアウト警告期間よりも長い間、サーバーからのキープアライブ ping の受信を遅延しないトランスポート接続の中断は、接続の有効期間イベントが発生しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="f5c0c-222">一部のネットワーク環境では、意図的にアイドル状態の接続を閉じる、キープアライブ パケットの別の機能は、SignalR 接続が使用中であることをこれらのネットワークに知らせることによって、これを防ぐために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="f5c0c-223">極端な場合、キープアライブ ping のデフォルトの頻度では、接続が閉じられるのを防ぐには十分でない場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="f5c0c-224">その場合、より頻繁に送信されるようにキープアライブ ping を設定できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="f5c0c-225">詳細については、このトピックの後半の「[タイムアウトとキープアライブの設定](#timeoutkeepalive)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="f5c0c-226">**重要**: ここで説明する一連のイベントは保証されません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="f5c0c-227">SignalR は、このスキームに従って予測可能な方法で接続の有効期間イベントを発生させようとしますが、ネットワーク イベントの多くのバリエーションと、トランスポート API などの基になる通信フレームワークがそれらを処理するさまざまな方法があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="f5c0c-228">たとえば、クライアントが`Reconnected`再接続した場合にイベントが発生しない場合や、接続の`OnConnected`確立が失敗したときにサーバー上のハンドラーが実行される場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="f5c0c-229">このトピックでは、通常は特定の典型的な状況によって生じる効果のみを説明します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="f5c0c-230">クライアント切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-230">Client disconnection scenarios</span></span>

<span data-ttu-id="f5c0c-231">ブラウザー クライアントでは、SignalR 接続を維持する SignalR クライアント コードは、Web ページの JavaScript コンテキストで実行されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="f5c0c-232">そのため、SignalR 接続は、1 つのページから別のページに移動するときに終了する必要があり、複数のブラウザー ウィンドウまたはタブから接続する場合は、複数の接続 ID を持つ複数の接続を持っている理由です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="f5c0c-233">ユーザーがブラウザー ウィンドウまたはタブを閉じたり、新しいページに移動したり、ページを更新したりすると、SignalR クライアント コードがブラウザ イベントを処理してメソッドを呼び出す`Stop`ため、SignalR 接続は直ちに終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="f5c0c-234">このようなシナリオ、またはアプリケーションがメソッドを呼び出すときに任意の`Stop`クライアント プラットフォーム`OnDisconnected`では、イベント ハンドラーがサーバーで直ちに実行され、`Closed`クライアントがイベントを発生させます`disconnected`(イベントは JavaScript で指定されています)。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="f5c0c-235">クライアント アプリケーションまたは、そのアプリケーションを実行しているコンピューターがクラッシュしたり、スリープ状態になった場合 (ユーザーがラップトップを閉じた場合など)、サーバーは何が起こったかを通知されません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="f5c0c-236">サーバーが知る限り、クライアントの損失は接続の中断によるもので、クライアントが再接続しようとしている可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="f5c0c-237">したがって、このようなシナリオでは、サーバーはクライアントに再接続の機会を与えるために待機し`OnDisconnected`、切断タイムアウト期間が満了するまで (デフォルトでは約 30 秒) 実行されません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="f5c0c-238">次の図は、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-238">The following diagram illustrates this scenario.</span></span>

![クライアント コンピュータの障害](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="f5c0c-240">サーバー切断のシナリオ</span><span class="sxs-lookup"><span data-stu-id="f5c0c-240">Server disconnection scenarios</span></span>

<span data-ttu-id="f5c0c-241">サーバーがオフラインになると、再起動、失敗、アプリ ドメインのリサイクルなどが発生し、接続が失われた場合や、トランスポート API と SignalR がサーバーのデータを削除したことをすぐに認識し`ConnectionSlow`、SignalR がイベントを発生させずに再接続を試みる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="f5c0c-242">クライアントが再接続モードに入り、切断タイムアウト期間が終了する前にサーバーが回復または再起動するか、新しいサーバーがオンラインになった場合、クライアントは復元されたサーバーまたは新しいサーバーに再接続します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="f5c0c-243">その場合、SignalR 接続はクライアントで続行され、イベント`Reconnected`が発生します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="f5c0c-244">最初のサーバーでは、`OnDisconnected`実行されることはなく、新しいサーバー上では`OnReconnected`、そのサーバー`OnConnected`上のクライアントに対して実行されたことはありませんが、実行されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="f5c0c-245">(再起動後またはアプリケーション ドメインのリサイクル後にクライアントが同じサーバーに再接続した場合も、サーバーが再起動すると、以前の接続アクティビティのメモリが存在しないため、この影響は同じです)。次の図では、トランスポート API が失われた接続をすぐに認識し、`ConnectionSlow`イベントが発生しないことを前提としています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![サーバー障害と再接続](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="f5c0c-247">切断タイムアウト時間内にサーバーが使用可能にならない場合、SignalR 接続は終了します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="f5c0c-248">このシナリオでは`Closed`、(JavaScript`disconnected`クライアントの) イベントはクライアントで発生します`OnDisconnected`が、サーバー上で呼び出されることはありません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="f5c0c-249">次の図では、トランスポート API が接続が失われたことを認識しないため、SignalR キープアライブ機能によって検出され`ConnectionSlow`、イベントが発生することを前提としています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![サーバー障害とタイムアウト](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="f5c0c-251">タイムアウトとキープアライブの設定</span><span class="sxs-lookup"><span data-stu-id="f5c0c-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="f5c0c-252">既定`ConnectionTimeout`の`DisconnectTimeout`、 `KeepAlive` 、および 値はほとんどのシナリオに適していますが、環境に特別なニーズがある場合は変更できます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="f5c0c-253">たとえば、ネットワーク環境でアイドル状態の接続が 5 秒間閉じた場合、キープアライブ値を減らす必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="f5c0c-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="f5c0c-254">ConnectionTimeout</span></span>

<span data-ttu-id="f5c0c-255">この設定は、トランスポート接続を開いたままにして応答を待機してから、その接続を閉じて新しい接続を開く時間を表します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="f5c0c-256">デフォルト値は 110 秒です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="f5c0c-257">この設定は、キープアライブ機能が無効になっている場合にのみ適用され、通常は長時間ポーリング トランスポートにのみ適用されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="f5c0c-258">次の図は、この設定が長時間ポーリング トランスポート接続に及ぼす影響を示しています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![ロングポーリングトランスポート接続](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="f5c0c-260">切断タイムアウト</span><span class="sxs-lookup"><span data-stu-id="f5c0c-260">DisconnectTimeout</span></span>

<span data-ttu-id="f5c0c-261">この設定は、イベントを発生させる前にトランスポート接続が失われた後に待機`Disconnected`する時間を表します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="f5c0c-262">既定値は 30 秒です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-262">The default value is 30 seconds.</span></span> <span data-ttu-id="f5c0c-263">を設定`DisconnectTimeout`すると`KeepAlive`、自動的に値の 1/3`DisconnectTimeout`に設定されます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="f5c0c-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="f5c0c-264">KeepAlive</span></span>

<span data-ttu-id="f5c0c-265">この設定は、アイドル接続を介してキープアライブ パケットを送信するまでの待機時間を表します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="f5c0c-266">既定値は 10 秒です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-266">The default value is 10 seconds.</span></span> <span data-ttu-id="f5c0c-267">この値は、値の`DisconnectTimeout`1/3 を超える値であってはなりません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="f5c0c-268">`DisconnectTimeout`と の両方を設定する`KeepAlive`場合は`KeepAlive`、`DisconnectTimeout`の後に設定します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="f5c0c-269">それ以外`KeepAlive`の場合は、タイムアウト値`DisconnectTimeout`の`KeepAlive`1/3 に自動的に設定すると、設定が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="f5c0c-270">キープアライブ機能を無効にする場合`KeepAlive`は、null に設定します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="f5c0c-271">長期ポーリング トランスポートでは、キープアライブ機能は自動的に無効になります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="f5c0c-272">タイムアウトとキープアライブの設定を変更する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="f5c0c-273">これらの設定の既定値を変更するには、次の例に`Application_Start`示すように *、Global.asax*ファイルで設定します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="f5c0c-274">サンプル コードに示されている値は、既定値と同じです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="f5c0c-275">切断についてユーザーに通知する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="f5c0c-276">アプリケーションによっては、接続に問題がある場合にユーザーにメッセージを表示する必要がある場合があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="f5c0c-277">これを行う方法とタイミングには、いくつかのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="f5c0c-278">次のコード サンプルは、生成されたプロキシを使用する JavaScript クライアント用です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="f5c0c-279">イベントを`connectionSlow`処理して、SignalR が接続の問題を認識すると、再接続モードに入る前に、メッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="f5c0c-280">SignalR`reconnecting`が切断を認識し、再接続モードに入るとき、イベントを処理してメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="f5c0c-281">再接続の`disconnected`試行がタイムアウトしたときにメッセージを表示するイベントを処理します。このシナリオでは、サーバーとの接続を再確立する唯一の方法は、新しい接続 ID を作成する`Start`メソッドを呼び出すことによって SignalR 接続を再起動することです。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="f5c0c-282">次のコード サンプルでは、メソッドの呼び出しによって発生した SignalR 接続の通常の終了後ではなく、再接続タイムアウト後にのみ通知を発行することを`Stop`確認するフラグを使用します。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="f5c0c-283">連続的に再接続する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-283">How to continuously reconnect</span></span>

<span data-ttu-id="f5c0c-284">アプリケーションによっては、接続が失われ、再接続の試行がタイムアウトになった後に、接続を自動的に再確立する必要がある場合があります。これを行うには、`Start``Closed`イベント ハンドラー (JavaScript クライアントの`disconnected`イベント ハンドラー) からメソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="f5c0c-285">サーバーまたは物理接続が使用できない場合に、頻`Start`繁に行わないように、呼び出しの前に一定期間待つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="f5c0c-286">次のコード サンプルは、生成されたプロキシを使用する JavaScript クライアント用です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="f5c0c-287">モバイル クライアントで注意する必要がある潜在的な問題は、サーバーまたは物理接続が使用できないときに連続的な再接続を試行すると、不要なバッテリが消耗する可能性があるという点です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="f5c0c-288">サーバー コードでクライアントを切断する方法</span><span class="sxs-lookup"><span data-stu-id="f5c0c-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="f5c0c-289">SignalR バージョン 2 には、クライアントを切断するための組み込みのサーバー API がありません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="f5c0c-290">[今後、この機能を追加する予定](https://github.com/SignalR/SignalR/issues/2101)があります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="f5c0c-291">現在の SignalR リリースでは、クライアントをサーバーから切断する最も簡単な方法は、クライアントに切断メソッドを実装し、そのメソッドをサーバーから呼び出す方法です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="f5c0c-292">次のコード サンプルは、生成されたプロキシを使用する JavaScript クライアントの切断メソッドを示しています。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="f5c0c-293">セキュリティ - クライアントが再接続されたり、ハッキングされたコードがメソッドを削除したり、その動作を変更したりする可能性があるため、クライアントの切断方法も、提案された組み込み API も`stopClient`、悪意のあるコードを実行しているハッキングされたクライアントのシナリオに対処しません。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="f5c0c-294">ステートフルサービス拒否 (DOS) 保護を実装する適切な場所は、フレームワークやサーバー層ではなくフロントエンド インフラストラクチャにあります。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="f5c0c-295">切断の理由の検出</span><span class="sxs-lookup"><span data-stu-id="f5c0c-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="f5c0c-296">SignalR 2.1 は、`OnDisconnect`タイムアウトではなく、クライアントが意図的に切断されているかどうかを示すサーバー イベントにオーバーロードを追加します。クライアント`StopCalled`が明示的に接続を閉じた場合、パラメーターは true です。</span><span class="sxs-lookup"><span data-stu-id="f5c0c-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="f5c0c-297">JavaScript では、サーバー エラーによってクライアントが切断された場合、エラー情報は クライアントに`$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="f5c0c-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="f5c0c-298">**C# サーバー`stopCalled`コード: パラメーター**</span><span class="sxs-lookup"><span data-stu-id="f5c0c-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="f5c0c-299">**JavaScript クライアント コード:`lastError`イベント`disconnect`内でアクセスします。**</span><span class="sxs-lookup"><span data-stu-id="f5c0c-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
