---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: Project Katana | の概要Microsoft Docs
author: howarddierking
description: ASP.NET Framework は10年以上にわたっています。プラットフォームでは、さまざまな Web サイトとサービスの開発が可能になりました。 Web アプリケーションとして...
ms.author: riande
ms.date: 08/30/2013
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 1f28db822930cdfd2ebf4cf9bb27d173f4aa4201
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78500344"
---
# <a name="an-overview-of-project-katana"></a><span data-ttu-id="f48b3-104">プロジェクト Katana の概要</span><span class="sxs-lookup"><span data-stu-id="f48b3-104">An Overview of Project Katana</span></span>

<span data-ttu-id="f48b3-105">[Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="f48b3-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="f48b3-106">ASP.NET Framework は10年以上にわたっています。プラットフォームでは、さまざまな Web サイトとサービスの開発が可能になりました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="f48b3-107">Web アプリケーションの開発戦略が進化するにつれて、ASP.NET MVC や ASP.NET Web API などのテクノロジを使用して、フレームワークを段階的に進化させることができました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="f48b3-108">Web アプリケーションの開発では、クラウドコンピューティングの世界における次の革新的な手順を実行します。そのため、プロジェクト[Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)は、アプリケーションを ASP.NET するためのコンポーネントの基盤となるセットを提供します。これにより、プロジェクトの[Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud は ASP.NET アプリケーションを最適化します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>

## <a name="why-katana--why-now"></a><span data-ttu-id="f48b3-109">Katana の理由-なぜですか。</span><span class="sxs-lookup"><span data-stu-id="f48b3-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="f48b3-110">開発者のフレームワークまたはエンドユーザーの製品について説明しているかどうかにかかわらず、製品作成の根底にある動機を理解することが重要です。これには、製品の作成者を知ることが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="f48b3-111">ASP.NET は、最初は2つの顧客を念頭に置いて作成されました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="f48b3-112">**最初の顧客グループは、従来の ASP 開発者でした。**</span><span class="sxs-lookup"><span data-stu-id="f48b3-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="f48b3-113">この時点で、ASP は interweaving マークアップとサーバー側スクリプトによって動的なデータドリブン Web サイトおよびアプリケーションを作成するための主要なテクノロジの1つでした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="f48b3-114">ASP ランタイムによって提供されるサーバー側スクリプトには、基になる HTTP プロトコルと Web サーバーの主要な側面を抽象化し、セッションやアプリケーションの状態管理やキャッシュなどの追加サービスへのアクセスを提供する、オブジェクトのセットが用意されています。強力な従来の ASP アプリケーションは、サイズと複雑さが増大しているため、管理が困難になっていました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="f48b3-115">これは、ほとんどの場合、スクリプト環境では、コードとマークアップのインターリーブによって生成されるコードの重複と組み合わせた構造がないことが原因でした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-115">This was largely due to the lack of structure found in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="f48b3-116">いくつかの課題に対処しながら従来の ASP の長所を活用するために、ASP.NET は、サーバー側のプログラミングモデルも保持しながら、.NET Framework のオブジェクト指向言語によって提供されるコード編成を利用してきました。従来の ASP 開発者が使い慣れたものです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="f48b3-117">**ASP.NET の対象となる顧客の2番目のグループは、Windows ビジネスアプリケーションの開発者でした。**</span><span class="sxs-lookup"><span data-stu-id="f48b3-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="f48b3-118">HTML マークアップを記述することに慣れている従来の ASP 開発者や、より多くの HTML マークアップを生成するコードは、キャンバスと豊富なユーザーセットを含むデザイン時のエクスペリエンスに慣れていました。インターフェイスコントロール。</span><span class="sxs-lookup"><span data-stu-id="f48b3-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="f48b3-119">最初のバージョンの ASP.NET ("Web フォーム" とも呼ばれます) は、ユーザーインターフェイスコンポーネントのサーバー側のイベントモデルと、シームレスな開発者エクスペリエンスを実現する一連のインフラストラクチャ機能 (ViewState など) と同様のデザイン時のエクスペリエンスを提供していました。クライアント側プログラミングとサーバー側プログラミングの間</span><span class="sxs-lookup"><span data-stu-id="f48b3-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="f48b3-120">Web フォームは、WinForms 開発者にとってなじみのあるステートフルなイベントモデルで、Web のステートレスな性質を効果的に hid します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="f48b3-121">履歴モデルによって発生した課題</span><span class="sxs-lookup"><span data-stu-id="f48b3-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="f48b3-122">**最終的な結果は、成熟した機能豊富なランタイムと開発者向けプログラミングモデルでした。**</span><span class="sxs-lookup"><span data-stu-id="f48b3-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="f48b3-123">しかし、その機能を使用すると、豊富な課題が発生しました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="f48b3-124">まず、フレームワークは**モノリシック**であり、論理的には異なる機能の単位が同じ system.servicemodel アセンブリ (たとえば、web フォームフレームワークを持つコア HTTP オブジェクト) に密に結合されていました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="f48b3-125">第2に、ASP.NET が大きな .NET Framework の一部として含まれていました。これは、**リリース間の時間が年の順に**なったことを意味します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="f48b3-126">これにより、急速に進化する Web 開発で発生するすべての変更に ASP.NET が対応することが困難になりました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="f48b3-127">最後に、system.web は、特定の Web ホスティングオプションに対していくつかの異なる方法で結合されています: インターネットインフォメーションサービス (IIS)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="f48b3-128">進化した手順: ASP.NET MVC と ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="f48b3-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="f48b3-129">また、Web 開発で多くの変更が行われています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="f48b3-130">Web アプリケーションは、大規模なフレームワークではなく、小規模で焦点を絞った一連のコンポーネントとして開発されてきました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="f48b3-131">コンポーネントの数、およびそれらがリリースされた頻度は、より高速に増加しています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="f48b3-132">Web にペースを置くことで、より大規模で特徴が豊富ではなく、より小さな、分離された、さらに焦点を絞ったフレームワークが必要になることが明らかになったので、 **ASP.NET チームは、1つのフレームワークではなく、プラグ可能な Web コンポーネントのファミリとして ASP.NET を有効にするために、いくつか**の</span><span class="sxs-lookup"><span data-stu-id="f48b3-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="f48b3-133">初期の変更点の1つは、Ruby on Rails のような Web 開発フレームワークにより、よく知られているモデルビューコントローラー (MVC) デザインパターンの普及が高まったことでした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="f48b3-134">このスタイルの Web アプリケーションを構築することで、開発者はアプリケーションのマークアップをより細かく制御できるようになり、ASP.NET の最初の販売ポイントの1つであるマークアップとビジネスロジックの分離が維持されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="f48b3-135">このスタイルの Web アプリケーション開発の需要を満たすために、Microsoft では、 **ASP.NET MVC を帯域外で開発**することによって、将来的により適切に配置する機会を獲得しました (.NET Framework には含まれません)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="f48b3-136">ASP.NET MVC は、独立したダウンロードとしてリリースされました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="f48b3-137">これにより、エンジニアリングチームは、以前よりもはるかに頻繁に更新を提供できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="f48b3-138">Web アプリケーション開発のもう1つの大きなシフトは、サーバーで生成された動的な Web ページから、 **AJAX 要求を通じてバックエンド Web api と**通信するクライアント側スクリプトから生成されたページの動的セクションを使用した静的初期マークアップへのシフトです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="f48b3-139">このアーキテクチャシフトは、Web Api の増加と ASP.NET Web API framework の開発に役立ちました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="f48b3-140">ASP.NET MVC の場合と同様に、ASP.NET Web API のリリースでは、さらにモジュール式のフレームワークとして ASP.NET をさらに進化させる機会が提供されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="f48b3-141">エンジニアリングチームは、この機会とビルドされた ASP.NET Web API を利用して、 **system.web で見つかったコアフレームワーク型に依存しないようにしました**。</span><span class="sxs-lookup"><span data-stu-id="f48b3-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="f48b3-142">これにより、2つのことが可能になりました。つまり、ASP.NET Web API は完全に自己完結した方法で進化する可能性がありました (また、NuGet を介して配信されるため、すぐに反復処理を継続できます)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="f48b3-143">2つ目は、System.web に外部依存関係がなく、IIS への依存関係がないため、カスタムホスト (たとえば、コンソールアプリケーション、Windows サービスなど) で実行する機能が含まれている ASP.NET Web API です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="f48b3-144">将来: 機敏なフレームワーク</span><span class="sxs-lookup"><span data-stu-id="f48b3-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="f48b3-145">フレームワークのコンポーネントを相互に分離してから NuGet でリリースすることで、フレームワークが**個別に、より迅速に反復処理**できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="f48b3-146">さらに、Web API の自己ホスト機能の能力と柔軟性は、サービスに対して**小規模で軽量なホスト**を必要とする開発者にとって非常に魅力的です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="f48b3-147">実際には、他のフレームワークもこの機能を必要としていました。そのため、各フレームワークは独自のホストプロセスで独自のベースアドレスを使用して実行され、個別に管理 (開始、停止など) する必要がありました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="f48b3-148">最新の Web アプリケーションでは、一般に、静的ファイルサービス、動的ページ生成、Web API、および最近のリアルタイム/プッシュ通知をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="f48b3-149">これらの各サービスを個別に実行して管理する必要があるということは、単に現実的ではありませんでした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="f48b3-150">必要とされるのは、開発者がさまざまなコンポーネントやフレームワークからアプリケーションを作成し、そのアプリケーションをサポートするホストで実行できるようにする、単一のホストの抽象化でした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="f48b3-151">Open Web Interface for .NET (OWIN)</span><span class="sxs-lookup"><span data-stu-id="f48b3-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="f48b3-152">Ruby コミュニティの[ラック](http://rack.github.io/)によって実現される利点により、Web サーバーとフレームワークコンポーネントの間の抽象化を作成するために、.net コミュニティのいくつかのメンバーが設定されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="f48b3-153">OWIN 抽象化の2つの設計目標は、単純であり、他の種類のフレームワークで考えられる依存関係を最小限に抑えたことでした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="f48b3-154">これらの2つの目標は、次のことを保証します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-154">These two goals help ensure:</span></span>

- <span data-ttu-id="f48b3-155">新しいコンポーネントは、より簡単に開発および使用できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="f48b3-156">アプリケーションは、ホストと、場合によってはプラットフォームやオペレーティングシステム全体にわたって簡単に移植できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="f48b3-157">生成される抽象化は、2つのコア要素で構成されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="f48b3-158">1つ目は環境ディクショナリです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-158">The first is the environment dictionary.</span></span> <span data-ttu-id="f48b3-159">このデータ構造は、HTTP 要求と応答の処理に必要なすべての状態と、関連するサーバーの状態を格納する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="f48b3-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="f48b3-160">環境ディクショナリは次のように定義されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="f48b3-161">OWIN と互換性のある Web サーバーは、HTTP 要求と応答のボディストリームやヘッダーコレクションなどのデータを環境ディクショナリに設定する役割を担います。</span><span class="sxs-lookup"><span data-stu-id="f48b3-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="f48b3-162">次に、追加の値を使用してディクショナリを設定または更新し、応答本文ストリームに書き込むのは、アプリケーションまたはフレームワークコンポーネントの役割です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="f48b3-163">OWIN 仕様では、環境ディクショナリの種類を指定するだけでなく、コアディクショナリのキーと値のペアの一覧を定義します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="f48b3-164">たとえば、次の表は、HTTP 要求に必要なディクショナリキーを示しています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="f48b3-165">キーの名前</span><span class="sxs-lookup"><span data-stu-id="f48b3-165">Key Name</span></span> | <span data-ttu-id="f48b3-166">値の説明</span><span class="sxs-lookup"><span data-stu-id="f48b3-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="f48b3-167">要求本文を含むストリーム (存在する場合)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="f48b3-168">ストリーム。要求本文がない場合は、プレースホルダーとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="f48b3-169">[要求本文](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f48b3-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="f48b3-170">要求ヘッダーの `IDictionary<string, string[]>`。</span><span class="sxs-lookup"><span data-stu-id="f48b3-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="f48b3-171">「[ヘッダー](http://owin.org/html/owin.html#3-3-headers)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f48b3-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="f48b3-172">要求の HTTP 要求メソッド (`"GET"`、`"POST"`など) を格納している `string`。</span><span class="sxs-lookup"><span data-stu-id="f48b3-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="f48b3-173">要求パスを格納している `string`。</span><span class="sxs-lookup"><span data-stu-id="f48b3-173">A `string` containing the request path.</span></span> <span data-ttu-id="f48b3-174">パスは、アプリケーションデリゲートの "ルート" に対する相対パスである必要があります。「[パス](http://owin.org/html/owin.html#5-3-paths)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f48b3-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="f48b3-175">アプリケーションデリゲートの "ルート" に対応する要求パスの部分を含む `string`。「[パス](http://owin.org/html/owin.html#5-3-paths)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f48b3-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="f48b3-176">プロトコルの名前とバージョン (`"HTTP/1.0"` や `"HTTP/1.1"`など) を含む `string`。</span><span class="sxs-lookup"><span data-stu-id="f48b3-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="f48b3-177">HTTP 要求 URI のクエリ文字列コンポーネントを含む `string`。先頭に "?" は使用できません。(例: `"foo=bar&baz=quux"`)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="f48b3-178">値は空の文字列でもかまいません。</span><span class="sxs-lookup"><span data-stu-id="f48b3-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="f48b3-179">要求に使用される URI スキームを含む `string` (例: `"http"`、`"https"`)。「 [URI スキーム](http://owin.org/html/owin.html#5-1-uri-scheme)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f48b3-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="f48b3-180">OWIN の2番目のキー要素はアプリケーションデリゲートです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="f48b3-181">これは、OWIN アプリケーションのすべてのコンポーネント間のプライマリインターフェイスとして機能する関数シグネチャです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="f48b3-182">アプリケーションデリゲートの定義は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="f48b3-183">次に、アプリケーションデリゲートは、関数が環境ディクショナリを入力として受け取り、タスクを返す、Func デリゲート型の実装にすぎません。</span><span class="sxs-lookup"><span data-stu-id="f48b3-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="f48b3-184">この設計には、開発者にとっていくつかの影響があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="f48b3-185">OWIN コンポーネントを記述するために必要な型の依存関係の数は非常に少なくなっています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="f48b3-186">これにより、開発者にとって OWIN のアクセシビリティが大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="f48b3-187">非同期デザインを使用すると、特に i/o 負荷の高い操作で、抽象化をコンピューティングリソースの処理に効率的に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="f48b3-188">アプリケーションデリゲートはアトミック実行の単位であり、環境ディクショナリはデリゲートのパラメーターとして渡されるため、OWIN コンポーネントを簡単に連結して、複雑な HTTP 処理パイプラインを作成できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="f48b3-189">実装の観点から見ると、OWIN は仕様 ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)) です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="f48b3-190">その目的は、次の Web フレームワークではなく、Web フレームワークと Web サーバーがどのように対話するかを指定することです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="f48b3-191">[OWIN](http://owin.org/)または[Katana](https://github.com/aspnet/AspNetKatana/wiki)を調査している場合は、 [OWIN NuGet パッケージ](http://nuget.org/packages/Owin)と OWIN にもご気になるかもしれません。</span><span class="sxs-lookup"><span data-stu-id="f48b3-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="f48b3-192">このライブラリには、 [Iappbuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)という1つのインターフェイスが含まれています。このインターフェイスは、OWIN 仕様の[セクション 4](http://owin.org/html/owin.html#4-application-startup)で説明されているスタートアップシーケンスを形式化して体系化します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="f48b3-193">OWIN サーバーを構築するために必要ではありませんが、 [Iappbuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)インターフェイスは具体的な参照ポイントを提供し、Katana プロジェクトコンポーネントによって使用されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="f48b3-194">プロジェクト Katana</span><span class="sxs-lookup"><span data-stu-id="f48b3-194">Project Katana</span></span>

<span data-ttu-id="f48b3-195">[OWIN](http://owin.org/html/owin.html)の仕様と*OWIN*はどちらもコミュニティ所有であり、コミュニティはオープンソースの取り組みを実行しますが、 [Katana](https://github.com/aspnet/AspNetKatana/wiki)プロジェクトは、オープンソースである一方で Microsoft によってリリースされる OWIN コンポーネントのセットを表します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="f48b3-196">これらのコンポーネントには、ホストとサーバーなどのインフラストラクチャコンポーネントと、 [SignalR](../../../signalr/index.md)や[ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)などのフレームワークへの認証コンポーネントやバインドなどの機能コンポーネントの両方が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="f48b3-197">このプロジェクトには、次の3つの高レベルの目標があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="f48b3-198">**ポータブル**–新しいコンポーネントが使用可能になったときに、コンポーネントを簡単に置き換えることができる必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="f48b3-199">これには、フレームワークからサーバーおよびホストへのすべての種類のコンポーネントが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="f48b3-200">この目標は、サードパーティのフレームワークがサードパーティのサーバーやホストで実行される可能性がありますが、Microsoft のサーバーでは、サードパーティのフレームワークをシームレスに実行できることを意味します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="f48b3-201">**モジュール型/柔軟性**-既定でオンになっている多くの機能を含む多数のフレームワークとは異なり、Katana プロジェクトコンポーネントは小規模であり、アプリケーションで使用するコンポーネントを決定するためにアプリケーション開発者に制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="f48b3-202">**軽量/パフォーマンス/スケーラブル**–フレームワークの従来の概念を、アプリケーション開発者によって明示的に追加される小さなフォーカスのあるコンポーネントのセットに分割することによって、Katana アプリケーションが使用するコンピューティングリソースが少なくなり、その結果、他の種類のサーバーやフレームワークと比べて負荷が増加します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="f48b3-203">アプリケーションの要件によって、基盤となるインフラストラクチャからさらに多くの機能が必要になるため、OWIN パイプラインに追加することができますが、これはアプリケーション開発者の責任において明示的に決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="f48b3-204">さらに、下位レベルのコンポーネントの態は、使用可能になったときに、新しい高パフォーマンスのサーバーをシームレスに導入することで、OWIN アプリケーションのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="f48b3-205">Katana コンポーネントを使用したはじめに</span><span class="sxs-lookup"><span data-stu-id="f48b3-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="f48b3-206">初めて導入された[node.js](http://nodejs.org/)フレームワークの1つの側面は、簡単に言えば、Web サーバーを作成して実行できるというシンプルなものでした。</span><span class="sxs-lookup"><span data-stu-id="f48b3-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="f48b3-207">Katana の目標が[node.js](http://nodejs.org/)で囲まれている場合は、ASP.NET Web アプリケーションの開発について知っているすべてのことを開発者に強制することなく、 [node.js](http://nodejs.org/) (およびそのようなフレームワーク) の多くの利点を Katana が提供することによって、それらをまとめることができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="f48b3-208">このステートメントが true を保持するためには、Katana プロジェクトの作業の開始が、 [node.js](http://nodejs.org/)の場合と同様に単純である必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="f48b3-209">"Hello World!" を作成しています</span><span class="sxs-lookup"><span data-stu-id="f48b3-209">Creating "Hello World!"</span></span>

<span data-ttu-id="f48b3-210">JavaScript と .NET 開発の重要な違いの1つは、コンパイラの存在 (または欠如) です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="f48b3-211">そのため、単純な Katana サーバーの開始点は、Visual Studio プロジェクトです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="f48b3-212">ただし、空の ASP.NET Web アプリケーションであるプロジェクトの種類のうち、最も少ないものから始めることができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="f48b3-213">次に、 [Owin](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)という NuGet パッケージをプロジェクトにインストールします。</span><span class="sxs-lookup"><span data-stu-id="f48b3-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="f48b3-214">このパッケージは、ASP.NET request パイプラインで実行される OWIN サーバーを提供します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="f48b3-215">このファイルは[NuGet ギャラリー](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)にあり、次のコマンドを使用して、Visual Studio の [パッケージマネージャー] ダイアログまたはパッケージマネージャーコンソールを使用してインストールできます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="f48b3-216">`Microsoft.Owin.Host.SystemWeb` パッケージをインストールすると、いくつかの追加パッケージが依存関係としてインストールされます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="f48b3-217">これらの依存関係の1つは `Microsoft.Owin`です。これは、OWIN アプリケーションを開発するためのいくつかのヘルパー型とメソッドを提供するライブラリです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="f48b3-218">これらの型を使用して、次の "hello world" サーバーをすばやく記述できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="f48b3-219">この非常に単純な Web サーバーは、Visual Studio の**F5**コマンドを使用して実行できるようになりました。また、デバッグを完全にサポートしています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="f48b3-220">ホストの切り替え</span><span class="sxs-lookup"><span data-stu-id="f48b3-220">Switching hosts</span></span>

<span data-ttu-id="f48b3-221">既定では、前の "hello world" の例は ASP.NET request パイプラインで実行され、IIS のコンテキストでは System.web が使用されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="f48b3-222">これにより、IIS の管理機能と全体的な成熟度を使用して OWIN パイプラインの柔軟性と省かを向上させることができるため、非常に大きな価値をもたらすことができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="f48b3-223">ただし、IIS で提供される利点が必要ではなく、より小規模で軽量なホストを使用する場合もあります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="f48b3-224">IIS と System.web の外部で単純な Web サーバーを実行するために必要なことは何でしょうか。</span><span class="sxs-lookup"><span data-stu-id="f48b3-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="f48b3-225">移植性の目標を示すために、Web サーバーホストからコマンドラインホストに移動するには、新しいサーバーとホストの依存関係をプロジェクトの出力フォルダーに追加してから、ホストを起動するだけです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="f48b3-226">この例では、Web サーバーを `OwinHost.exe` という名前の Katana ホストでホストし、Katana HttpListener ベースのサーバーを使用します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="f48b3-227">他の Katana コンポーネントと同様に、これらは次のコマンドを使用して NuGet から取得されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="f48b3-228">次に、コマンドラインからプロジェクトルートフォルダーに移動して、(それぞれの NuGet パッケージの tools フォルダーにインストールされていた) `OwinHost.exe` を実行するだけです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="f48b3-229">既定では、`OwinHost.exe` は HttpListener ベースのサーバーを検索するように構成されているため、追加の構成は必要ありません。</span><span class="sxs-lookup"><span data-stu-id="f48b3-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="f48b3-230">`http://localhost:5000/` するために Web ブラウザーで移動すると、コンソールを使用して現在実行中のアプリケーションが表示されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="f48b3-231">Katana アーキテクチャ</span><span class="sxs-lookup"><span data-stu-id="f48b3-231">Katana Architecture</span></span>

 <span data-ttu-id="f48b3-232">Katana コンポーネントアーキテクチャは、*ホスト、サーバー、ミドルウェア、* *アプリケーション*のように、アプリケーションを4つの論理層に分割します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="f48b3-233">コンポーネントアーキテクチャは、多くの場合、アプリケーションの再コンパイルを必要とせずに、これらのレイヤーの実装を簡単に置き換えることができるように考慮されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="f48b3-234">Host</span><span class="sxs-lookup"><span data-stu-id="f48b3-234">Host</span></span>

 <span data-ttu-id="f48b3-235">ホストは次の役割を担います。</span><span class="sxs-lookup"><span data-stu-id="f48b3-235">The host is responsible for:</span></span>

- <span data-ttu-id="f48b3-236">基になるプロセスを管理します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-236">Managing the underlying process.</span></span>
- <span data-ttu-id="f48b3-237">サーバーの選択と、要求の処理に使用される OWIN パイプラインの構築を実行するワークフローを調整します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

  <span data-ttu-id="f48b3-238">現時点では、Katana ベースのアプリケーションには、次の3つの主要なホスティングオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="f48b3-239">**Iis/ASP. NET**: 標準の HttpModule 型と HttpHandler 型を使用して、OWIN パイプラインを ASP.NET 要求フローの一部として iis で実行できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="f48b3-240">ASP.NET ホスティングのサポートは、Web アプリケーションプロジェクトに NuGet パッケージをインストールすることによって有効になります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="f48b3-241">また、IIS はホストとサーバーの両方として機能するため、この NuGet パッケージでは OWIN サーバー/ホストの区別が行われます。つまり、SystemWeb ホストを使用している場合、開発者は代替サーバーの実装を置き換えることはできません。</span><span class="sxs-lookup"><span data-stu-id="f48b3-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="f48b3-242">**カスタムホスト**: Katana component suite を使用すると、開発者は独自のカスタムプロセスでアプリケーションをホストできるようになります。これは、コンソールアプリケーション、Windows サービスなどになります。この機能は、Web API によって提供される自己ホスト機能に似ています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="f48b3-243">次の例は、Web API コードのカスタムホストを示しています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="f48b3-244">Katana アプリケーションの自己ホストセットアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="f48b3-245">Web API と Katana の自己ホストの例の大きな違いの1つは、Web API 構成コードが Katana 自己ホストの例にないことです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="f48b3-246">移植性と省かの両方を有効にするために、Katana は、サーバーを起動するコードを、要求処理パイプラインを構成するコードから分離します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="f48b3-247">Web API を構成するコードは、クラス Startup に含まれています。これはさらに、WebApplication. Start の型パラメーターとして指定されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="f48b3-248">Startup クラスの詳細については、この記事の後半で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="f48b3-249">ただし、Katana の自己ホストプロセスを開始するために必要なコードは、ASP.NET Web API 自己ホストアプリケーションで現在使用しているコードに似ています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="f48b3-250">**Owinhost .exe**: Katana Web アプリケーションを実行するカスタムプロセスを記述する必要がありますが、多くの場合は、サーバーを起動してアプリケーションを実行できる、ビルド済みの実行可能ファイルを起動することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="f48b3-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="f48b3-251">このシナリオでは、Katana component suite に `OwinHost.exe`が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="f48b3-252">プロジェクトのルートディレクトリ内から実行すると、この実行可能ファイルはサーバーを起動し (既定では HttpListener サーバーを使用します)、規約を使用してユーザーのスタートアップクラスを検索して実行します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="f48b3-253">より詳細な制御を行うために、実行可能ファイルには多数の追加のコマンドラインパラメーターが用意されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="f48b3-254">サーバー</span><span class="sxs-lookup"><span data-stu-id="f48b3-254">Server</span></span>

 <span data-ttu-id="f48b3-255">ホストは、アプリケーションを実行するプロセスの開始と管理を担当しますが、サーバーの役割は、ネットワークソケットを開き、要求をリッスンし、ユーザーが指定した OWIN コンポーネントのパイプラインを通じて送信することです (既にお気付きかもしれませんが、このパイプラインはアプリケーション開発者のスタートアップクラスに指定されています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="f48b3-256">現在、Katana プロジェクトには、次の2つのサーバー実装が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="f48b3-257">**Owin**: 前述のように、ASP.NET パイプラインと連携する IIS は、ホストとサーバーの両方として機能します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="f48b3-258">このため、このホストオプションを選択すると、IIS は、プロセスのアクティブ化や HTTP 要求のリッスンなどのホストレベルの問題を管理します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="f48b3-259">ASP.NET Web アプリケーションの場合は、ASP.NET パイプラインに要求を送信します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="f48b3-260">Katana SystemWeb ホストは、ASP.NET HttpModule と HttpHandler を登録して、HTTP パイプラインを通過し、ユーザーが指定した OWIN パイプラインを介して要求を送信するときに、要求をインターセプトします。</span><span class="sxs-lookup"><span data-stu-id="f48b3-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="f48b3-261">**Owin HttpListener**: 名前が示すように、この Katana server は、.NET Framework の HttpListener クラスを使用してソケットを開き、要求を開発者が指定した Owin パイプラインに送信します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="f48b3-262">これは現在、Katana セルフホスト API と OwinHost .exe の両方に対する既定のサーバー選択です。</span><span class="sxs-lookup"><span data-stu-id="f48b3-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="f48b3-263">ミドルウェア/フレームワーク</span><span class="sxs-lookup"><span data-stu-id="f48b3-263">Middleware/framework</span></span>

 <span data-ttu-id="f48b3-264">既に説明したように、サーバーはクライアントからの要求を受け入れるときに、開発者のスタートアップコードによって指定される OWIN コンポーネントのパイプラインを介してそれを渡す役割を担います。</span><span class="sxs-lookup"><span data-stu-id="f48b3-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="f48b3-265">これらのパイプラインコンポーネントはミドルウェアと呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="f48b3-266">非常に基本的なレベルでは、OWIN ミドルウェアコンポーネントは、呼び出し可能になるように OWIN アプリケーションデリゲートを実装するだけで済みます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="f48b3-267">ただし、ミドルウェアコンポーネントの開発と構成を簡略化するために、Katana はミドルウェアコンポーネントのいくつかの規則とヘルパーの種類をサポートしています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="f48b3-268">最も一般的なのは、`OwinMiddleware` クラスです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="f48b3-269">このクラスを使用して構築されたカスタムミドルウェアコンポーネントは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="f48b3-270">このクラスは `OwinMiddleware`から派生し、パイプライン内の次のミドルウェアのインスタンスをその引数の1つとして受け取り、それを基本コンストラクターに渡すコンストラクターを実装します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="f48b3-271">ミドルウェアの構成に使用される追加の引数は、次のミドルウェアパラメーターの後にコンストラクターパラメーターとしても宣言されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="f48b3-272">実行時には、オーバーライドされた `Invoke` メソッドを使用してミドルウェアが実行されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="f48b3-273">このメソッドは、型 `OwinContext`の1つの引数を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="f48b3-274">このコンテキストオブジェクトは、前に説明した `Microsoft.Owin` NuGet パッケージによって提供され、要求、応答、および環境ディクショナリへの厳密に型指定されたアクセスを提供し、いくつかの追加のヘルパー型を提供します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="f48b3-275">ミドルウェアクラスは、次のように、アプリケーションのスタートアップコードの OWIN パイプラインに簡単に追加できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="f48b3-276">Katana インフラストラクチャは、単純に OWIN ミドルウェアコンポーネントのパイプラインを構築するだけなので、コンポーネントはパイプラインに参加するためにアプリケーションデリゲートをサポートするだけで済むため、ミドルウェアコンポーネントは、単純な logger から ASP.NET、Web API、 [SignalR](../../../signalr/index.md)などのフレームワーク全体まで多岐にわたります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="f48b3-277">たとえば、前の OWIN パイプラインに ASP.NET Web API を追加するには、次のスタートアップコードを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="f48b3-278">Katana インフラストラクチャは、構成メソッドの IAppBuilder オブジェクトに追加された順序に基づいて、ミドルウェアコンポーネントのパイプラインを構築します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="f48b3-279">この例では、LoggerMiddleware は、これらの要求が最終的にどのように処理されるかに関係なく、パイプラインを通過するすべての要求を処理できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="f48b3-280">これにより、ミドルウェアコンポーネント (認証コンポーネントなど) が複数のコンポーネントとフレームワーク (ASP.NET Web API、SignalR、静的ファイルサーバーなど) を含むパイプラインの要求を処理できるという強力なシナリオが可能になります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="f48b3-281">[アプリケーション]</span><span class="sxs-lookup"><span data-stu-id="f48b3-281">Applications</span></span>

<span data-ttu-id="f48b3-282">前の例で示したように、OWIN および Katana プロジェクトは、新しいアプリケーションプログラミングモデルと考えることはできません。また、アプリケーションのプログラミングモデルとフレームワークをサーバーおよびホストインフラストラクチャから分離するための抽象化として考える必要があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="f48b3-283">たとえば、Web API アプリケーションをビルドする場合、開発者フレームワークは、Katana プロジェクトのコンポーネントを使用する OWIN パイプラインでアプリケーションが実行されているかどうかに関係なく、引き続き ASP.NET Web API framework を使用します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="f48b3-284">OWIN 関連のコードがアプリケーション開発者に表示される場所の1つは、開発者が OWIN パイプラインを作成するアプリケーションスタートアップコードです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="f48b3-285">スタートアップコードでは、開発者は一連の UseXx ステートメントを登録します。通常は、受信要求を処理する各ミドルウェアコンポーネントに対して1つのステートメントを使用します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="f48b3-286">このエクスペリエンスは、現在の System.web world に HTTP モジュールを登録するのと同じ効果があります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="f48b3-287">通常は、ASP.NET Web API や[SignalR](../../../signalr/index.md)など、より大きなフレームワークミドルウェアがパイプラインの最後に登録されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="f48b3-288">認証やキャッシュなどの横断的なミドルウェアコンポーネントは、通常、パイプラインの先頭に登録されます。これにより、パイプラインの後半で登録されるすべてのフレームワークおよびコンポーネントに対する要求が処理されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="f48b3-289">このミドルウェアコンポーネントを相互に分離し、基盤となるインフラストラクチャコンポーネントから分離することにより、システム全体が安定した状態を維持しながら、さまざまな速度でコンポーネントを進化させることができます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="f48b3-290">コンポーネント– NuGet パッケージ</span><span class="sxs-lookup"><span data-stu-id="f48b3-290">Components – NuGet Packages</span></span>

<span data-ttu-id="f48b3-291">現在の多くのライブラリやフレームワークと同様に、Katana プロジェクトコンポーネントは一連の NuGet パッケージとして提供されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="f48b3-292">今後のバージョン2.0 では、Katana package 依存関係グラフは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="f48b3-293">(大きいビューの場合は画像をクリックします)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="f48b3-294">Katana プロジェクト内のほぼすべてのパッケージは、Owin パッケージで直接的または間接的に依存しています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="f48b3-295">これは IAppBuilder インターフェイスを含むパッケージであることに注意してください。これは、OWIN 仕様のセクション4で説明されているアプリケーションの起動シーケンスの具象実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="f48b3-296">さらに、パッケージの多くは Owin に依存しています。これは、HTTP 要求と応答を処理するための一連のヘルパー型を提供します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="f48b3-297">パッケージの残りの部分は、ホスティングインフラストラクチャパッケージ (サーバーまたはホスト) またはミドルウェアのいずれかとして分類できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="f48b3-298">Katana プロジェクトの外部にあるパッケージと依存関係はオレンジ色で表示されます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="f48b3-299">Katana 2.0 のホスティングインフラストラクチャには、SystemWeb と HttpListener ベースのサーバー、OwinHost .exe を使用して OWIN アプリケーションを実行するための OwinHost パッケージ、および自己ホスト型の OWIN アプリケーションの Owin パッケージが含まれます。カスタムホスト (例: コンソールアプリケーション、Windows サービスなど)</span><span class="sxs-lookup"><span data-stu-id="f48b3-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="f48b3-300">Katana 2.0 では、ミドルウェアコンポーネントは主にさまざまな認証手段を提供することに重点を置いています。</span><span class="sxs-lookup"><span data-stu-id="f48b3-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="f48b3-301">診断用の追加のミドルウェアコンポーネントが1つ用意されています。これにより、開始ページとエラーページのサポートが有効になります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="f48b3-302">OWIN が事実上ホストの抽象化に成長するにつれて、Microsoft とサードパーティによって開発されたミドルウェアコンポーネントのエコシステムも数が増加します。</span><span class="sxs-lookup"><span data-stu-id="f48b3-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="f48b3-303">まとめ</span><span class="sxs-lookup"><span data-stu-id="f48b3-303">Conclusion</span></span>

 <span data-ttu-id="f48b3-304">最初から、Katana プロジェクトの目標はまだ作成されていないため、開発者は他の Web フレームワークを学習できます。</span><span class="sxs-lookup"><span data-stu-id="f48b3-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="f48b3-305">代わりに、以前よりも多くの選択肢を .NET Web アプリケーション開発者に提供するための抽象化を作成することになりました。</span><span class="sxs-lookup"><span data-stu-id="f48b3-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="f48b3-306">一般的な Web アプリケーションスタックの論理層を交換可能なコンポーネントのセットに分割することにより、Katana プロジェクトでは、スタック全体のコンポーネントが、これらのコンポーネントにとって適切な速度で改善されるようになります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="f48b3-307">単純な OWIN 抽象化に関連するすべてのコンポーネントを構築することにより、Katana は、フレームワークとその上に構築されたアプリケーションを、さまざまなサーバーやホストで移植できるようにします。</span><span class="sxs-lookup"><span data-stu-id="f48b3-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="f48b3-308">開発者がスタックを管理するようにすることで、Katana は、開発者が軽量の方法や機能豊富な Web スタックのしくみについて究極の選択を行うことができるようになります。</span><span class="sxs-lookup"><span data-stu-id="f48b3-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="f48b3-309">Katana の詳細については、</span><span class="sxs-lookup"><span data-stu-id="f48b3-309">For more information about Katana</span></span>

- <span data-ttu-id="f48b3-310">GitHub の Katana プロジェクト: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/)。</span><span class="sxs-lookup"><span data-stu-id="f48b3-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="f48b3-311">ビデオ: [KATANA OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)、Howard Dierking。</span><span class="sxs-lookup"><span data-stu-id="f48b3-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="f48b3-312">謝辞</span><span class="sxs-lookup"><span data-stu-id="f48b3-312">Acknowledgements</span></span>

- <span data-ttu-id="f48b3-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick は、Azure と MVC に重点を置いた Microsoft のシニアプログラミングライターです。</span><span class="sxs-lookup"><span data-stu-id="f48b3-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="f48b3-314">[Scott マン Selman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span><span class="sxs-lookup"><span data-stu-id="f48b3-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="f48b3-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span><span class="sxs-lookup"><span data-stu-id="f48b3-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>
