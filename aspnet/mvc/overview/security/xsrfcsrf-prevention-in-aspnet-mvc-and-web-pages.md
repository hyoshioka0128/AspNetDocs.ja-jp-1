---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC と Web Pages の XSRF/CSRF 防止 |Microsoft Docs
author: Rick-Anderson
description: クロスサイト要求偽造 (XSRF または CSRF とも呼ばれます) は、悪意のある web サイトが interacti に影響する可能性がある web ホストアプリケーションに対する攻撃です。
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455530"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="bb50a-103">ASP.NET MVC と Web ページの XSRF/CSRF 防止</span><span class="sxs-lookup"><span data-stu-id="bb50a-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="bb50a-104">[Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="bb50a-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="bb50a-105">クロスサイト要求偽造 (XSRF または CSRF とも呼ばれます) は、web でホストされるアプリケーションに対する攻撃であり、悪意のある web サイトが、クライアントブラウザーとそのブラウザーによって信頼されている web サイトとの間の対話に影響を与える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="bb50a-106">Web ブラウザーは web サイトへのすべての要求で認証トークンを自動的に送信するため、これらの攻撃が可能になります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="bb50a-107">標準的な例は、ASP.NET のフォーム認証チケットなどの認証クッキーです。</span><span class="sxs-lookup"><span data-stu-id="bb50a-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="bb50a-108">ただし、永続的な認証メカニズム (Windows 認証、基本など) を使用する web サイトは、これらの攻撃の対象にすることができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="bb50a-109">XSRF 攻撃はフィッシング攻撃とは異なります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="bb50a-110">フィッシング攻撃には攻撃対象とのやり取りが必要です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="bb50a-111">フィッシング攻撃では、悪意のある web サイトがターゲット web サイトを模倣し、攻撃者に機密情報を提供することはできません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="bb50a-112">XSRF 攻撃では、多くの場合に攻撃対象とのやり取りは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="bb50a-113">攻撃者は、ブラウザーによって、関連するすべての cookie が送信先の web サイトに自動的に送信されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="bb50a-114">詳細については、 [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(owasp) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="bb50a-115">攻撃の構造</span><span class="sxs-lookup"><span data-stu-id="bb50a-115">Anatomy of an attack</span></span>

<span data-ttu-id="bb50a-116">XSRF 攻撃を実行するには、いくつかのオンラインバンキングトランザクションを実行する必要があるユーザーを考えてみます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="bb50a-117">このユーザーは、最初に WoodgroveBank.com にアクセスしてログインします。この時点で、応答ヘッダーには自分の認証クッキーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="bb50a-118">認証 cookie はセッション cookie であるため、ブラウザープロセスが終了すると、ブラウザーによって自動的にクリアされます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="bb50a-119">ただし、その時点までは、ブラウザーには、WoodgroveBank.com に対する各要求に cookie が自動的に含まれます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="bb50a-120">これで、ユーザーは $1000 を別のアカウントに転送するようになりました。そのため、銀行のサイトにフォームを入力すると、ブラウザーはこの要求をサーバーに対して行います。</span><span class="sxs-lookup"><span data-stu-id="bb50a-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="bb50a-121">この操作は副作用がある (金額トランザクションを開始する) ため、この操作を開始するために、銀行のサイトで HTTP POST の要求が選択されています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="bb50a-122">サーバーは、要求から認証トークンを読み取り、現在のユーザーのアカウント番号を検索し、十分な資金が存在することを確認してから、対象のアカウントにトランザクションを開始します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="bb50a-123">オンラインバンキングを完了すると、ユーザーが銀行のサイトから移動し、web 上の他の場所にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="bb50a-124">これらのサイトのいずれか– fabrikam.com – &lt;iframe&gt;内に埋め込まれたページに次のマークアップを含めます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="bb50a-125">これにより、ブラウザーは次の要求を行います。</span><span class="sxs-lookup"><span data-stu-id="bb50a-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="bb50a-126">攻撃者は、ユーザーがターゲット web サイトに有効な認証トークンを持っている可能性があるという事実を悪用しています。また、Javascript の小さなスニペットを使用して、ブラウザーがターゲットサイトへの HTTP POST を自動的に行うようにしています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="bb50a-127">認証トークンがまだ有効である場合、銀行のサイトでは、攻撃者が選択したアカウントへの $250 の転送を開始します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="bb50a-128">効率的でない軽減策</span><span class="sxs-lookup"><span data-stu-id="bb50a-128">Ineffective mitigations</span></span>

<span data-ttu-id="bb50a-129">上記のシナリオでは、WoodgroveBank.com が SSL 経由でアクセスされ、SSL のみの認証クッキーが攻撃を阻止するのに十分ではないという事実に注意してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="bb50a-130">攻撃者は &lt;フォーム&gt; 要素で[URI スキーム](http://en.wikipedia.org/wiki/URI_scheme)(https) を指定できます。また、これらの cookie が目的のターゲットの URI スキームと一致する限り、ブラウザーは引き続きターゲットサイトに unexpired cookie を送信します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="bb50a-131">信頼されたサイトのみにアクセスしても安全なオンラインに保つことができるので、ユーザーは信頼されていないサイトにアクセスしないようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="bb50a-132">これには真実がありますが、残念ながらこのアドバイスは常に実用的であるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="bb50a-133">ユーザーは、ローカルニュースサイト ConsolidatedMessenger を "信頼" している可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="bb50a-134">ConsolidatedMessenger.com を使用してそのサイトにアクセスしますが、そのサイトには、fabrikam.com で実行されていたものと同じコードスニペットを注入できる XSS 脆弱性があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="bb50a-135">受信要求にドメインを参照する[Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)があることを確認できます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="bb50a-136">これにより、サードパーティのドメインから知らないうちに送信された要求を停止します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="bb50a-137">ただし、プライバシー上の理由からブラウザーの Referer ヘッダーを無効にするユーザーもいれば、攻撃者が特定の安全でないソフトウェアがインストールされている場合は、そのヘッダーを偽装することがあります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="bb50a-138">[Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)の検証は、XSRF 攻撃を防ぐための安全な方法とは見なされません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="bb50a-139">Web Stack Runtime XSRF の緩和</span><span class="sxs-lookup"><span data-stu-id="bb50a-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="bb50a-140">ASP.NET Web Stack ランタイムは、[シンクロナイザートークンパターン](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern)のバリエーションを使用して、XSRF 攻撃に対する防御を行います。</span><span class="sxs-lookup"><span data-stu-id="bb50a-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="bb50a-141">シンクロナイザートークンパターンの一般的な形式では、2つの XSRF トークンが (認証トークンに加えて) 各 HTTP POST と共にサーバーに送信されます。1つは cookie として、もう1つはフォーム値です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="bb50a-142">ASP.NET ランタイムによって生成されるトークン値は、攻撃者によって決定的または予測可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="bb50a-143">トークンが送信されると、サーバーでは、両方のトークンが比較チェックに合格した場合にのみ、要求を続行できます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="bb50a-144">XSRF 要求確認*セッショントークン*は、HTTP クッキーとして格納され、現在、ペイロードに次の情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="bb50a-145">ランダムな128ビット識別子で構成されるセキュリティトークン。</span><span class="sxs-lookup"><span data-stu-id="bb50a-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="bb50a-146">次の図は、Internet Explorer の F12 開発者ツールで表示される XSRF request 確認セッショントークンを示しています (これは現在の実装であり、変更される可能性があります)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="bb50a-147">*フィールドトークン*は `<input type="hidden" />` として格納され、ペイロードに次の情報が含まれます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="bb50a-148">ログインしているユーザーのユーザー名 (認証されている場合)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="bb50a-149">[Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)によって提供される追加データ。</span><span class="sxs-lookup"><span data-stu-id="bb50a-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="bb50a-150">XSRF トークンのペイロードは暗号化および署名されるので、ツールを使用してトークンを確認するときにユーザー名を表示することはできません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="bb50a-151">Web アプリケーションが ASP.NET 4.0 をターゲットにしている場合、暗号化サービスは、 [MachineKey. Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)ルーチンによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="bb50a-152">Web アプリケーションが ASP.NET 4.5 以降を対象としている場合、暗号化サービスは、パフォーマンス、拡張性、およびセキュリティを向上させるために、 [MachineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))ルーチンによって提供されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="bb50a-153">詳細については、次のブログ投稿を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="bb50a-154">ASP.NET 4.5, pt. 1 での暗号化の強化</span><span class="sxs-lookup"><span data-stu-id="bb50a-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="bb50a-155">ASP.NET 4.5、pt. 2 での暗号化の強化</span><span class="sxs-lookup"><span data-stu-id="bb50a-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="bb50a-156">ASP.NET 4.5、pt. 3 での暗号化の強化</span><span class="sxs-lookup"><span data-stu-id="bb50a-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="bb50a-157">トークンの生成</span><span class="sxs-lookup"><span data-stu-id="bb50a-157">Generating the tokens</span></span>

<span data-ttu-id="bb50a-158">XSRF トークンを生成するには、Razor ページから MVC ビューまたは @AntiForgery.GetHtml() から[@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx)メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="bb50a-159">ランタイムは、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="bb50a-160">現在の HTTP 要求に XSRF セッショントークン (XSRF cookie \_\_RequestVerificationToken) が既に含まれている場合は、セキュリティトークンがそこから抽出されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="bb50a-161">HTTP 要求に XSRF セッショントークンが含まれていない場合、またはセキュリティトークンの抽出に失敗した場合は、新しいランダムな XSRF トークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="bb50a-162">上記の手順 (1) からのセキュリティトークンと、現在ログインしているユーザーの id を使用して、XSRF フィールドトークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="bb50a-163">(ユーザー id を決定する方法の詳細については、以下の「 **[特別なサポートを使用するシナリオ](#_Scenarios_with_special)** 」を参照してください)。さらに、 [Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx)が構成されている場合、ランタイムはその[getadditionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)メソッドを呼び出し、返された文字列をフィールドトークンに含めます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="bb50a-164">(詳細については、「 **[構成と拡張機能](#_Configuration_and_extensibility)** 」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="bb50a-165">手順 (1) で新しい XSRF トークンが生成された場合、それを含む新しいセッショントークンが作成され、送信 HTTP cookies コレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="bb50a-166">手順 (2) のフィールドトークンは `<input type="hidden" />` 要素にラップされ、この HTML マークアップは `Html.AntiForgeryToken()` または `AntiForgery.GetHtml()`の戻り値になります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="bb50a-167">トークンの検証</span><span class="sxs-lookup"><span data-stu-id="bb50a-167">Validating the tokens</span></span>

<span data-ttu-id="bb50a-168">受信した XSRF トークンを検証するために、開発者は自分の MVC アクションまたはコントローラーに[Validateアンチ Forgerytoken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)属性を含めるか、または自分の Razor ページから `@AntiForgery.Validate()` を呼び出します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="bb50a-169">ランタイムは、次の手順を実行します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="bb50a-170">受信セッショントークンとフィールドトークンが読み取られ、それぞれから抽出された XSRF トークンが読み取られます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="bb50a-171">XSRF トークンは、生成ルーチンのステップごとに同一である必要があります (2)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="bb50a-172">現在のユーザーが認証されている場合、ユーザー名はフィールドトークンに格納されているユーザー名と比較されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="bb50a-173">ユーザー名が一致している必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-173">The usernames must match.</span></span>
3. <span data-ttu-id="bb50a-174">[Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)が構成されている場合、ランタイムは*validateadditionaldata*メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="bb50a-175">メソッドはブール値*true*を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="bb50a-176">検証が成功した場合、要求は続行できます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="bb50a-177">検証が失敗した場合、フレームワークは*Httpantiforgeryexception*をスローします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="bb50a-178">エラー条件</span><span class="sxs-lookup"><span data-stu-id="bb50a-178">Failure conditions</span></span>

<span data-ttu-id="bb50a-179">ASP.NET Web Stack Runtime v2 以降、検証中にスローされる*Httpantiforgeryexception*には、問題の原因に関する詳細情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="bb50a-180">現在定義されているエラー条件は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="bb50a-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="bb50a-181">セッショントークンまたはフォームトークンが要求に存在しません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="bb50a-182">セッショントークンまたはフォームトークンを読み取ることができません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="bb50a-183">この原因として最も可能性が高いのは、一致しないバージョンの ASP.NET Web Stack ランタイムを実行しているファーム、または web.config の &lt;machineKey&gt; 要素がコンピューター間で異なるファームです。</span><span class="sxs-lookup"><span data-stu-id="bb50a-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="bb50a-184">Fiddler などのツールを使用して、XSRF トークンを使用して改ざんすることで、この例外を強制的に適用することができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="bb50a-185">セッショントークンとフィールドトークンがスワップされました。</span><span class="sxs-lookup"><span data-stu-id="bb50a-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="bb50a-186">セッショントークンとフィールドトークンに、一致しないセキュリティトークンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="bb50a-187">フィールドトークン内に埋め込まれているユーザー名が、現在ログインしているユーザーのユーザー名と一致しません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="bb50a-188">*[Iアンチ Forgeryadditionaldataprovider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* メソッドは*false*を返しました。</span><span class="sxs-lookup"><span data-stu-id="bb50a-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="bb50a-189">また、XSRF 施設では、トークンの生成または検証中に追加のチェックを実行することもできます。これらのチェック中にエラーが発生すると、例外がスローされる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="bb50a-190">詳細については、 [WIF/ACS/要求ベースの認証](#_WIF_ACS)と **[構成と拡張](#_Configuration_and_extensibility)** に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="bb50a-191">特別なサポートがあるシナリオ</span><span class="sxs-lookup"><span data-stu-id="bb50a-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="bb50a-192">匿名認証</span><span class="sxs-lookup"><span data-stu-id="bb50a-192">Anonymous authentication</span></span>

<span data-ttu-id="bb50a-193">XSRF システムには、匿名ユーザーの特別なサポートが含まれています *。* ここで、"anonymous" は、"anonymous" プロパティが*false*を返すユーザーとして定義されています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="bb50a-194">シナリオには、ログインページへの XSRF 保護の提供 (ユーザーが認証される前) と、アプリケーションが*IIdentity*以外のメカニズムを使用してユーザーを識別するカスタム認証スキームが含まれます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="bb50a-195">これらのシナリオをサポートするには、セッションとフィールドトークンが、ランダムに生成された128ビットの不透明な識別子であるセキュリティトークンによって結合されていることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="bb50a-196">このセキュリティトークンは、サイトを移動するときに個々のユーザーのセッションを追跡するために使用されます。これにより、匿名識別子の目的が効果的に提供されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="bb50a-197">上記で説明した生成ルーチンと検証ルーチンのユーザー名の代わりに、空の文字列が使用されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="bb50a-198">WIF/ACS/要求ベースの認証</span><span class="sxs-lookup"><span data-stu-id="bb50a-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="bb50a-199">通常、.NET Framework に組み込まれている*IIdentity*クラスには、特定のアプリケーション内の特定のユーザーを一意に識別するのに十分な*IIdentity.Name*のプロパティがあります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="bb50a-200">たとえば、 *FormsIdentity.Name*はメンバーシップデータベースに格納されているユーザー名 (そのデータベースに依存するすべてのアプリケーションに対して一意である) を返し、 *WindowsIdentity.Name*はユーザーのドメイン修飾 id を返します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="bb50a-201">これらのシステムは認証のみを行います。また、アプリケーションに対してユーザーを*識別*します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="bb50a-202">一方、クレームベースの認証では、必ずしも特定のユーザーを識別する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="bb50a-203">代わりに、 *ClaimsPrincipal*と*ClaimsIdentity*の種類は*クレーム*インスタンスのセットに関連付けられています。この場合、個々の要求は "18 歳以上の年齢" や "管理者" などになります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="bb50a-204">ユーザーは必ずしも特定されていないため、ランタイムはこの特定のユーザーの一意の識別子として*ClaimsIdentity.Name*プロパティを使用できません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="bb50a-205">チームは実際の例を見てきました。 *ClaimsIdentity.Name*は*null*を返し、フレンドリ (表示) 名を返します。それ以外の場合は、ユーザーの一意の識別子として使用するのに適していない文字列を返します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="bb50a-206">信頼性情報ベースの認証を使用する多くのデプロイでは、特に[Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) を使用します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="bb50a-207">ACS を使用すると、開発者は個々の*id プロバイダー* (ADFS、Microsoft アカウントプロバイダー、yahoo! などの OpenID プロバイダーなど) を構成し、id プロバイダーは*名前識別子*を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="bb50a-208">これらの名前識別子には、電子メールアドレスのような個人を特定できる情報 (PII) を含めることができます。また、個人の個人識別子 (PPID) のように匿名化することもできます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="bb50a-209">タプル (id プロバイダー、名前識別子) は、サイトを参照している間、特定のユーザーに適切な追跡トークンとして十分に機能します。そのため、ASP.NET Web Stack ランタイムは、を生成するときに、ユーザー名の代わりにタプルを使用できます。XSRF のフィールドトークンを検証しています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="bb50a-210">Id プロバイダーと名前識別子の特定の Uri は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="bb50a-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="bb50a-211">(詳細については、この[ACS ドキュメントページ](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)を参照してください。)</span><span class="sxs-lookup"><span data-stu-id="bb50a-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="bb50a-212">トークンを生成または検証するときに、ASP.NET Web スタックランタイムは実行時に次の型にバインドします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="bb50a-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (WIF SDK の場合)</span><span class="sxs-lookup"><span data-stu-id="bb50a-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="bb50a-214">`System.Security.Claims.ClaimsIdentity` (.NET 4.5 の場合)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="bb50a-215">これらの型が存在し、現在のユーザーの*IIIIdentity*がこれらの型のいずれかを実装しているかサブクラスを実装している場合、XSRF ファシリティは、トークンを生成および検証するときに、ユーザー名の代わりに (id プロバイダー、名前識別子) タプルを使用します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="bb50a-216">このようなタプルが存在しない場合、要求は失敗し、開発者に対して、使用中の特定の要求ベースの認証メカニズムを理解するように XSRF システムを構成する方法を説明するエラーが表示されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="bb50a-217">詳細については、「 **[構成と拡張機能](#_Configuration_and_extensibility)** 」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="bb50a-218">OAuth/OpenID 認証</span><span class="sxs-lookup"><span data-stu-id="bb50a-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="bb50a-219">最後に、XSRF 機能は、OAuth または OpenID 認証を使用するアプリケーションに対して特別なサポートを行います。</span><span class="sxs-lookup"><span data-stu-id="bb50a-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="bb50a-220">このサポートはヒューリスティックに基づいています。現在の*IIdentity.Name*が http://または https://で始まる場合は、既定の stringcomparison.ordinalignorecase comparer ではなく序数の比較子を使用して、ユーザー名の比較が行われます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="bb50a-221">構成と拡張性</span><span class="sxs-lookup"><span data-stu-id="bb50a-221">Configuration and extensibility</span></span>

<span data-ttu-id="bb50a-222">場合によっては、開発者が XSRF の生成と検証の動作を厳密に制御する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="bb50a-223">たとえば、MVC と Web ページのヘルパーの既定の動作である HTTP cookie を応答に自動的に追加することは望ましくありません。開発者は、トークンを他の場所に保存することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="bb50a-224">これを支援するために、次の2つの Api が存在します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="bb50a-225">*Gettokens*メソッドは、既存の XSRF 要求確認セッショントークン (null) を入力として受け取り、新しい XSRF request 検証セッショントークンとフィールドトークンを出力として生成します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="bb50a-226">トークンは、装飾のない単なる不透明な文字列です。インスタンスの*Formtoken*値は、&lt;入力&gt; タグにラップされません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="bb50a-227">*Newcookietoken*値は null にすることができます。このエラーが発生した場合は、 *Oldcookietoken*値が引き続き有効であり、新しい応答クッキーを設定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="bb50a-228">*Gettokens*の呼び出し元は、必要な応答クッキーを保持したり、必要なマークアップを生成したりします。*Gettokens*メソッド自体は、応答を副作用として変更しません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="bb50a-229">*Validate*メソッドは、受信セッションとフィールドトークンを受け取り、前述の検証ロジックを実行します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="bb50a-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="bb50a-230">AntiForgeryConfig</span></span>

<span data-ttu-id="bb50a-231">開発者は、アプリケーション\_の起動から、XSRF システムを構成できます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="bb50a-232">構成はプログラムによって行います。</span><span class="sxs-lookup"><span data-stu-id="bb50a-232">Configuration is programmatic.</span></span> <span data-ttu-id="bb50a-233">次に、静的な*アンチ Forgeryconfig*型のプロパティについて説明します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="bb50a-234">クレームを使用するほとんどのユーザーは、UniqueClaimTypeIdentifier プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="bb50a-235">**プロパティ**</span><span class="sxs-lookup"><span data-stu-id="bb50a-235">**Property**</span></span> | <span data-ttu-id="bb50a-236">**説明**</span><span class="sxs-lookup"><span data-stu-id="bb50a-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="bb50a-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="bb50a-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="bb50a-238">トークンの生成中に追加データを提供し、トークンの検証中に追加のデータを使用する[Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 。</span><span class="sxs-lookup"><span data-stu-id="bb50a-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="bb50a-239">既定値は、*null* です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-239">The default value is *null*.</span></span> <span data-ttu-id="bb50a-240">詳細については、「 [Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 」セクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="bb50a-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="bb50a-241">**CookieName**</span></span> | <span data-ttu-id="bb50a-242">XSRF のセッショントークンを格納するために使用される HTTP クッキーの名前を提供する文字列。</span><span class="sxs-lookup"><span data-stu-id="bb50a-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="bb50a-243">この値が設定されていない場合、アプリケーションの展開された仮想パスに基づいて、名前が自動的に生成されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="bb50a-244">既定値は、*null* です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-244">The default value is *null*.</span></span> |
| <span data-ttu-id="bb50a-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="bb50a-245">**RequireSsl**</span></span> | <span data-ttu-id="bb50a-246">SSL で保護されたチャネル経由で XSRF トークンを送信する必要があるかどうかを指定するブール値。</span><span class="sxs-lookup"><span data-stu-id="bb50a-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="bb50a-247">この値が*true*の場合、自動的に生成される cookie には "secure" フラグが設定され、SSL 経由で送信されていない要求内から呼び出された場合、XSRF api はスローします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="bb50a-248">既定値は *false* です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-248">The default value is *false*.</span></span> |
| <span data-ttu-id="bb50a-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="bb50a-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="bb50a-250">XSRF システムで、要求ベースの id のサポートを非アクティブ化するかどうかを指定するブール値。</span><span class="sxs-lookup"><span data-stu-id="bb50a-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="bb50a-251">この値が*true*の場合、 *IIdentity.Name*はユーザーごとの一意の識別子として使用するのが適切であると想定し、 [WIF/ACS/要求ベースの認証](#_WIF_ACS)セクションで説明されているように、特殊なケースの*IClaimsIdentity*または*ClClaimsIdentity*を試行しません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="bb50a-252">既定値は `false` です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-252">The default value is `false`.</span></span> |
| <span data-ttu-id="bb50a-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="bb50a-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="bb50a-254">一意のユーザーごとの識別子としての使用に適した要求の種類を示す文字列。</span><span class="sxs-lookup"><span data-stu-id="bb50a-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="bb50a-255">この値が設定されていて、現在の*IIdentity*がクレームベースの場合、システムは*UniqueClaimTypeIdentifier*によって指定された種類の要求を抽出しようとし、フィールドトークンを生成するときに、ユーザーのユーザー名の代わりに対応する値が使用されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="bb50a-256">要求の種類が見つからない場合、システムは要求に失敗します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="bb50a-257">既定値は*null*です。これは、ユーザーのユーザー名の代わりに、前に説明したように、システムが (id プロバイダー、名前識別子) タプルを使用する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="bb50a-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="bb50a-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="bb50a-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="bb50a-259">*[Iアンチ Forgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 型を使用すると、開発者は、各トークンの追加データをラウンドトリップさせることで、XSRF システムの動作を拡張できます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="bb50a-260">*Getadditionaldata*メソッドは、フィールドトークンが生成されるたびに呼び出され、戻り値は生成されたトークン内に埋め込まれます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="bb50a-261">実装者は、タイムスタンプ、nonce、またはこのメソッドからのその他の値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="bb50a-262">同様に、 *Validateadditionaldata*メソッドは、フィールドトークンが検証されるたびに呼び出され、トークン内に埋め込まれた "追加データ" 文字列がメソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="bb50a-263">検証ルーチンは、(トークンの作成時に現在の時刻をチェックすることによって) タイムアウトを実装したり、nonce チェックルーチンやその他の必要なロジックを実装したりすることができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="bb50a-264">設計上の決定とセキュリティに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="bb50a-264">Design decisions and security considerations</span></span>

<span data-ttu-id="bb50a-265">セッションとフィールドトークンをリンクするセキュリティトークンは、匿名/認証されていないユーザーを XSRF 攻撃から保護する場合にのみ、技術的には必要です。</span><span class="sxs-lookup"><span data-stu-id="bb50a-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="bb50a-266">ユーザーが認証されると、認証トークン自体 (cookie の形式で送信された可能性があります) をシンクロナイザートークンペアの半分として使用できるようになります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="bb50a-267">ただし、認証されていないユーザーによるログインページの保護には有効なシナリオがあります。また、認証されたユーザーであっても、常にセキュリティトークンを生成して検証することによって、XSRF の対策ロジックがより簡単になりました。</span><span class="sxs-lookup"><span data-stu-id="bb50a-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="bb50a-268">また、攻撃者によってフィールドトークンが侵害される可能性がある場合に、追加の保護も提供します。これにより、セッショントークンが攻撃者にとって別のハードルになる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="bb50a-269">複数のアプリケーションが1つのドメインでホストされている場合、開発者は注意を払う必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="bb50a-270">たとえば、 *example1.cloudapp.net*と*example2.cloudapp.net*は異なるホストですが、 *cloudapp.net ドメイン\** のすべてのホスト間には暗黙の信頼関係があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="bb50a-271">この暗黙的な信頼関係[により、信頼できない可能性のあるホストが互いの cookie に影響を与えることが](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks)あります (AJAX 要求を管理する同じオリジンポリシーは、必ずしも HTTP クッキーに適用されるわけではありません)。</span><span class="sxs-lookup"><span data-stu-id="bb50a-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="bb50a-272">ASP.NET Web Stack ランタイムでは、ユーザー名がフィールドトークンに埋め込まれるという点が軽減されます。したがって、悪意のあるサブドメインがセッショントークンを上書きできる場合でも、ユーザーに有効なフィールドトークンを生成することはできません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="bb50a-273">ただし、このような環境でホストされている場合、組み込みの XSRF ルーチンは、セッションハイジャックやログイン XSRF を防ぐことはできません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="bb50a-274">現在、XSRF ルーチンは[クリックジャッキング](https://www.owasp.org/index.php/Clickjacking)を防御するものではありません。</span><span class="sxs-lookup"><span data-stu-id="bb50a-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="bb50a-275">クリックジャッキングに対して自身を防御する必要があるアプリケーションは、各応答で X フレームオプション: sameorigin ヘッダーを送信することによって簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="bb50a-276">このヘッダーは、最近のすべてのブラウザーでサポートされています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="bb50a-277">詳細については、 [IE ブログ](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL ブログ](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)、 [owasp](https://www.owasp.org/index.php/Clickjacking)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="bb50a-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="bb50a-278">ASP.NET Web スタックランタイムは、今後のリリースで、MVC と Web ページの XSRF ヘルパーが自動的にこのヘッダーを設定し、アプリケーションがこの攻撃に対して自動的に保護されるようにします。</span><span class="sxs-lookup"><span data-stu-id="bb50a-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="bb50a-279">Web 開発者は、サイトが XSS 攻撃に対して脆弱でないことを継続的に確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="bb50a-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="bb50a-280">XSS 攻撃は非常に強力であり、悪用が成功すると、XSRF 攻撃に対して ASP.NET Web Stack Runtime 防御も破壊されます。</span><span class="sxs-lookup"><span data-stu-id="bb50a-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="bb50a-281">Acknowledgement (受信確認)</span><span class="sxs-lookup"><span data-stu-id="bb50a-281">Acknowledgment</span></span>

<span data-ttu-id="bb50a-282">[@LeviBroderick](https://twitter.com/LeviBroderick)、ASP.NET のセキュリティコードの大部分をこの情報の大部分に書いています。</span><span class="sxs-lookup"><span data-stu-id="bb50a-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
