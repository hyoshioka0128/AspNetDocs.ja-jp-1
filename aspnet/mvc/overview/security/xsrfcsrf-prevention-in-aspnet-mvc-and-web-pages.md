---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC と Web ページの XSRF/CSRF 防止 |Microsoft Docs
author: Rick-Anderson
description: 悪意のある web サイトを使用して、interacti に影響する、web でホストされるアプリケーションに対する攻撃をクロスサイト リクエスト フォージェリ (XSRF または CSRF とも呼ばれます) には.
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: a6e10c52d83dc3c29ab2f9f6bb0c05cfbbf6aad1
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/06/2019
ms.locfileid: "65126364"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="f4202-103">ASP.NET MVC と Web ページの XSRF/CSRF 防止</span><span class="sxs-lookup"><span data-stu-id="f4202-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="f4202-104">によって[Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="f4202-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="f4202-105">サイト間の要求が偽造 (XSRF または CSRF) は、悪意のある web サイトがクライアント ブラウザーとそのブラウザーが信頼する web サイト間のやり取りに影響するという、web でホストされるアプリケーションに対する攻撃です。</span><span class="sxs-lookup"><span data-stu-id="f4202-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="f4202-106">Web ブラウザーがすべての要求で自動的に認証トークンを web サイトに送信するため、これらの攻撃が可能になります。</span><span class="sxs-lookup"><span data-stu-id="f4202-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="f4202-107">標準的な例は、ASP などの認証クッキーです。NET のフォーム認証チケット。</span><span class="sxs-lookup"><span data-stu-id="f4202-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="f4202-108">ただし、(Windows 認証、Basic、およびなど) などの任意の永続的な認証メカニズムを使用する web サイトの場合は、これらの攻撃対象となることができます。</span><span class="sxs-lookup"><span data-stu-id="f4202-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="f4202-109">XSRF 攻撃はフィッシング攻撃とは異なります。</span><span class="sxs-lookup"><span data-stu-id="f4202-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="f4202-110">フィッシング攻撃には、対象とのやり取りが必要です。</span><span class="sxs-lookup"><span data-stu-id="f4202-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="f4202-111">フィッシング攻撃では、悪意のある web サイトがターゲットの web サイト、し、対象は、攻撃者に機密情報を提供することにようにだまされます。</span><span class="sxs-lookup"><span data-stu-id="f4202-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="f4202-112">XSRF 攻撃では、ある必要はありません多くの場合、相互作用に攻撃対象です。</span><span class="sxs-lookup"><span data-stu-id="f4202-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="f4202-113">代わりに、自動的にすべての関連クッキーを模擬 web サイトに送信するブラウザーで、攻撃者が証明書利用者です。</span><span class="sxs-lookup"><span data-stu-id="f4202-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="f4202-114">詳細については、次を参照してください。、 [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))します。</span><span class="sxs-lookup"><span data-stu-id="f4202-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="f4202-115">攻撃の分析</span><span class="sxs-lookup"><span data-stu-id="f4202-115">Anatomy of an attack</span></span>

<span data-ttu-id="f4202-116">XSRF 攻撃を説明するには、いくつかのオンライン銀行取引トランザクションを実行したいユーザーを検討してください。</span><span class="sxs-lookup"><span data-stu-id="f4202-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="f4202-117">このユーザーに最初にこの時点で、応答ヘッダーが認証 cookie を含む WoodgroveBank.com と、ログをアクセスします。</span><span class="sxs-lookup"><span data-stu-id="f4202-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="f4202-118">認証 cookie は、セッションの cookie であるためは自動的にオフにする、ブラウザーでブラウザーのプロセスの終了時にします。</span><span class="sxs-lookup"><span data-stu-id="f4202-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="f4202-119">ただし、それまでは、ブラウザーが自動的に cookie が含まれます WoodgroveBank.com 要求ごとにします。</span><span class="sxs-lookup"><span data-stu-id="f4202-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="f4202-120">ユーザーは、彼女、銀行サイト上のフォームに入力し、ブラウザーがサーバーにこの要求を行うために、別のアカウントに $1000 を転送するようになりましたが。</span><span class="sxs-lookup"><span data-stu-id="f4202-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="f4202-121">この操作には、(金銭トランザクションを開始) 副作用があるため、銀行サイトがこの操作を開始するには、HTTP POST を要求するように選択します。</span><span class="sxs-lookup"><span data-stu-id="f4202-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="f4202-122">サーバーは、要求から認証トークンを読み取ります、現在のユーザーのアカウントの数を調べ、十分な資金が存在することを確認し、コピー先アカウントに、トランザクションを開始します。</span><span class="sxs-lookup"><span data-stu-id="f4202-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="f4202-123">オンライン バンキング完了させます、ユーザーが銀行サイトから離れたと、web で他の場所にアクセスします。</span><span class="sxs-lookup"><span data-stu-id="f4202-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="f4202-124">次のマークアップ内に埋め込まれてページ – fabrikam.com – これらのサイトのいずれかが含まれています、 &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="f4202-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="f4202-125">この要求を行い、ブラウザーが発生しています。</span><span class="sxs-lookup"><span data-stu-id="f4202-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="f4202-126">攻撃者は、ユーザーは、ターゲット web サイトの有効な認証トークンを必要があり、彼女が、ターゲット サイトに HTTP POST のことを自動的にブラウザーに Javascript の小さなスニペットを使用してください。 いるという事実を悪用してください。</span><span class="sxs-lookup"><span data-stu-id="f4202-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="f4202-127">認証トークンがまだ有効の場合は、銀行サイトの攻撃者のアカウントに 250 ドルの転送が開始されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="f4202-128">無効な軽減策</span><span class="sxs-lookup"><span data-stu-id="f4202-128">Ineffective mitigations</span></span>

<span data-ttu-id="f4202-129">あったことを示す前述のシナリオで WoodgroveBank.com は SSL 経由でアクセスされていたと、SSL 専用の認証クッキーが攻撃を阻止するために十分な興味深いは。</span><span class="sxs-lookup"><span data-stu-id="f4202-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="f4202-130">攻撃者を指定すること、 [URI スキーム](http://en.wikipedia.org/wiki/URI_scheme)(https) で彼女&lt;フォーム&gt;要素、およびブラウザーは引き続きこれらの cookie は、URI で一貫性のある限り、対象のサイトに期限が切れていない cookie を送信目的のターゲットのスキーム。</span><span class="sxs-lookup"><span data-stu-id="f4202-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="f4202-131">ユーザーによってとして信頼済みサイトが安全なオンラインを維持するだけにアクセスして、信頼されていないサイト必要がありますいないアクセスだけように 1 つと言えるでしょう。</span><span class="sxs-lookup"><span data-stu-id="f4202-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="f4202-132">これは、一部は本当しますが、残念ながらこのアドバイスは常に実用的です。</span><span class="sxs-lookup"><span data-stu-id="f4202-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="f4202-133">おそらく、ユーザー「信頼」ローカル ニュース サイト ConsolidatedMessenger します。</span><span class="sxs-lookup"><span data-stu-id="f4202-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="f4202-134">ConsolidatedMessenger.com およびが代わりに、サイトのアクセスがそのサイトには、攻撃者が fabrikam.com 上で実行されるコードの同じスニペットを挿入することができる、XSS 脆弱性を持ちます。</span><span class="sxs-lookup"><span data-stu-id="f4202-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="f4202-135">受信要求があることを確認することができます、 [Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)ドメインを参照します。</span><span class="sxs-lookup"><span data-stu-id="f4202-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="f4202-136">これにより、無意識にサード パーティのドメインから送信された要求は停止します。</span><span class="sxs-lookup"><span data-stu-id="f4202-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="f4202-137">ただし、一部の人には、プライバシー上の理由から、ブラウザーの Referer ヘッダーが無効にして、攻撃者できる場合は被害者があるインストールされている特定のセキュリティ保護されていないソフトウェアそのヘッダーなりすます場合があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="f4202-138">検証、 [Referer ヘッダー](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) XSRF 攻撃を防ぐための安全なアプローチとは見なされません。</span><span class="sxs-lookup"><span data-stu-id="f4202-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="f4202-139">Web スタック ランタイム XSRF の軽減策</span><span class="sxs-lookup"><span data-stu-id="f4202-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="f4202-140">ASP.NET Web スタックのランタイムのバリアントを使用して、[シンクロナイザー トークン パターン](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern)XSRF 攻撃から保護します。</span><span class="sxs-lookup"><span data-stu-id="f4202-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="f4202-141">シンクロナイザー トークン パターンの一般的な形式は、2 つの ANTI-XSRF トークンは、(認証トークン) だけでなく各 HTTP POST を使用してサーバーに送信されます: として、cookie、フォームの値としてもう 1 つのトークン。</span><span class="sxs-lookup"><span data-stu-id="f4202-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="f4202-142">ASP.NET ランタイムによって生成されたトークンの値は、決定的または攻撃者が予測可能ではありません。</span><span class="sxs-lookup"><span data-stu-id="f4202-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="f4202-143">トークンが送信されたとき、サーバーが要求に両方のトークンは、比較のチェックを渡す場合にのみ続行を許可します。</span><span class="sxs-lookup"><span data-stu-id="f4202-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="f4202-144">XSRF 要求検証*セッション トークン*は HTTP cookie として格納され、現在そのペイロードでは、次の情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f4202-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="f4202-145">128 ビットのランダムな識別子で構成されるセキュリティ トークンです。</span><span class="sxs-lookup"><span data-stu-id="f4202-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="f4202-146">次の図は、Internet Explorer F12 開発者ツールで表示される XSRF 要求検証のセッション トークンを示しています。(注これは、現在の実装であり、件名は、変化する可能性にもします)。</span><span class="sxs-lookup"><span data-stu-id="f4202-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="f4202-147">*フィールド トークン*として格納されて、`<input type="hidden" />`そのペイロードでは、次の情報が含まれています。</span><span class="sxs-lookup"><span data-stu-id="f4202-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="f4202-148">ログインしているユーザーのユーザー名 (認証済み) 場合。</span><span class="sxs-lookup"><span data-stu-id="f4202-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="f4202-149">その他のデータによって提供される、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)します。</span><span class="sxs-lookup"><span data-stu-id="f4202-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="f4202-150">ANTI-XSRF トークンのペイロードが暗号化され、署名済み、ツールを使用して、トークンを確認する場合は、ユーザー名を表示できないようにします。</span><span class="sxs-lookup"><span data-stu-id="f4202-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="f4202-151">暗号化サービスがによって提供される web アプリケーションで ASP.NET 4.0 が対象とするときに、 [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)ルーチン。</span><span class="sxs-lookup"><span data-stu-id="f4202-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="f4202-152">Web アプリケーションで ASP.NET 4.5 を対象とするまたはで提供される、暗号化サービスと、 [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))ルーチンより優れたパフォーマンス、拡張性、およびセキュリティを提供します。</span><span class="sxs-lookup"><span data-stu-id="f4202-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="f4202-153">詳細については、次のブログの投稿を参照してください。</span><span class="sxs-lookup"><span data-stu-id="f4202-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="f4202-154">Cryptographic Improvements in ASP.NET 4.5, pt.1</span><span class="sxs-lookup"><span data-stu-id="f4202-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="f4202-155">Cryptographic Improvements in ASP.NET 4.5, pt.2</span><span class="sxs-lookup"><span data-stu-id="f4202-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="f4202-156">Cryptographic Improvements in ASP.NET 4.5, pt.3</span><span class="sxs-lookup"><span data-stu-id="f4202-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="f4202-157">トークンを生成します。</span><span class="sxs-lookup"><span data-stu-id="f4202-157">Generating the tokens</span></span>

<span data-ttu-id="f4202-158">ANTI-XSRF トークンを生成するには、呼び出し、 [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC ビューからのメソッドまたは@AntiForgery.GetHtmlRazor ページから ()。</span><span class="sxs-lookup"><span data-stu-id="f4202-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="f4202-159">ランタイムは、次の手順を実行し、されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="f4202-160">現在の HTTP 要求には既に ANTI-XSRF のセッション トークンが含まれている場合 (ANTI-XSRF cookie \_ \_RequestVerificationToken)、セキュリティ トークンの抽出元。</span><span class="sxs-lookup"><span data-stu-id="f4202-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="f4202-161">ANTI-XSRF のセッション トークンが HTTP 要求に含まれていない場合、またはセキュリティ トークンの抽出に失敗した場合は、新しいランダムな ANTI-XSRF トークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="f4202-162">上記の手順 (1) と、現在ログインしているユーザーの id からセキュリティ トークンを使用して、ANTI-XSRF フィールドのトークンが生成されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="f4202-163">(ユーザー id を確認する方法については、次を参照してください、 **[特別なサポートのシナリオ](#_Scenarios_with_special)** 以下のセクションです。)。さらに場合、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx)はランタイムを呼び出すが、構成されているその[GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)メソッドとフィールドのトークンで返される文字列が含まれます。</span><span class="sxs-lookup"><span data-stu-id="f4202-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="f4202-164">(を参照してください、 **[構成と拡張機能](#_Configuration_and_extensibility)** 詳細についてはします)。</span><span class="sxs-lookup"><span data-stu-id="f4202-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="f4202-165">新しい ANTI-XSRF トークンは、(1) の手順で生成された場合、新しいセッション トークンはそれを含めるためが作成され、送信 HTTP クッキーのコレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="f4202-166">手順 (2) のフィールドのトークンにラップされます、`<input type="hidden" />`要素とこの HTML マークアップはの戻り値に`Html.AntiForgeryToken()`または`AntiForgery.GetHtml()`します。</span><span class="sxs-lookup"><span data-stu-id="f4202-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="f4202-167">トークンを検証</span><span class="sxs-lookup"><span data-stu-id="f4202-167">Validating the tokens</span></span>

<span data-ttu-id="f4202-168">入力方向の ANTI-XSRF トークンを検証するには、開発者が含まれます、 [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) 、MVC アクションまたはコント ローラー、または彼女の呼び出しに属性`@AntiForgery.Validate()`自分の Razor ページから。</span><span class="sxs-lookup"><span data-stu-id="f4202-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="f4202-169">ランタイムは、次の手順が実行されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="f4202-170">受信セッション トークンとフィールドのトークンが読み取られ、それぞれから ANTI-XSRF トークンを抽出します。</span><span class="sxs-lookup"><span data-stu-id="f4202-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="f4202-171">ANTI-XSRF トークンは、各世代ルーチンで、手順 (2) と同じである必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="f4202-172">現在のユーザーが認証されている場合、自分のユーザー名は、フィールドのトークンに格納されているユーザー名と比較されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="f4202-173">ユーザー名が一致する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-173">The usernames must match.</span></span>
3. <span data-ttu-id="f4202-174">場合、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)が構成されているランタイムの呼び出し、 *ValidateAdditionalData*メソッド。</span><span class="sxs-lookup"><span data-stu-id="f4202-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="f4202-175">メソッドはブール値を返す必要があります*true*します。</span><span class="sxs-lookup"><span data-stu-id="f4202-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="f4202-176">検証が成功すると、続行する、要求が許可されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="f4202-177">検証に失敗した場合、framework がスローされます、 *HttpAntiForgeryException*します。</span><span class="sxs-lookup"><span data-stu-id="f4202-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="f4202-178">エラー条件</span><span class="sxs-lookup"><span data-stu-id="f4202-178">Failure conditions</span></span>

<span data-ttu-id="f4202-179">以降、ASP.NET Web スタックのランタイムの v2 では、 *HttpAntiForgeryException*中にスローされる検証には問題点の詳細についてにが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f4202-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="f4202-180">現在定義されているエラー条件は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4202-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="f4202-181">セッション トークンまたはフォームのトークンでは、要求に存在しません。</span><span class="sxs-lookup"><span data-stu-id="f4202-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="f4202-182">セッション トークンは、フォーム トークンは、読み取ることができません。</span><span class="sxs-lookup"><span data-stu-id="f4202-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="f4202-183">これの最も可能性の高い原因は、ASP.NET Web スタックのランタイムまたはファームのバージョンの不一致を実行するファームで、 &lt;machineKey&gt; Web.config 内の要素は、マシン間で異なります。</span><span class="sxs-lookup"><span data-stu-id="f4202-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="f4202-184">Fiddler などのツールを使用して、強制的にこの例外をいずれかの ANTI-XSRF トークンを改ざんすることができます。</span><span class="sxs-lookup"><span data-stu-id="f4202-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="f4202-185">セッション トークンとフィールドのトークンがスワップされました。</span><span class="sxs-lookup"><span data-stu-id="f4202-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="f4202-186">セッション トークンとトークンをフィールドには、一致しないセキュリティ トークンが含まれます。</span><span class="sxs-lookup"><span data-stu-id="f4202-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="f4202-187">フィールドのトークンに埋め込まれたユーザー名は、現在ログインしているユーザーのユーザー名と一致しません。</span><span class="sxs-lookup"><span data-stu-id="f4202-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="f4202-188">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* メソッドが返される*false*します。</span><span class="sxs-lookup"><span data-stu-id="f4202-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="f4202-189">ANTI-XSRF 機能は、トークンの生成または検証中に追加のチェックも実行でき、例外がスローされているこれらのチェック中にエラーがあります。</span><span class="sxs-lookup"><span data-stu-id="f4202-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="f4202-190">参照してください、 [WIF/ACS]、[クレーム ベース認証](#_WIF_ACS)と **[構成と拡張機能](#_Configuration_and_extensibility)** 詳細については、セクション。</span><span class="sxs-lookup"><span data-stu-id="f4202-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="f4202-191">特別なサポートのシナリオ</span><span class="sxs-lookup"><span data-stu-id="f4202-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="f4202-192">匿名認証</span><span class="sxs-lookup"><span data-stu-id="f4202-192">Anonymous authentication</span></span>

<span data-ttu-id="f4202-193">ANTI-XSRF システムには"anonymous"が定義されているユーザーとして、匿名ユーザーの特殊なサポートが含まれる場所、 *IIdentity.IsAuthenticated*プロパティが返す*false*。</span><span class="sxs-lookup"><span data-stu-id="f4202-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="f4202-194">シナリオには、ログイン ページ (前に、ユーザーが認証される) と、メカニズムを使用アプリケーション以外のカスタム認証スキームに XSRF 保護を提供することが含まれます*IIdentity*ユーザーを識別します。</span><span class="sxs-lookup"><span data-stu-id="f4202-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="f4202-195">これらのシナリオをサポートするには、セキュリティ トークンには、128 ビット ランダムに生成された非透過識別子によって、セッションとフィールドのトークンが参加していることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="f4202-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="f4202-196">このセキュリティ トークンは、彼女匿名の識別子の目的を効果的に機能するために、サイトが移動したときに、個々 のユーザーのセッションを追跡するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="f4202-197">空の文字列は、上記の生成と検証ルーチンのユーザー名の代わりに使用されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="f4202-198">WIF/ACS]、[クレーム ベース認証</span><span class="sxs-lookup"><span data-stu-id="f4202-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="f4202-199">通常、 *IIdentity* 、.NET Framework に組み込まれているクラス プロパティが設定されている*IIdentity.Name*は特定のアプリケーション内の特定のユーザーを一意に識別するための十分な。</span><span class="sxs-lookup"><span data-stu-id="f4202-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="f4202-200">たとえば、 *FormsIdentity.Name* (これによって、そのデータベースのすべてのアプリケーションに対して一意では)、メンバーシップ データベースに格納されているユーザー名を返します*WindowsIdentity.Name*を返します、ユーザーのドメイン修飾 id です。</span><span class="sxs-lookup"><span data-stu-id="f4202-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="f4202-201">これらのシステムだけでなく認証を提供します。これらも*識別*アプリケーションに対するユーザー。</span><span class="sxs-lookup"><span data-stu-id="f4202-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="f4202-202">クレーム ベースの認証では、その一方は必ずしも必要ありません、特定のユーザーを識別します。</span><span class="sxs-lookup"><span data-stu-id="f4202-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="f4202-203">代わりに、 *ClaimsPrincipal*と*ClaimsIdentity*種類が一連の関連*要求*インスタンス、個々 の要求が「18 + 年齢の年が」をする可能性がありますか"管理者"するものです。</span><span class="sxs-lookup"><span data-stu-id="f4202-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="f4202-204">ユーザーを識別されていない必ずしもため、ランタイムは使用できません、 *ClaimsIdentity.Name*プロパティとして特定のユーザーの一意の識別子。</span><span class="sxs-lookup"><span data-stu-id="f4202-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="f4202-205">チームが実際の例を表示、 *ClaimsIdentity.Name*返します*null*フレンドリ (表示) 名を返しますまたは、それ以外の場合は、一意の識別子として使用するための適切な文字列を返しますユーザー。</span><span class="sxs-lookup"><span data-stu-id="f4202-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="f4202-206">クレーム ベース認証を使用する展開の多くを使用している[Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) 具体的には。</span><span class="sxs-lookup"><span data-stu-id="f4202-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="f4202-207">ACS では、個々 の開発者は構成がによって*id プロバイダー* (など、Microsoft アカウント プロバイダーを ADFS OpenID プロバイダーなどの yahoo! など)、id プロバイダーを返すと*識別子の名前*.</span><span class="sxs-lookup"><span data-stu-id="f4202-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="f4202-208">これらの名前識別子は、電子メール アドレスのように Personally Identifiable Information (PII) を含めることができますか、匿名化された Private Personal Identifier (PPID) のような可能性があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="f4202-209">関係なく、(id プロバイダー、名前識別子) タプル十分に役割を果たします、特定のユーザー用の適切な追跡トークンを生成するときに、ASP.NET Web スタックのランタイムは、ユーザー名の代わりに、タプルを使用できるように、サイトを参照彼女はときに、ANTI-XSRF フィールドのトークンを検証しています。</span><span class="sxs-lookup"><span data-stu-id="f4202-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="f4202-210">Id プロバイダーおよび名前識別子の特定の Uri は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4202-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="f4202-211">(この[ACS ドキュメント ページ](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)の詳細)。</span><span class="sxs-lookup"><span data-stu-id="f4202-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="f4202-212">生成するか、トークンを検証、ASP.NET Web スタックのランタイム実行時に試みます型にバインド。</span><span class="sxs-lookup"><span data-stu-id="f4202-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="f4202-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (用、WIF SDK があります。)</span><span class="sxs-lookup"><span data-stu-id="f4202-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="f4202-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5)。</span><span class="sxs-lookup"><span data-stu-id="f4202-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="f4202-215">これらの型が存在しない場合、現在のユーザーの*IIIIdentity*実装またはサブクラスのいずれかの種類、ANTI-XSRF 機能は、(id プロバイダー、名前識別子) を使用を生成する場合はユーザー名の代わりにタプルとトークンを検証します。</span><span class="sxs-lookup"><span data-stu-id="f4202-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="f4202-216">このような組が存在しない場合、要求は、開発者に、使用中、特定のクレーム ベースの認証メカニズムを理解する ANTI-XSRF システムを構成する方法を説明するエラーで失敗します。</span><span class="sxs-lookup"><span data-stu-id="f4202-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="f4202-217">参照してください、 **[構成と拡張機能](#_Configuration_and_extensibility)** 詳細についてはします。</span><span class="sxs-lookup"><span data-stu-id="f4202-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="f4202-218">OAuth と OpenID 認証</span><span class="sxs-lookup"><span data-stu-id="f4202-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="f4202-219">最後に、ANTI-XSRF 施設 OAuth または OpenID 認証を使用しているアプリケーション用の特別なサポートしています。</span><span class="sxs-lookup"><span data-stu-id="f4202-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="f4202-220">このサポートは、ヒューリスティックに基づく: 場合、現在*IIdentity.Name*はユーザー名の比較を実行し、 http:// または https:// で始まる既定 OrdinalIgnoreCase の比較子ではなく序数の比較子を使用します。</span><span class="sxs-lookup"><span data-stu-id="f4202-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="f4202-221">構成と拡張機能</span><span class="sxs-lookup"><span data-stu-id="f4202-221">Configuration and extensibility</span></span>

<span data-ttu-id="f4202-222">場合によっては、開発者は、ANTI-XSRF 生成と検証の動作に厳密な制御を必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="f4202-223">たとえば、おそらく HTTP クッキーを応答に自動的に追加の Web ページの MVC とヘルパーの既定の動作が望ましくないと、開発者がトークンを他の場所を保持することができます。</span><span class="sxs-lookup"><span data-stu-id="f4202-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="f4202-224">この作業に役立つ 2 つの Api が存在します。</span><span class="sxs-lookup"><span data-stu-id="f4202-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="f4202-225">*GetTokens*としてメソッドは、既存 XSRF 要求検証セッション トークン (null にすることがあります) を入力して、新しい XSRF 要求検証セッション トークンとフィールドのトークンを出力として生成します。</span><span class="sxs-lookup"><span data-stu-id="f4202-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="f4202-226">トークンは、単に不透明な文字列; の装飾なしの*formToken*値がのインスタンスでラップされなく、&lt;入力&gt;タグ。</span><span class="sxs-lookup"><span data-stu-id="f4202-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="f4202-227">*NewCookieToken*値があります。 この場合、null、 *oldCookieToken*値がまだ有効で、新しい応答 cookie を設定する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="f4202-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="f4202-228">呼び出し元*GetTokens* 、必要な応答のクッキーを永続化または; 必要なマークアップを生成する責任を負いますが、 *GetTokens*メソッド自体は副作用として、応答を変更しません。</span><span class="sxs-lookup"><span data-stu-id="f4202-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="f4202-229">*検証*メソッドは、受信セッションと、フィールドを選択し、トークンの上に、前述の検証ロジックを実行します。</span><span class="sxs-lookup"><span data-stu-id="f4202-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="f4202-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="f4202-230">AntiForgeryConfig</span></span>

<span data-ttu-id="f4202-231">開発者がアプリケーションから ANTI-XSRF システムを構成する\_を開始します。</span><span class="sxs-lookup"><span data-stu-id="f4202-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="f4202-232">構成はプログラムです。</span><span class="sxs-lookup"><span data-stu-id="f4202-232">Configuration is programmatic.</span></span> <span data-ttu-id="f4202-233">静的プロパティ*AntiForgeryConfig*型は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="f4202-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="f4202-234">要求を使用するほとんどのユーザーを UniqueClaimTypeIdentifier プロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="f4202-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="f4202-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="f4202-235">**Property**</span></span> | <span data-ttu-id="f4202-236">**説明**</span><span class="sxs-lookup"><span data-stu-id="f4202-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="f4202-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="f4202-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="f4202-238">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)をトークンの生成中に追加のデータを提供し、トークンの検証中に追加のデータを消費します。</span><span class="sxs-lookup"><span data-stu-id="f4202-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="f4202-239">既定値は*null*します。</span><span class="sxs-lookup"><span data-stu-id="f4202-239">The default value is *null*.</span></span> <span data-ttu-id="f4202-240">詳細については、次を参照してください。、 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)セクション。</span><span class="sxs-lookup"><span data-stu-id="f4202-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="f4202-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="f4202-241">**CookieName**</span></span> | <span data-ttu-id="f4202-242">ANTI-XSRF セッション トークンを格納するために使用される HTTP クッキーの名前を指定する文字列。</span><span class="sxs-lookup"><span data-stu-id="f4202-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="f4202-243">この値が設定されていない場合、名前が自動的に生成されます、アプリケーションのデプロイされた仮想パスに基づいています。</span><span class="sxs-lookup"><span data-stu-id="f4202-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="f4202-244">既定値は*null*します。</span><span class="sxs-lookup"><span data-stu-id="f4202-244">The default value is *null*.</span></span> |
| <span data-ttu-id="f4202-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="f4202-245">**RequireSsl**</span></span> | <span data-ttu-id="f4202-246">ANTI-XSRF トークンが SSL で保護されたチャネル経由で送信するために必要かどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="f4202-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="f4202-247">この値が場合*true*自動的に生成された cookie は、"secure"フラグを設定するには、していて、ANTI-XSRF Api が SSL 経由で送信が要求内から呼び出された場合にスローされます。</span><span class="sxs-lookup"><span data-stu-id="f4202-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="f4202-248">既定値は *false* です。</span><span class="sxs-lookup"><span data-stu-id="f4202-248">The default value is *false*.</span></span> |
| <span data-ttu-id="f4202-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="f4202-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="f4202-250">ANTI-XSRF システムに要求ベース id のサポートを非アクティブ化するかどうかを示すブール値。</span><span class="sxs-lookup"><span data-stu-id="f4202-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="f4202-251">この値が場合*true*、システムで、あると想定されます*IIdentity.Name*ユーザーごとの一意の識別子として使用するための適切なは、特別なケースは試みません*IClaimsIdentity*または*ClClaimsIdentity* 」の説明に従って、 [WIF/ACS]、[クレーム ベース認証](#_WIF_ACS)セクション。</span><span class="sxs-lookup"><span data-stu-id="f4202-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="f4202-252">既定値は `false` です。</span><span class="sxs-lookup"><span data-stu-id="f4202-252">The default value is `false`.</span></span> |
| <span data-ttu-id="f4202-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="f4202-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="f4202-254">どの要求の種類を示す文字列は、ユーザーごとの一意の識別子として使用するために適しています。</span><span class="sxs-lookup"><span data-stu-id="f4202-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="f4202-255">この値が設定され、現在場合*IIdentity*で指定されたクレームに基づく、システムは、種類のクレームを抽出しよう*UniqueClaimTypeIdentifier*、対応する値が使用されますフィールドのトークンを生成するときに、ユーザーのユーザー名の代わりに</span><span class="sxs-lookup"><span data-stu-id="f4202-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="f4202-256">要求の種類が見つからない場合、システムには、要求は失敗します。</span><span class="sxs-lookup"><span data-stu-id="f4202-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="f4202-257">既定値は*null*、(id プロバイダー、名前識別子)、システムを使用することを示します組のユーザー名の代わりに前述のようです。</span><span class="sxs-lookup"><span data-stu-id="f4202-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="f4202-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="f4202-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="f4202-259">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 型により、開発者は各トークン内の追加データのラウンド トリップで ANTI-XSRF システムの動作を拡張します。</span><span class="sxs-lookup"><span data-stu-id="f4202-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="f4202-260">*GetAdditionalData*メソッドが呼び出されるフィールドのトークンが生成され、戻り値が生成されたトークン内に埋め込まれています。</span><span class="sxs-lookup"><span data-stu-id="f4202-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="f4202-261">実装するときは、このメソッドから、タイムスタンプ、nonce、またはユーザーがその他の値を返すことができます。</span><span class="sxs-lookup"><span data-stu-id="f4202-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="f4202-262">同様に、 *ValidateAdditionalData*メソッドが呼び出されるフィールドのトークンの検証し、トークン内に埋め込まれた「追加のデータ」文字列は、メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="f4202-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="f4202-263">検証ルーチン (トークンの作成時に格納されている時間に対して、現在の時刻をチェック) をタイムアウトを実装することが、必要なロジックのルーチン、またはその他のチェック nonce。</span><span class="sxs-lookup"><span data-stu-id="f4202-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="f4202-264">設計に関する決定事項とセキュリティに関する考慮事項</span><span class="sxs-lookup"><span data-stu-id="f4202-264">Design decisions and security considerations</span></span>

<span data-ttu-id="f4202-265">セッションとフィールドのトークンをリンクするセキュリティ トークンは技術的には必要な場合にのみ XSRF 攻撃からの匿名/認証されていないユーザーを保護しようとしています。</span><span class="sxs-lookup"><span data-stu-id="f4202-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="f4202-266">認証トークン (おそらくは cookie の形式で送信された) 自体が 1 つとしてされる可能性があります、ユーザーが認証されると、トークンのペアのシンクロナイザーの半分です。</span><span class="sxs-lookup"><span data-stu-id="f4202-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="f4202-267">ただし、ログイン ページが認証されていないユーザーは、ヒットを保護するための有効なシナリオがされ、ANTI-XSRF ロジックは、常に生成して、認証されたユーザーの場合でも、セキュリティ トークンを検証して単純なされていました。</span><span class="sxs-lookup"><span data-stu-id="f4202-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="f4202-268">いくつか追加の保護を設定またはセッション トークンを克服するために攻撃者の別のハードルとなる推測と、攻撃者によってフィールドのトークンに欠陥があること。</span><span class="sxs-lookup"><span data-stu-id="f4202-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="f4202-269">複数のアプリケーションが 1 つのドメインでホストされている場合は、開発者が注意を使用してください。</span><span class="sxs-lookup"><span data-stu-id="f4202-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="f4202-270">たとえば、場合でも*example1.cloudapp.net*と*example2.cloudapp.net*はさまざまなホストは、すべてのホスト間で暗黙的な信頼リレーションシップがある、  *\*. cloudapp.net*ドメイン。</span><span class="sxs-lookup"><span data-stu-id="f4202-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="f4202-271">この暗黙的な信頼関係[互いの cookie に影響を与える可能性のある信頼されていないホストできる](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks)(AJAX 要求を管理する同一オリジン ポリシーに必ずしも適用ない HTTP cookie)。</span><span class="sxs-lookup"><span data-stu-id="f4202-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="f4202-272">ASP.NET Web スタックのランタイムは、フィールドのトークンにユーザー名が埋め込まれているため、場合でも、悪意のあるサブドメインは、セッション トークンを上書きすることができなく、ユーザーの有効なフィールドのトークンを生成することで、いくつかの軽減策を提供します。</span><span class="sxs-lookup"><span data-stu-id="f4202-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="f4202-273">ただし、このような環境でホストされている場合、組み込みの ANTI-XSRF ルーチンもことはできません防御セッション ハイジャックまたは XSRF のログイン。</span><span class="sxs-lookup"><span data-stu-id="f4202-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="f4202-274">ANTI-XSRF ルーチンがに対する防御はいない現在[クリックジャッ キング](https://www.owasp.org/index.php/Clickjacking)します。</span><span class="sxs-lookup"><span data-stu-id="f4202-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="f4202-275">アプリケーション自体をクリックジャッ キングに対する防御が、X のフレームのオプションを送信することによって行う簡単にことがあります。各応答と共に SAMEORIGIN ヘッダー。</span><span class="sxs-lookup"><span data-stu-id="f4202-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="f4202-276">このヘッダーは、最近のすべてのブラウザーでサポートされます。</span><span class="sxs-lookup"><span data-stu-id="f4202-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="f4202-277">詳細については、次を参照してください。、 [IE ブログ](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL ブログ](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)、および[OWASP](https://www.owasp.org/index.php/Clickjacking)します。</span><span class="sxs-lookup"><span data-stu-id="f4202-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="f4202-278">いくつかの将来のリリースください、MVC、ASP.NET Web スタック ランタイム可能性があり、Web ページの ANTI-XSRF ヘルパーは、アプリケーションは、この攻撃に対しては自動的に保護できるように自動的にこのヘッダーを設定します。</span><span class="sxs-lookup"><span data-stu-id="f4202-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="f4202-279">Web 開発者は、そのサイトが XSS 攻撃に対して脆弱でないことを確認する続行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="f4202-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="f4202-280">XSS 攻撃が非常に強力なと悪用、XSRF 攻撃からの ASP.NET Web スタック ランタイム防御機能でも改ページします。</span><span class="sxs-lookup"><span data-stu-id="f4202-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="f4202-281">受信確認</span><span class="sxs-lookup"><span data-stu-id="f4202-281">Acknowledgment</span></span>

<span data-ttu-id="f4202-282">[@LeviBroderick](https://twitter.com/LeviBroderick)、作成者、ASP.NET のセキュリティ コードの多くはこの情報の一括します。</span><span class="sxs-lookup"><span data-stu-id="f4202-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
