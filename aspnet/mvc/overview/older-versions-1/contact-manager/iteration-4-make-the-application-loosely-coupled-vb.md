---
uid: mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-vb
title: 'イテレーション #4 – アプリケーションを疎結合 (VB) にする |マイクロソフトドキュメント'
author: rick-anderson
description: この 4 回目のイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションの保守と変更を容易にします。 のために..
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 92c70297-4430-4e4e-919a-9c2333a8d09a
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-4-make-the-application-loosely-coupled-vb
msc.type: authoredcontent
ms.openlocfilehash: 1026e307b7e498a8b1392f2907c08cdcd05a3199
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542769"
---
# <a name="iteration-4--make-the-application-loosely-coupled-vb"></a>繰り返し #4 – アプリケーションを疎結合にする (VB)

[マイクロソフト](https://github.com/microsoft)

[コードをダウンロード](iteration-4-make-the-application-loosely-coupled-vb/_static/contactmanager_4_vb1.zip)

> この 4 回目のイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションの保守と変更を容易にします。 たとえば、リポジトリ パターンと依存関係の挿入パターンを使用するようにアプリケーションをリファクタリングします。

## <a name="building-a-contact-management-aspnet-mvc-application-vb"></a>MVC アプリケーション (VB) ASP.NET連絡先管理の構築

この一連のチュートリアルでは、最初から最後まで連絡先管理アプリケーション全体を構築します。 連絡先マネージャー アプリケーションでは、連絡先の情報 (名前、電話番号、電子メール アドレス) を保存できます。

複数のイテレーションでアプリケーションをビルドします。 各反復処理で、アプリケーションを徐々に改善します。 この複数の反復アプローチの目的は、各変更の理由を理解できるようにすることです。

- イテレーション #1 - アプリケーションを作成します。 最初のイテレーションでは、できるだけ簡単な方法で連絡先マネージャーを作成します。 基本的なデータベース操作のサポートを追加: 作成、読み取り、更新、および削除 (CRUD) 。

- イテレーション #2 - アプリケーションを見栄えよくします。 このイテレーションでは、既定の ASP.NET MVC ビュー マスター ページとカスケード スタイル シートを変更することで、アプリケーションの外観を向上させます。

- イテレーション #3 - フォームの検証を追加します。 3 回目のイテレーションでは、基本的なフォーム検証を追加します。 必須のフォームフィールドに入力せずにフォームを送信できないようにします。 また、メールアドレスと電話番号も検証します。

- イテレーション #4 - アプリケーションを疎結合にします。 この 4 回目のイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションの保守と変更を容易にします。 たとえば、リポジトリ パターンと依存関係の挿入パターンを使用するようにアプリケーションをリファクタリングします。

- イテレーション #5 - 単体テストを作成します。 5 回目のイテレーションでは、単体テストを追加することで、アプリケーションの保守と変更を容易にします。 データ モデル クラスをモックし、コントローラーと検証ロジックの単体テストをビルドします。

- イテレーション #6 - テスト駆動型開発を使用します。 この 6 回目のイテレーションでは、単体テストを最初に記述し、単体テストに対してコードを記述することで、アプリケーションに新しい機能を追加します。 このイテレーションでは、連絡先グループを追加します。

- イテレーション #7 - Ajax 機能を追加します。 7 回目のイテレーションでは、Ajax のサポートを追加することで、アプリケーションの応答性とパフォーマンスを向上させます。

## <a name="this-iteration"></a>このイテレーション

連絡先マネージャー アプリケーションのこの 4 回目のイテレーションでは、アプリケーションをより疎結合するようにリファクタリングします。 アプリケーションが疎結合されている場合、アプリケーションの他の部分のコードを変更する必要なく、アプリケーションの 1 つの部分でコードを変更できます。 疎結合アプリケーションは、変更に対してより弾力性があります。

現在、Contact Manager アプリケーションで使用されるすべてのデータ アクセスおよび検証ロジックは、コントローラー クラスに含まれています。 これは悪い考えです。 アプリケーションの一部を変更する必要がある場合は、アプリケーションの別の部分にバグが発生するリスクがあります。 たとえば、検証ロジックを変更すると、データ アクセスやコントローラロジックに新しいバグが発生する危険性があります。

> [!NOTE] 
> 
> (SRP) を変更する理由がクラスに複数ある必要があります。 コントローラ、検証、データベースロジックの混在は、単一責任原則に大きな違反です。

アプリケーションの変更が必要になる理由はいくつかあります。 アプリケーションに新しい機能を追加する必要がある場合、アプリケーションのバグを修正する必要がある場合、またはアプリケーションの機能の実装方法を変更する必要がある場合があります。 アプリケーションが静的であることはめったにありません。 彼らは成長し、時間の経過とともに変異する傾向があります。

たとえば、データ アクセス層の実装方法を変更するとします。 現時点では、連絡先マネージャー アプリケーションは、データベースにアクセスするのに Microsoft エンティティ フレームワークを使用します。 ただし、ADO.NET データ サービスや NHibernate などの新しいまたは代替のデータ アクセス テクノロジに移行する場合があります。 ただし、データ アクセス コードは検証コードやコントローラー コードから分離されていないため、データ アクセスに直接関連しない他のコードを変更せずに、アプリケーションのデータ アクセス コードを変更する方法はありません。

アプリケーションが疎結合されている場合、アプリケーションの他の部分に触れることなく、アプリケーションの一部を変更できます。 たとえば、検証やコントローラのロジックを変更せずに、データ アクセス テクノロジを切り替えることができます。

このイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションをより疎結合のアプリケーションにリファクタリングできます。 完了すると、連絡先マネージャーは以前に行わなかったことを何もしません。 ただし、今後はアプリケーションをより簡単に変更できるようになります。

> [!NOTE] 
> 
> リファクタリングとは、既存の機能を失わないようにアプリケーションを書き換えるプロセスです。

## <a name="using-the-repository-software-design-pattern"></a>リポジトリ ソフトウェア設計パターンの使用

最初の変更は、リポジトリパターンと呼ばれるソフトウェア設計パターンを利用することです。 リポジトリ パターンを使用して、アプリケーションの他の部分からデータ アクセス コードを分離します。

リポジトリ パターンを実装するには、次の 2 つの手順を実行する必要があります。

1. インターフェイスを作成する
2. インターフェイスを実装する具象クラスを作成する

まず、実行する必要があるすべてのデータ アクセス メソッドを記述するインターフェイスを作成する必要があります。 IContactManager リポジトリ インターフェイスは、リスト 1 に含まれています。 このインターフェイスでは、5 つのメソッドについて説明します: 連絡先を作成する()、連絡先を削除する()、編集接触()、GetContacts()。

**リスト 1 - モデル\IContactManager リポジトリ.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample1.vb)]

次に、インターフェイスを実装する具体的なクラスを作成する必要があります。 データベースにアクセスするために Microsoft エンティティ フレームワークを使用しているため、EntityContactManagerRepository という名前の新しいクラスを作成します。 このクラスはリスト 2 に含まれています。

**リスト 2 - モデル\エンティティコンタクトマネージャーリポジトリ.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample2.vb)]

クラスが IContactManager リポジトリ インターフェイスを実装していることに注意してください。 このクラスは、そのインターフェイスで記述されている 5 つのメソッドすべてを実装します。

なぜ私たちはインターフェイスを気にする必要があるのか疑問に思うかもしれません。 インターフェイスとそれを実装するクラスの両方を作成する必要があるのはなぜですか?

1 つの例外を除いて、アプリケーションの残りの部分は、具象クラスではなくインターフェイスと対話します。 クラスによって公開されるメソッドを呼び出す代わりに、IContactManagerRepository インターフェイスによって公開されるメソッドを呼び出します。

そうすれば、アプリケーションの残りの部分を変更することなく、新しいクラスでインターフェイスを実装できます。 たとえば、将来の日付に、インターフェイスを実装するクラスを実装する必要があります。 クラスは、ADO.NET データ サービスを使用して、Microsoft エンティティ フレームワークの代わりにデータベースにアクセスする場合があります。

アプリケーション コードが、具体的な EntityContactManagerRepository クラスではなく IContactManagerRepository インターフェイスに対してプログラムされている場合は、コードの残りの部分を変更せずに具体的なクラスを切り替えることができます。 たとえば、データ アクセスまたは検証ロジックを変更せずに、EntityContactManagerRepository クラスから DataServicesContactManager リポジトリ クラスに切り替えることができます。

具体的なクラスではなくインターフェイス (抽象化) に対するプログラミングを行うと、アプリケーションの変更に対する耐性が高くなります。

> [!NOTE] 
> 
> メニュー オプションリファクタリング、インターフェイスの抽出を選択することで、Visual Studio 内の具象クラスからインターフェイスをすばやく作成できます。 たとえば、最初に EntityContactManagerRepository クラスを作成し、次にインターフェイスの抽出を使用して IContactManager リポジトリ インターフェイスを自動的に生成できます。

## <a name="using-the-dependency-injection-software-design-pattern"></a>依存性注入ソフトウェア設計パターンの使用

データ アクセス コードを別のリポジトリ クラスに移行したので、このクラスを使用するように連絡先コントローラーを変更する必要があります。 私たちは、私たちのコントローラでリポジトリクラスを使用するために依存性注入と呼ばれるソフトウェア設計パターンを利用します。

変更された連絡先コントローラはリスト 3 に含まれています。

**リスト 3 - コントローラー\連絡先コントローラー.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample3.vb)]

リスト 3 の Contact コントローラには 2 つのコンストラクターがあることに注意してください。 最初のコンストラクターは、IContactManagerRepository インターフェイスの具象インスタンスを 2 番目のコンストラクターに渡します。 連絡先のコント ローラー クラスは *、コンストラクター依存関係の挿入を*使用します。

クラスが使用される唯一の場所は、最初のコンストラクターにあります。 クラスの残りの部分では、具体的なエンティティコンタクトマネージャーリポジトリクラスの代わりにIContactManagerRepositoryインターフェイスを使用します。

これにより、将来の IContactManager リポジトリ クラスの実装を簡単に切り替えることができます。 クラスの代わりにデータ サービス連絡先リポジトリ クラスを使用する場合は、最初のコンストラクターを変更するだけです。

コンストラクター依存関係の注入は、Contact コントローラー クラスを非常にテスト可能にします。 単体テストでは、IContactManagerRepository クラスのモック実装を渡すことによって、連絡先コント ローラーをインスタンス化できます。 依存関係の挿入のこの機能は、連絡先マネージャー アプリケーションの単体テストをビルドするときに、次のイテレーションで非常に重要になります。

> [!NOTE] 
> 
> 連絡先コント ローラー クラスを IContactManagerRepository インターフェイスの特定の実装から完全に分離する場合は、StructureMap や Microsoft エンティティ フレームワーク (MEF) などの依存関係の挿入をサポートするフレームワークを利用できます。 依存関係挿入フレームワークを利用することで、コード内で具象クラスを参照する必要がなさ。

## <a name="creating-a-service-layer"></a>サービスレイヤの作成

リスト 3 の変更されたコント ローラー クラスで、検証ロジックがコント ローラー ロジックとまだ混同されている可能性があります。 データ アクセス ロジックを分離するのも同じ理由で、検証ロジックを分離することをお勧めします。

この問題を解決するには、別の[サービス層](http://martinfowler.com/eaaCatalog/serviceLayer.html)を作成します。 サービス層は、コントローラクラスとリポジトリクラスの間に挿入できる個別のレイヤです。 サービス層には、すべての検証ロジックを含むビジネスロジックが含まれています。

サービスはリスト 4 に含まれています。 連絡先コント ローラー クラスからの検証ロジックが含まれています。

**リスト 4 - モデル\コンタクトマネージャーサービス.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample4.vb)]

コンストラクターには検証ディクショナリが必要であることに注意してください。 サービス層は、この検証ディクショナリを介してコントローラー層と通信します。 デコレータ パターンについて説明する場合は、次のセクションで検証ディクショナリについて詳しく説明します。

さらに、インターフェイスが実装されていることに注意してください。 具体的なクラスではなく、インターフェイスに対するプログラミングに常に努める必要があります。 連絡先マネージャー アプリケーション内の他のクラスは、直接の連絡先マネージャー サービス クラスと対話しません。 代わりに、1 つの例外を除き、連絡先マネージャー アプリケーションの残りの部分は、IContactManagerService インターフェイスに対してプログラムされます。

インターフェイスはリスト 5 に含まれています。

**リスト 5 - モデル\IContactManagerサービス.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample5.vb)]

変更された連絡先コントローラー クラスは、リスト 6 に含まれています。 連絡先コント ローラーは、もはや連絡先マネージャー リポジトリと対話します。 代わりに、連絡先コント ローラーは、連絡先マネージャー サービスと対話します。 各レイヤーは、他のレイヤーから可能な限り分離されます。

**リスト 6 - コントローラー\連絡先コントローラー.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample6.vb)]

アプリケーションは、もはや単一責任原則(SRP)の反則を実行しません。 リスト 6 の連絡先コントローラーは、アプリケーション実行のフローを制御する以外のすべての責任を取り除かれています。 すべての検証ロジックが連絡先コントローラーから削除され、サービス層にプッシュされました。 すべてのデータベース ロジックがリポジトリ レイヤにプッシュされました。

## <a name="using-the-decorator-pattern"></a>デコレータ パターンの使用

私たちは、サービス層をコントローラ層から完全に切り離すことができるようにしたいと考えています。 原則として、MVC アプリケーションへの参照を追加する必要なく、コントローラーレイヤーとは別のアセンブリでサービス層をコンパイルできるはずです。

ただし、サービス層は検証エラーメッセージをコントローラ層に渡すことができる必要があります。 コントローラとサービス層を結合せずに、サービス層が検証エラーメッセージを伝えるようにするにはどうしたらいいでしょうか。 [デコレータ](http://en.wikipedia.org/wiki/Decorator_pattern)パターンという名前のソフトウェアデザインパターンを利用できます。

コントローラーは、検証エラーを表すために ModelState という名前のモデル状態ディクショナリを使用します。 したがって、コントローラー層からサービス層に ModelState を渡したいと思うかもしれません。 ただし、サービス層で ModelState を使用すると、サービスレイヤーは ASP.NET MVC フレームワークの機能に依存します。 これは、いつか、ASP.NETのMVCアプリケーションの代わりにWPFアプリケーションでサービス層を使用する場合があるため、悪い結果が出ます。 その場合は、ASP.NET MVC フレームワークを参照して ModelStateDictionary クラスを使用する必要はありません。

デコレータ パターンを使用すると、インターフェイスを実装するために、既存のクラスを新しいクラスにラップできます。 当社のコンタクトマネージャプロジェクトには、リスト7に含まれるModelStateWrapperクラスが含まれています。 クラスは、リスト 8 のインターフェイスを実装します。

**リスト 7 - モデル\検証\モデルステートラッパー.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample7.vb)]

**リスト 8 - モデル\検証\I検証ディクショナリ.vb**

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample8.vb)]

リスト 5 を詳しく見ると、ContactManager サービス レイヤーが IValidationDictionary インターフェイスを排他的に使用していることがわかります。 サービスは、クラスに依存していません。 連絡先コント ローラーは、ContactManager サービスを作成すると、コント ローラーは、次のように、そのモデル状態をラップします。

[!code-vb[Main](iteration-4-make-the-application-loosely-coupled-vb/samples/sample9.vb)]

## <a name="summary"></a>まとめ

このイテレーションでは、連絡先マネージャー アプリケーションに新しい機能を追加しませんでした。 このイテレーションの目的は、保守と変更が容易になるように、Contact Manager アプリケーションをリファクタリングすることです。

まず、リポジトリソフトウェア設計パターンを実装しました。 すべてのデータ アクセス コードを別の ContactManager リポジトリ クラスに移行しました。

また、コントローラー ロジックから検証ロジックを分離しました。 すべての検証コードを含む個別のサービス層を作成しました。 コントローラー層がサービス層と対話し、サービス層がリポジトリ層と対話します。

サービス層を作成するときに、デコレータ パターンを利用して ModelState をサービス層から分離しました。 サービス層では、モデル状態の代わりに IValidationDictionary インターフェイスに対してプログラミングを行いました。

最後に、依存性注入パターンという名前のソフトウェア設計パターンを利用しました。 このパターンを使用すると、具象クラスではなくインターフェイス (抽象化) に対してプログラミングできます。 依存関係の挿入のデザイン パターンを実装すると、コードのテストも容易になります。 次のイテレーションでは、単体テストをプロジェクトに追加します。

> [!div class="step-by-step"]
> [前へ](iteration-3-add-form-validation-vb.md)
> [次へ](iteration-5-create-unit-tests-vb.md)
