---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: 'イテレーション #5 – 単体テストの作成 (C#) |マイクロソフトドキュメント'
author: rick-anderson
description: 5 回目のイテレーションでは、単体テストを追加することで、アプリケーションの保守と変更を容易にします。 私たちは、データモデルクラスを模倣し、o..のための単体テストを構築します。
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: c005a8ffc3b09c126d796f2feb74d402cb784aa2
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542353"
---
# <a name="iteration-5--create-unit-tests-c"></a>繰り返し #5 – 単体テストを作成する (C#)

[マイクロソフト](https://github.com/microsoft)

[コードをダウンロード](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> 5 回目のイテレーションでは、単体テストを追加することで、アプリケーションの保守と変更を容易にします。 データ モデル クラスをモックし、コントローラーと検証ロジックの単体テストをビルドします。

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a>MVC アプリケーション (C#) ASP.NET連絡先管理の構築

この一連のチュートリアルでは、最初から最後まで連絡先管理アプリケーション全体を構築します。 連絡先マネージャー アプリケーションでは、連絡先の情報 (名前、電話番号、電子メール アドレス) を保存できます。

複数のイテレーションでアプリケーションをビルドします。 各反復処理で、アプリケーションを徐々に改善します。 この複数の反復アプローチの目的は、各変更の理由を理解できるようにすることです。

- イテレーション #1 - アプリケーションを作成します。 最初のイテレーションでは、できるだけ簡単な方法で連絡先マネージャーを作成します。 基本的なデータベース操作のサポートを追加: 作成、読み取り、更新、および削除 (CRUD) 。

- イテレーション #2 - アプリケーションを見栄えよくします。 このイテレーションでは、既定の ASP.NET MVC ビュー マスター ページとカスケード スタイル シートを変更することで、アプリケーションの外観を向上させます。

- イテレーション #3 - フォームの検証を追加します。 3 回目のイテレーションでは、基本的なフォーム検証を追加します。 必須のフォームフィールドに入力せずにフォームを送信できないようにします。 また、メールアドレスと電話番号も検証します。

- イテレーション #4 - アプリケーションを疎結合にします。 この 4 回目のイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションの保守と変更を容易にします。 たとえば、リポジトリ パターンと依存関係の挿入パターンを使用するようにアプリケーションをリファクタリングします。

- イテレーション #5 - 単体テストを作成します。 5 回目のイテレーションでは、単体テストを追加することで、アプリケーションの保守と変更を容易にします。 データ モデル クラスをモックし、コントローラーと検証ロジックの単体テストをビルドします。

- イテレーション #6 - テスト駆動型開発を使用します。 この 6 回目のイテレーションでは、単体テストを最初に記述し、単体テストに対してコードを記述することで、アプリケーションに新しい機能を追加します。 このイテレーションでは、連絡先グループを追加します。

- イテレーション #7 - Ajax 機能を追加します。 7 回目のイテレーションでは、Ajax のサポートを追加することで、アプリケーションの応答性とパフォーマンスを向上させます。

## <a name="this-iteration"></a>このイテレーション

連絡先マネージャー アプリケーションの前のイテレーションでは、アプリケーションがより緩やかに結合されるようにリファクタリングしました。 アプリケーションを、コントローラ、サービス、リポジトリの各層に分けました。 各レイヤは、インターフェイスを介して、その下のレイヤと対話します。

アプリケーションの保守と変更を容易にするために、アプリケーションをリファクタリングしました。 たとえば、新しいデータ アクセス テクノロジを使用する必要がある場合は、コントローラーやサービス 層に触れることなく、リポジトリ レイヤーを変更するだけで済みます。 Contact Manager を疎結合することで、アプリケーションの変更に対する耐性が高くなりました。

しかし、連絡先マネージャアプリケーションに新しい機能を追加する必要がある場合はどうなりますか? または、バグを修正するとどうなりますか? コードを記述する際の悲しい、しかし十分に証明された真実は、コードに触れるたびに新しいバグが発生するリスクを生み出すことです。

たとえば、ある晴れた日に、上司から連絡先マネージャーに新しい機能を追加するように依頼されることがあります。 彼女は、連絡先グループのサポートを追加することを望んでいます。 この場合、ユーザーは連絡先をフレンドやビジネスなどのグループに整理できるようにしたいと考えています。

この新機能を実装するには、Contact Manager アプリケーションの 3 つのレイヤーすべてを変更する必要があります。 コントローラー、サービス層、およびリポジトリに新しい機能を追加する必要があります。 コードの変更を開始するとすぐに、以前に機能していた機能が壊れる危険性があります。

前回のイテレーションと同様に、アプリケーションを別々のレイヤーにリファクタリングすることは良いことです。 それは私たちがアプリケーションの残りの部分に触れることなく、全体のレイヤーに変更を加えることを可能にするので、それは良いことでした。 ただし、レイヤー内のコードを管理および変更しやすくする場合は、コードの単体テストを作成する必要があります。

単体テストを使用して、コードの個々の単位をテストします。 これらのコード単位は、アプリケーション層全体よりも小さくなります。 通常、単体テストを使用して、コード内の特定のメソッドが期待どおりの動作をするかどうかを確認します。 たとえば、クラスによって公開される CreateContact() メソッドの単体テストを作成します。

アプリケーションの単体テストは、セーフティ ネットと同様に機能します。 アプリケーションのコードを変更するたびに、一連の単体テストを実行して、変更によって既存の機能が壊れるかどうかを確認できます。 単体テストを実行すると、コードを安全に変更できます。 単体テストを行うアプリケーションのすべてのコードは、変更に対する回復力を高めます。

このイテレーションでは、連絡先マネージャー アプリケーションに単体テストを追加します。 このようにして、次のイテレーションでは、既存の機能を破壊する心配をせずに、アプリケーションに連絡先グループを追加できます。

> [!NOTE] 
> 
> NUnit、xUnit.net、および MbUnit を含むさまざまな単体テスト フレームワークがあります。 このチュートリアルでは、Visual Studio に含まれている単体テスト フレームワークを使用します。 ただし、これらの代替フレームワークの 1 つを簡単に使用できます。

## <a name="what-gets-tested"></a>テスト内容

完璧な世界では、すべてのコードが単体テストでカバーされます。 完璧な世界では、あなたは完璧なセーフティネットを持つことになります。 アプリケーション内の任意のコード行を変更し、単体テストを実行することで、変更が既存の機能を壊したかどうかを即座に知ることができます。

しかし、私たちは完璧な世界に住んでいません。 実際には、単体テストを記述する場合、ビジネス ロジック (検証ロジックなど) のテストを記述するに集中します。 特に、データ アクセス ロジックまたはビュー ロジックの単体テストは記述*しません*。

便利なように、単体テストは非常に迅速に実行する必要があります。 アプリケーションの単体テストは、数百個 (あるいは数千個) まで簡単に蓄積できます。 単体テストの実行に時間がかかる場合は、実行を避けます。 つまり、長時間実行される単体テストは、日々のコーディングの目的では役に立ちません。

このため、通常は、データベースと対話するコードの単体テストを記述しません。 数百単位の単体テストをライブ データベースに対して実行すると、処理速度が遅すぎます。 代わりに、データベースをモックし、モック データベースとやり取りするコードを記述します (以下のデータベースのモックを作成する方法について説明します)。

同様の理由で、通常はビューの単体テストを記述しません。 ビューをテストするには、Web サーバーをスピンアップする必要があります。 Web サーバーをスピンアップするプロセスは比較的低速であるため、ビューの単体テストを作成することはお勧めできません。

ビューに複雑なロジックが含まれている場合は、ロジックを Helper メソッドに移動することを検討する必要があります。 Web サーバーを回転させることなく実行するヘルパー メソッドの単体テストを記述できます。

> [!NOTE] 
> 
> 単体テストを記述する際に、データ アクセス ロジックまたはビュー ロジックのテストを記述することはお勧めできませんが、これらのテストは、機能テストや統合テストをビルドするときに非常に役立ちます。

> [!NOTE] 
> 
> mvc ASP.NET Web フォーム ビュー エンジンです。 Web フォーム ビュー エンジンは Web サーバーに依存していますが、他のビュー エンジンは依存しない場合があります。

## <a name="using-a-mock-object-framework"></a>モック オブジェクト フレームワークの使用

単体テストをビルドする場合、ほとんどの場合、モック オブジェクト フレームワークを利用する必要があります。 モック オブジェクト フレームワークを使用すると、アプリケーションのクラスのモックとスタブを作成できます。

たとえば、モック オブジェクト フレームワークを使用して、リポジトリ クラスのモック バージョンを生成できます。 そうすれば、単体テストで実際のリポジトリ クラスの代わりにモック リポジトリ クラスを使用できます。 モック リポジトリを使用すると、単体テストの実行時にデータベース コードを実行することを回避できます。

Visual Studio には、モック オブジェクト フレームワークは含まれていません。 ただし、.NET フレームワークでは、いくつかの商用およびオープン ソースのモック オブジェクト フレームワークが利用できます。

1. Moq - このフレームワークはオープンソースのBSDライセンスの下で利用可能です。 Moq は から[https://code.google.com/p/moq/](https://code.google.com/p/moq/)ダウンロードできます。
2. Rhinoモック - このフレームワークはオープンソースのBSDライセンスの下で利用可能です。 あなたは、Rhino[http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)のモックからダウンロードすることができます.
3. タイプモックアイソレータ - これは、商業フレームワークです。 から試用版をダウンロードできます[http://www.typemock.com/](http://www.typemock.com/)。

このチュートリアルでは、Moqを使用することにしました。 ただし、同じように簡単に Rhinoモックやタイプモックアイソレータを使用して、連絡先マネージャアプリケーションのモックオブジェクトを作成することができます。

Moq を使用する前に、以下の手順を完了する必要があります。

1. .
2. ダウンロードを解凍する前に、ファイルを右クリックし、[**ブロック解除**] というボタンをクリックしてください (図 1 参照)。
3. ダウンロードを解凍します。
4. 参照を追加する、 Moq アセンブリの参照を右クリックして、 ContactManager.Tests プロジェクトで参照フォルダーをクリックし、**参照の追加**を選択します。 [参照] タブで、Moq を解凍したフォルダを参照し、Moq.dll アセンブリを選択します。 **[OK]** をクリックします。
5. これらの手順を完了すると、References フォルダーは図 2 のようになります。

[![ブロック解除の Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)

**図 01**: ブロック解除 Moq ([フルサイズの画像を表示する をクリック](iteration-5-create-unit-tests-cs/_static/image2.png))

[![Moq を追加した後の参照](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)

**図 02**: Moq を追加した後の参考資料 ([フルサイズの画像を表示する をクリック](iteration-5-create-unit-tests-cs/_static/image4.png))

## <a name="creating-unit-tests-for-the-service-layer"></a>サービス層の単体テストの作成

まず、Contact Manager アプリケーションのサービス層に対する単体テストのセットを作成します。 これらのテストを使用して、検証ロジックを検証します。

という名前の新しいフォルダーを作成します。 次に、Models フォルダを右クリックし **、[追加]、[新しいテスト**] の順に選択します。 図 3 に示す **[新しいテストの追加**] ダイアログが表示されます。 **単体テスト**テンプレートを選択し、新しいテスト ContactManagerServiceTest.csに名前を付けます。 **[OK] ボタン**をクリックして、新しいテストをテスト プロジェクトに追加します。

> [!NOTE] 
> 
> 一般に、テスト プロジェクトのフォルダー構造は、ASP.NET MVC プロジェクトのフォルダー構造と一致するようにします。 たとえば、コントローラー テストを Controllers フォルダーに配置し、モデル テストを Models フォルダーに配置するなどです。

[![モデル\コンタクトマネージャーサービステスト.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)

**図 03**: モデル\コンタクトマネージャーサービステスト.cs([フルサイズの画像を表示する をクリック](iteration-5-create-unit-tests-cs/_static/image6.png)します)

最初は、クラスによって公開される CreateContact() メソッドをテストします。 次の 5 つのテストを作成します。

- CreateContact() - 有効な連絡先がメソッドに渡されたときに、値 true が返されることをテストします。
- CreateContactRequiredFirstName() - 名前が欠落している取引先担当者が CreateContact() メソッドに渡されたときに、エラー メッセージがモデル状態に追加されることをテストします。
- CreateContactRequiredLastName() - 姓が欠落している連絡先が CreateContact() メソッドに渡されたときに、エラー メッセージがモデル状態に追加されることをテストします。
- CreateContactInvalidPhone() - 無効な電話番号を持つ連絡先が CreateContact() メソッドに渡されたときに、エラー メッセージがモデル状態に追加されることをテストします。
- CreateContactInvalidEmail() - 無効な電子メール アドレスを持つ連絡先が CreateContact() メソッドに渡されたときに、エラー メッセージがモデル状態に追加されることをテストします。

最初のテストでは、有効な連絡先が検証エラーを生成しないことを確認します。 残りのテストでは、各検証規則がチェックされます。

これらのテストのコードは、リスト 1 に含まれています。

**リスト 1 - モデル\コンタクトマネージャーサービステスト.cs**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

リスト 1 では Contact クラスを使用するため、テスト プロジェクトに Microsoft エンティティ フレームワークへの参照を追加する必要があります。 アセンブリへの参照を追加します。

リスト 1 には、[TestInitialize] 属性で修飾された Initialize() という名前のメソッドが含まれています。 このメソッドは、各単体テストが実行される前に自動的に呼び出されます (各単体テストの直前に 5 回呼び出されます)。 Initialize() メソッドは、次のコード行を使用してモックリポジトリを作成します。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

このコード行では、Moq フレームワークを使用して、IContactManagerRepository インターフェイスからモック リポジトリを生成します。 各単体テストの実行時にデータベースにアクセスしないように、実際の EntityContactManagerRepository の代わりにモック リポジトリが使用されます。 モック リポジトリは IContactManagerRepository インターフェイスのメソッドを実装していますが、メソッドは実際には何もしません。

> [!NOTE] 
> 
> Moq フレームワークを使用する場合、モックリポジトリと\_\_モックリポジトリオブジェクトの間には区別があります。 前者は、モック&lt;リポジトリの動作を指定&gt;するメソッドを含むモック IContactManagerRepository クラスを参照します。 後者は、IContactManager リポジトリ インターフェイスを実装する実際のモック リポジトリを指します。

モック リポジトリは、クラスのインスタンスを作成するときに Initialize() メソッドで使用されます。 個々の単体テストはすべて、このインスタンスを使用します。

リスト 1 には、各単体テストに対応する 5 つのメソッドが含まれています。 これらのメソッドは、[TestMethod] 属性で修飾されています。 単体テストを実行すると、この属性を持つメソッドが呼び出されます。 つまり、[TestMethod] 属性で修飾されたメソッドは単体テストです。

CreateContact() という名前の最初の単体テストは、呼び出し元 CreateContact() が、Contact クラスの有効なインスタンスがメソッドに渡されたときに true を返すことを確認します。 このテストでは、Contact クラスのインスタンスを作成し、CreateContact() メソッドを呼び出して、CreateContact() が true の値を返すかどうかを確認します。

残りのテストでは、CreateContact() メソッドが無効な Contact で呼び出されると、メソッドが false を返し、予期される検証エラー メッセージがモデル状態に追加されることを確認します。 たとえば、テストは、FirstName プロパティに空の文字列を持つ Contact クラスのインスタンスを作成します。 次に、メソッドが無効な連絡先を使用して呼び出されます。 最後に、テストは CreateContact() が false を返し、モデルの状態に予期される検証エラー メッセージ "名が必要です" が含まれていることを確認します。

リスト 1 で、メニュー オプションの **[テスト]、[実行]、[ソリューション内のすべてのテスト(Ctrl + R、A)]** を選択して単体テストを実行できます。 テストの結果は 、[テスト結果] ウィンドウに表示されます (図 4 参照)。

[![テスト結果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)

**図04**: テスト結果 ([フルサイズの画像を表示する をクリック](iteration-5-create-unit-tests-cs/_static/image8.png))

## <a name="creating-unit-tests-for-controllers"></a>コントローラーの単体テストの作成

ASP.NETMVC アプリケーションは、ユーザー操作のフローを制御します。 コントローラーをテストする際には、コントローラーが正しいアクション結果を返すかどうかをテストし、データを表示します。 また、コントローラーがモデル クラスと期待どおりに対話するかどうかをテストすることもできます。

たとえば、リスト 2 には、連絡先コントローラー Create() メソッドの 2 つの単体テストが含まれています。 最初の単体テストでは、有効な連絡先が Create() メソッドに渡されると Create() メソッドがインデックス アクションにリダイレクトされることを確認します。 つまり、有効な連絡先が渡されると、Create() メソッドはインデックス アクションを表す RedirectToRouteResult を返す必要があります。

コント ローラー層をテストするときに ContactManager サービス層をテストする必要はありません。 したがって、Initialize メソッドで次のコードを使用してサービス層をモックします。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

CreateValidContact() 単体テストでは、次のコード行を使用してサービス層 CreateContact() メソッドを呼び出す動作をモックします。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

このコード行により、モック ContactManager サービスは、その CreateContact() メソッドが呼び出されたときに true の値を返します。 サービス層を嘲笑することで、サービス層でコードを実行することなく、コントローラの動作をテストできます。

2 番目の単体テストでは、無効な連絡先がメソッドに渡されたときに Create() アクションが [作成] ビューを返すことを確認します。 サービス層 CreateContact() メソッドは、次のコード行で false の値を返します。

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

Create() メソッドが期待どおりに動作する場合、サービスレイヤーが値 false を返したときに Create ビューを返す必要があります。 このようにすると、コントローラーは検証エラー メッセージを Create ビューに表示でき、ユーザーはその無効な連絡先プロパティを修正できます。

コントローラーの単体テストをビルドする場合は、コントローラーアクションから明示的なビュー名を返す必要があります。 たとえば、次のようなビューを返しません。

ビュー()を返します。

代わりに、次のようなビューを返します。

ビューを返します("作成")。

ビューを返すときに明示的でない場合は、ViewResult.ViewName プロパティは空の文字列を返します。

**リスト 2 - コントローラー\コンタクトコントローラーテスト.cs**

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a>まとめ

このイテレーションでは、連絡先マネージャー アプリケーションの単体テストを作成しました。 これらの単体テストをいつでも実行して、アプリケーションが期待どおりの動作を行っていることを確認できます。 単体テストは、アプリケーションのセーフティ ネットとして機能し、将来的にアプリケーションを安全に変更できます。

2 組の単体テストを作成しました。 まず、サービス層の単体テストを作成して検証ロジックをテストしました。 次に、コントローラー層の単体テストを作成して、フロー制御ロジックをテストしました。 サービス層をテストする際、リポジトリレイヤーをモックすることで、サービス層のテストをリポジトリレイヤーから分離しました。 コントローラ層をテストする際、サービス層をモックすることで、コントローラ層のテストを分離しました。

次のイテレーションでは、連絡先マネージャー アプリケーションを変更して、連絡先グループをサポートするようにします。 テスト駆動開発と呼ばれるソフトウェア設計プロセスを使用して、この新機能をアプリケーションに追加します。

> [!div class="step-by-step"]
> [前へ](iteration-4-make-the-application-loosely-coupled-cs.md)
> [次へ](iteration-6-use-test-driven-development-cs.md)
