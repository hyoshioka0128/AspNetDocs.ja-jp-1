---
uid: mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-vb
title: 'イテレーション #6 – テスト駆動開発 (VB) を使用する |マイクロソフトドキュメント'
author: rick-anderson
description: この 6 回目のイテレーションでは、単体テストを最初に記述し、単体テストに対してコードを記述することで、アプリケーションに新しい機能を追加します。 このイテレーションでは,...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: e1fd226f-3f8e-4575-a179-5c75b240333d
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-6-use-test-driven-development-vb
msc.type: authoredcontent
ms.openlocfilehash: 8464f4cdee673ef75d561e4cf89613fdca2c16af
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542808"
---
# <a name="iteration-6--use-test-driven-development-vb"></a>繰り返し #6 – テスト駆動型開発を使用する (VB)

[マイクロソフト](https://github.com/microsoft)

[コードをダウンロード](iteration-6-use-test-driven-development-vb/_static/contactmanager_6_vb1.zip)

> この 6 回目のイテレーションでは、単体テストを最初に記述し、単体テストに対してコードを記述することで、アプリケーションに新しい機能を追加します。 このイテレーションでは、連絡先グループを追加します。

## <a name="building-a-contact-management-aspnet-mvc-application-vb"></a>MVC アプリケーション (VB) ASP.NET連絡先管理の構築

この一連のチュートリアルでは、最初から最後まで連絡先管理アプリケーション全体を構築します。 連絡先マネージャー アプリケーションでは、連絡先の情報 (名前、電話番号、電子メール アドレス) を保存できます。

複数のイテレーションでアプリケーションをビルドします。 各反復処理で、アプリケーションを徐々に改善します。 この複数の反復アプローチの目的は、各変更の理由を理解できるようにすることです。

- イテレーション #1 - アプリケーションを作成します。 最初のイテレーションでは、できるだけ簡単な方法で連絡先マネージャーを作成します。 基本的なデータベース操作のサポートを追加: 作成、読み取り、更新、および削除 (CRUD) 。

- イテレーション #2 - アプリケーションを見栄えよくします。 このイテレーションでは、既定の ASP.NET MVC ビュー マスター ページとカスケード スタイル シートを変更することで、アプリケーションの外観を向上させます。

- イテレーション #3 - フォームの検証を追加します。 3 回目のイテレーションでは、基本的なフォーム検証を追加します。 必須のフォームフィールドに入力せずにフォームを送信できないようにします。 また、メールアドレスと電話番号も検証します。

- イテレーション #4 - アプリケーションを疎結合にします。 この 4 回目のイテレーションでは、いくつかのソフトウェア設計パターンを利用して、Contact Manager アプリケーションの保守と変更を容易にします。 たとえば、リポジトリ パターンと依存関係の挿入パターンを使用するようにアプリケーションをリファクタリングします。

- イテレーション #5 - 単体テストを作成します。 5 回目のイテレーションでは、単体テストを追加することで、アプリケーションの保守と変更を容易にします。 データ モデル クラスをモックし、コントローラーと検証ロジックの単体テストをビルドします。

- イテレーション #6 - テスト駆動型開発を使用します。 この 6 回目のイテレーションでは、単体テストを最初に記述し、単体テストに対してコードを記述することで、アプリケーションに新しい機能を追加します。 このイテレーションでは、連絡先グループを追加します。

- イテレーション #7 - Ajax 機能を追加します。 7 回目のイテレーションでは、Ajax のサポートを追加することで、アプリケーションの応答性とパフォーマンスを向上させます。

## <a name="this-iteration"></a>このイテレーション

Contact Manager アプリケーションの以前のイテレーションでは、コードのセーフティ ネットを提供する単体テストを作成しました。 単体テストを作成する動機は、コードの変更に対する耐性を高めるためです。 単体テストを実施することで、コードを変更して、既存の機能が壊れているかどうかをすぐに確認できます。

このイテレーションでは、まったく異なる目的で単体テストを使用します。 このイテレーションでは、単体テストをアプリケーション設計の一部として使用*します*。 テスト駆動開発を実践する場合は、まずテストを記述してから、テストに対してコードを記述します。

より正確に言うと、テスト駆動開発を実践する場合、コードを作成する際に完了する手順は 3 つあります (赤/緑/リファクタリング)。

1. 失敗した単体テストを書く (赤)
2. 単体テストに合格するコードを記述する (緑)
3. コードのリファクタリング (リファクタリング)

まず、単体テストを記述します。 単体テストでは、コードの動作を想定する意図を表現する必要があります。 単体テストを初めて作成すると、単体テストは失敗します。 テストを満たすアプリケーション コードをまだ記述していないため、テストは失敗します。

次に、単体テストが成功するために十分なコードを記述します。 目標は、最も怠惰で、ずさんで、最速の方法でコードを書く方法です。 アプリケーションのアーキテクチャについて考える時間を無駄にしないでください。 代わりに、単体テストで表現される意図を満たすために必要な最小限のコードを記述することに重点を置く必要があります。

最後に、十分なコードを記述した後、一歩下がってアプリケーションの全体的なアーキテクチャを検討できます。 この手順では、リポジトリ パターンなどのソフトウェア設計パターンを利用してコードを書き直し (リファクタリング) して、コードの保守性を高めます。 コードは単体テストでカバーされるため、この手順でコードを書き直すことができます。

テスト駆動開発の実践には多くのメリットがあります。 まず、テスト駆動型の開発では、実際に記述する必要があるコードに集中する必要があります。 特定のテストに合格するのに十分なコードを記述することに常に重点を置いているため、雑草に迷い込んで、決して使用しない大量のコードを記述することはできなくなります。

次に、「テストファースト」設計方法論は、コードの使用方法の観点からコードを記述する必要があります。 つまり、テスト駆動型開発を実践する場合、ユーザーの視点から常にテストを記述しています。 したがって、テスト駆動型の開発により、よりクリーンで理解しやすい API が得られます。

最後に、テスト駆動型の開発では、アプリケーションを記述する通常のプロセスの一部として単体テストを記述する必要があります。 プロジェクトの期限が近づくと、テストは通常、ウィンドウの外に出る最初のものです。 一方、テスト駆動開発を実践する場合、単体テストの作成は、単体テストをアプリケーション構築プロセスの中心にするため、高潔な方が高い方がよいでしょう。

> [!NOTE] 
> 
> テスト駆動開発の詳細については、Michael Feathers の著書 **「レガシー コードを効果的に使用する**」を読むことをお勧めします。

このイテレーションでは、連絡先マネージャー アプリケーションに新しい機能を追加します。 連絡先グループのサポートを追加します。 連絡先グループを使用して、連絡先をビジネス グループや友商グループなどのカテゴリに分類できます。

テスト駆動型開発のプロセスに従って、この新しい機能をアプリケーションに追加します。 まず単体テストを記述し、これらのテストに対してすべてのコードを記述します。

## <a name="what-gets-tested"></a>テスト内容

前のイテレーションで説明したように、通常はデータ アクセス ロジックまたはビュー ロジックの単体テストを記述しません。 データベースへのアクセスは比較的低速な操作であるため、データ アクセス ロジックの単体テストは記述しません。 ビューにアクセスするには、比較的低速な操作である Web サーバーを作成する必要があるため、ビュー ロジックの単体テストは記述しません。 テストを何度も何度も繰り返し実行できない限り、単体テストを記述しないでください。

テスト駆動型開発は単体テストによって駆動されるため、最初はコントローラーとビジネス ロジックの記述に重点を置いています。 データベースやビューへのアクセスは避けます。 このチュートリアルの最後まで、データベースの変更やビューの作成は行いません。 まず、テストできることから始めます。

## <a name="creating-user-stories"></a>ユーザー ストーリーの作成

テスト駆動開発を実践する場合は、常にテストを書くことから始めます。 これはすぐに問題を提起します:どのように最初に書くテストを決めるのですか? この質問に答えるためには、[*ユーザー ストーリー*](http://en.wikipedia.org/wiki/User_stories)のセットを書く必要があります。

ユーザー ストーリーは、ソフトウェア要件の非常に簡潔な (通常は 1 つの文) 説明です。 これは、ユーザーの視点から書かれた要件の非技術的な説明である必要があります。

新しい連絡先グループ機能で必要な機能を説明するユーザー ストーリーのセットを次に示します。

1. ユーザーは連絡先グループの一覧を表示できます。
2. ユーザーは新しい連絡先グループを作成できます。
3. ユーザーは既存の連絡先グループを削除できます。
4. ユーザーは、新しい連絡先を作成するときに連絡先グループを選択できます。
5. 既存の連絡先を編集するときに、ユーザーは連絡先グループを選択できます。
6. 連絡先グループの一覧がインデックス ビューに表示されます。
7. ユーザーが連絡先グループをクリックすると、一致する連絡先の一覧が表示されます。

このユーザー ストーリーの一覧は、顧客が完全に理解できることに注意してください。 技術的な実装の詳細については言及していません。

アプリケーションの構築中に、ユーザー ストーリーのセットをより洗練することができます。 ユーザー ストーリーを複数のストーリー (要件) に分割する場合があります。 たとえば、新しい連絡先グループの作成には検証が必要であると判断できます。 名前を付けずに連絡先グループを送信すると、検証エラーが返されます。

ユーザー ストーリーのリストを作成したら、最初の単体テストを記述する準備が整いました。 まず、連絡先グループの一覧を表示するための単体テストを作成します。

## <a name="listing-contact-groups"></a>連絡先グループの一覧表示

最初のユーザー ストーリーは、ユーザーが連絡先グループの一覧を表示できる必要があります。 この話をテストで表現する必要があります。

ContactManager.Tests プロジェクトでコントローラー フォルダーを右クリックし、**追加、新しいテスト**を選択し、単体テスト テンプレートを選択して、新しい**単体テスト**を作成します (図 1 参照)。 新しい単体テストの名前を付け **、OK**ボタンをクリックします。

[![グループコントローラーテスト単体テストの追加](iteration-6-use-test-driven-development-vb/_static/image1.jpg)](iteration-6-use-test-driven-development-vb/_static/image1.png)

**図 01**: GroupControllerTest 単体テストの追加 ([フルサイズのイメージを表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image2.png))

最初の単体テストは、リスト 1 に含まれています。 このテストでは、グループ コントローラの Index() メソッドがグループのセットを返すかどうかを確認します。 テストでは、グループのコレクションがビュー データに返されることを確認します。

**リスト 1 - コントローラー\グループコントローラーテスト.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample1.vb)]

Visual Studio のリスト 1 に最初にコードを入力すると、赤い波線が多く表示されます。 グループコントローラまたはグループクラスは作成していません。

この時点では、最初の単体テストを実行できないように、アプリケーションを構築することさえできません。 それは良いことです。 これは失敗したテストとしてカウントされます。 したがって、アプリケーション コードの作成を開始する権限が与えられます。 テストを実行するのに十分なコードを記述する必要があります。

リスト 2 の Group コントローラー クラスには、単体テストに合格するために必要な最小限のコードが含まれています。 Index() アクションは、静的にコード化されたグループのリストを返します (グループクラスはリスト 3 で定義されています)。

**リスト 2 - コントローラ\グループコントローラ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample2.vb)]

**リスト 3 - モデル\グループ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample3.vb)]

プロジェクトに GroupController クラスとグループ クラスを追加すると、最初の単体テストが正常に完了します (図 2 参照)。 テストに合格するために必要な最低限の作業を行いました。 それはお祝いする時間です。

[![成功！](iteration-6-use-test-driven-development-vb/_static/image2.jpg)](iteration-6-use-test-driven-development-vb/_static/image3.png)

**図02**: 成功!([フルサイズの画像を表示するには クリック](iteration-6-use-test-driven-development-vb/_static/image4.png))

## <a name="creating-contact-groups"></a>連絡先グループの作成

これで、2 番目のユーザー ストーリーに移ります。 新しい連絡先グループを作成できる必要があります。 この意図をテストで表現する必要があります。

リスト 4 のテストでは、Create() メソッドを新しいグループで呼び出すと、Index() メソッドから返されたグループのリストにグループが追加されることを確認します。 つまり、新しいグループを作成すれば、Index() メソッドによって返されたグループのリストから新しいグループを取り戻すことができるはずです。

**リスト 4 - コントローラ\グループコントローラテスト.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample4.vb)]

リスト 4 のテストでは、新しい連絡先グループを使用してグループ コントローラー Create() メソッドを呼び出します。 次に、テストは、グループ コント ローラーの Index() メソッドを呼び出すと、ビュー データで新しいグループが返されることを確認します。

リスト 5 の変更されたグループ コントローラーには、新しいテストに合格するために必要な最小限の変更が含まれています。

**リスト 5 - コントローラ\グループコントローラ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample5.vb)]

## <a name="the-group-controller-in-listing-5-has-a-new-create-action-this-action-adds-a-group-to-a-collection-of-groups-notice-that-the-index-action-has-been-modified-to-return-the-contents-of-the-collection-of-groups"></a>リスト 5 のグループ コントローラには、新しい Create() アクションがあります。 このアクションにより、グループのコレクションにグループが追加されます。 グループのコレクションの内容を返すように、Index() アクションが変更されていることに注意してください。

もう一度、我々は、単体テストに合格するために必要な最低限の作業を実行しました。 グループ コントローラーにこれらの変更を加えた後、すべての単体テストに合格します。

## <a name="adding-validation"></a>検証の追加

この要件は、ユーザー ストーリーでは明示的に記述されていません。 ただし、グループに名前を付けることを要求することは合理的です。 そうしないと、連絡先をグループに整理することはあまり役に立ちません。

リスト 6 には、この意図を表現する新しいテストが含まれています。 このテストでは、名前を指定せずにグループを作成しようとすると、モデル状態の検証エラー メッセージが表示されることを確認します。

**リスト 6 - コントローラ\グループコントローラテスト.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample6.vb)]

このテストを満たすためには、グループクラスにNameプロパティを追加する必要があります(リスト7を参照)。 さらに、グループコントローラのCreate()アクションに検証ロジックを少し追加する必要があります(リスト8を参照)。

**リスト 7 - モデル\グループ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample7.vb)]

**リスト 8 - コントローラ\グループコントローラ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample8.vb)]

グループ コントローラー Create() アクションに検証とデータベース ロジックの両方が含まれていることに注意してください。 現在、グループ コントローラで使用されるデータベースは、メモリ内コレクションだけで構成されています。

## <a name="time-to-refactor"></a>リファクタリングまでの時間

赤/緑/リファクタリングの 3 番目のステップは、リファクタリングパーツです。 この時点で、コードから一歩下がって、アプリケーションをリファクタリングしてデザインを改善する方法を検討する必要があります。 リファクタリングステージは、ソフトウェア設計の原則とパターンを実装する最善の方法について一生懸命考える段階です。

コードの設計を改善するために選択した方法で、コードを自由に変更できます。 私たちは、既存の機能を壊すから私たちを防ぐユニットテストのセーフティネットを持っています。

今のところ、私たちのグループコントローラは、優れたソフトウェア設計の観点から混乱しています。 グループ コントローラには、検証とデータ アクセス コードが混乱しています。 単一責任原則に違反しないように、これらの懸念事項を異なるクラスに分ける必要があります。

リファクタリングされたグループ コントローラ クラスは、リスト 9 に含まれています。 コントローラーが、ContactManager サービス層を使用するように変更されました。 これは、連絡先コントローラーで使用するサービス層と同じです。

リスト 10 には、グループの検証、一覧表示、および作成をサポートするために ContactManager サービス層に追加された新しいメソッドが含まれています。 インターフェイスが更新され、新しいメソッドが含まれました。

リスト 11 には、IContactManager リポジトリ インターフェイスを実装する新しいフェイクコンタクトマネージャーリポジトリクラスが含まれています。 IContactManager リポジトリ インターフェイスも実装する EntityContactManager リポジトリ クラスとは異なり、新しいクラスはデータベースと通信しません。 クラスは、データベースのプロキシとしてメモリ内コレクションを使用します。 このクラスは、偽のリポジトリ レイヤーとして単体テストで使用します。

**リスト 9 - コントローラ\グループコントローラ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample9.vb)]

**リスト 10 - コントローラー\コンタクトマネージャーサービス.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample10.vb)]

**リスト 11 - コントローラー\フェイクコンタクトマネージャーリポジトリ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample11.vb)]

インターフェイスを変更するには、エンティティコンタクトマネージャーリポジトリクラスで CreateGroup() メソッドとリストグループ() メソッドを実装する必要があります。 これを行う最も怠惰で最速の方法は、次のようなスタブ メソッドを追加することです。

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample12.vb)]

最後に、アプリケーションの設計に対するこれらの変更では、単体テストに変更を加える必要があります。 これで、単体テストを実行するときに FakeContactManager リポジトリを使用する必要があります。 更新されたグループコントローラテストクラスは、リスト 12 に含まれています。

**リスト 12 - コントローラ\グループコントローラテスト.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample13.vb)]

これらの変更をすべて行った後、もう一度、すべての単体テストに合格します。 レッド/グリーン/リファクタリングの全サイクルを完了しました。 最初の 2 つのユーザー ストーリーを実装しました。 これで、ユーザー ストーリーで表現される要件に対するサポート単体テストが提供されました。 残りのユーザー ストーリーを実装するには、同じサイクルの赤/緑/リファクタリングを繰り返します。

## <a name="modifying-our-database"></a>データベースの変更

残念ながら、単体テストで表される要件をすべて満たしていますが、作業は完了していません。 データベースを変更する必要があります。

新しいグループ データベース テーブルを作成する必要があります。 次の手順に従います。

1. サーバー エクスプローラ ウィンドウで、[テーブル] フォルダを右クリックし、メニュー オプションの **[新しいテーブルの追加]** を選択します。
2. テーブル デザイナーで、次に説明する 2 つの列を入力します。
3. ID 列を主キーおよび ID 列としてマークします。
4. フロッピーのアイコンをクリックして、新しいテーブルを Groups という名前で保存します。

<a id="0.12_table01"></a>

| **列名** | **[データ型]** | **NULL を許可する** |
| --- | --- | --- |
| Id | INT | False |
| 名前 | nvarchar(50) | False |

次に、連絡先テーブルからすべてのデータを削除する必要があります (そうしないと、連絡先テーブルとグループ テーブル間のリレーションシップを作成できません)。 次の手順に従います。

1. [連絡先] テーブルを右クリックし、メニュー オプションの [**テーブル データの表示**] を選択します。
2. すべての行を削除します。

次に、グループ データベース テーブルと既存の連絡先データベース テーブルの間のリレーションシップを定義する必要があります。 次の手順に従います。

1. [サーバー エクスプローラー] ウィンドウで [連絡先] テーブルをダブルクリックして、テーブル デザイナーを開きます。
2. GroupId という名前の連絡先テーブルに新しい整数列を追加します。
3. [リレーションシップ] ボタンをクリックして 、[外部キー リレーションシップ] ダイアログを開きます (図 3 参照)。
4. [追加] ボタンをクリックします。
5. [テーブルと列の指定] ボタンの横に表示される省略記号ボタンをクリックします。
6. [テーブルと列] ダイアログで、[主キー テーブルとしてグループ] を選択し、主キー列として [ID] を選択します。 外部キー テーブルとして連絡先を選択し、外部キー列として GroupId を選択します (図 4 参照)。 [OK] ボタンをクリックします。
7. [**挿入および更新の指定]** で、[**削除ルール**] の値 **[カスケード**] を選択します。
8. [閉じる] ボタンをクリックして、[外部キーリレーションシップ] ダイアログを閉じます。
9. [保存] ボタンをクリックして、連絡先テーブルに変更を保存します。

[![データベース テーブル リレーションシップの作成](iteration-6-use-test-driven-development-vb/_static/image3.jpg)](iteration-6-use-test-driven-development-vb/_static/image5.png)

**図 03**: データベース テーブル リレーションシップを作成する ([フルサイズの画像を表示するには クリック](iteration-6-use-test-driven-development-vb/_static/image6.png))

[![テーブルのリレーションシップの指定](iteration-6-use-test-driven-development-vb/_static/image4.jpg)](iteration-6-use-test-driven-development-vb/_static/image7.png)

**図 04**: テーブルのリレーションシップを指定する ([フルサイズの画像を表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image8.png)します )

### <a name="updating-our-data-model"></a>データ モデルの更新

次に、新しいデータベース テーブルを表すためにデータ モデルを更新する必要があります。 次の手順に従います。

1. モデル フォルダーで ContactManagerModel.edmx ファイルをダブルクリックして、エンティティ デザイナーを開きます。
2. Designer 画面を右クリックし、メニューオプションの **[データベースからモデルを更新**] を選択します。
3. 更新ウィザードで、[グループ] テーブルを選択し、[完了] ボタンをクリックします (図 5 参照)。
4. Groups エンティティを右クリックし、メニュー オプションの **[名前の変更**] を選択します。 *グループ*エンティティの名前を*グループ*(単数) に変更します。
5. 連絡先エンティティの下部に表示される [グループ] ナビゲーション プロパティを右クリックします。 *グループ*ナビゲーション プロパティの名前を *[グループ*(単数)] に変更します。

[![データベースからのエンティティ フレームワーク モデルの更新](iteration-6-use-test-driven-development-vb/_static/image5.jpg)](iteration-6-use-test-driven-development-vb/_static/image9.png)

**図 05**: データベースから Entity Framework モデルを更新する ([フルサイズの画像を表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image10.png)して)

これらの手順を完了すると、データ モデルは連絡先テーブルとグループ テーブルの両方を表します。 エンティティ デザイナーには、両方のエンティティが表示されます (図 6 参照)。

[![グループと連絡先を表示するエンティティ デザイナー](iteration-6-use-test-driven-development-vb/_static/image6.jpg)](iteration-6-use-test-driven-development-vb/_static/image11.png)

**図 06**: グループと取引先担当者を表示するエンティティ デザイナー ([フルサイズの画像を表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image12.png)して )

### <a name="creating-our-repository-classes"></a>リポジトリクラスの作成

次に、リポジトリ クラスを実装する必要があります。 このイテレーションの過程で、単体テストを満たすコードを記述しながら、いくつかの新しいメソッドを IContactManagerRepository インターフェイスに追加しました。 IContactManager リポジトリ インターフェイスの最終バージョンは、リスト 14 に含まれています。

**リスト 14 - モデル\IContactManager リポジトリ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample14.vb)]

実際の EntityContactManagerRepository クラスでの連絡先グループの操作に関連するメソッドは実際には実装していません。 現在、クラスには、IContactManagerRepository インターフェイスに記載されている各連絡先グループ メソッドのスタブ メソッドがあります。 たとえば、ListGroups() メソッドは現在次のようになります。

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample15.vb)]

スタブ メソッドを使用して、アプリケーションをコンパイルして単体テストに合格することができました。 しかし、今ではこれらのメソッドを実際に実装する時が経ちます。 エンティティコンタクトマネージャーリポジトリクラスの最終バージョンは、リスト13に含まれています。

**リスト 13 - モデル\エンティティコンタクトマネージャーリポジトリ.vb**

[!code-vb[Main](iteration-6-use-test-driven-development-vb/samples/sample16.vb)]

### <a name="creating-the-views"></a>ビューの作成

既定のASP.NETビュー エンジンを使用する場合は、mvc アプリケーションをASP.NETします。 したがって、特定の単体テストに応答してビューを作成する必要はありません。 ただし、アプリケーションはビューなしでは役に立たないため、Contact Manager アプリケーションに含まれるビューを作成および変更せずに、このイテレーションを完了することはできません。

連絡先グループを管理するために、次の新しいビューを作成する必要があります (図 7 参照)。

- ビュー\グループ\Index.aspx - 連絡先グループの一覧を表示します。
- ビュー\グループ\削除.aspx - 連絡先グループを削除するための確認フォームを表示します。

[![グループインデックスビュー](iteration-6-use-test-driven-development-vb/_static/image7.jpg)](iteration-6-use-test-driven-development-vb/_static/image13.png)

**図 07**: グループインデックスビュー ([フルサイズの画像を表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image14.png))

連絡先グループを含むように、次の既存のビューを変更する必要があります。

- ビュー\ホーム\作成.aspx
- ビュー\ホーム\編集.aspx
- ビュー\ホーム\インデックス.aspx

このチュートリアルに付属する Visual Studio アプリケーションを見ると、変更されたビューを確認できます。 たとえば、図 8 は、連絡先インデックス ビューを示しています。

[![連絡先インデックスビュー](iteration-6-use-test-driven-development-vb/_static/image8.jpg)](iteration-6-use-test-driven-development-vb/_static/image15.png)

**図 08**: 連絡先インデックス ビュー ([フルサイズの画像を表示する をクリック](iteration-6-use-test-driven-development-vb/_static/image16.png)します)

## <a name="summary"></a>まとめ

このイテレーションでは、テスト駆動型開発アプリケーションの設計方法に従って、Contact Manager アプリケーションに新しい機能を追加しました。 まず、ユーザー ストーリーのセットを作成しました。 ユーザー ストーリーによって表される要件に対応する単体テストのセットを作成しました。 最後に、単体テストで表される要件を満たすだけのコードを記述しました。

単体テストで表される要件を満たすだけのコードを記述し終えたら、データベースとビューを更新しました。 新しいグループ テーブルをデータベースに追加し、エンティティ フレームワーク データ モデルを更新しました。 また、ビューのセットを作成および変更しました。

次のイテレーション (最終イテレーション) では、Ajax を利用するようにアプリケーションを書き直します。 Ajax を利用することで、Contact Manager アプリケーションの応答性とパフォーマンスを向上させます。

> [!div class="step-by-step"]
> [前へ](iteration-5-create-unit-tests-vb.md)
> [次へ](iteration-7-add-ajax-functionality-vb.md)
