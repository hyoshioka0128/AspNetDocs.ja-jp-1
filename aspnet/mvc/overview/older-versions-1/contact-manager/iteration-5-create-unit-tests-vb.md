---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-vb
title: 'イテレーション #5 –単体テストを作成する (VB) |Microsoft Docs'
author: microsoft
description: 5番目のイテレーションでは、単体テストを追加することによって、アプリケーションの保守と変更を容易にします。 私たちは、データモデルクラスを作成し、
ms.author: riande
ms.date: 02/20/2009
ms.assetid: c6e5c036-2265-4fa7-a9eb-47f197bdc262
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-vb
msc.type: authoredcontent
ms.openlocfilehash: 4ce1c6224a7e9203ff62f136f4f3a43e4561a904
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78437836"
---
# <a name="iteration-5--create-unit-tests-vb"></a>イテレーション #5 –単体テストを作成する (VB)

[Microsoft](https://github.com/microsoft)

[コードのダウンロード](iteration-5-create-unit-tests-vb/_static/contactmanager_5_vb1.zip)

> 5番目のイテレーションでは、単体テストを追加することによって、アプリケーションの保守と変更を容易にします。 データモデルクラスをモック化し、コントローラーと検証ロジックの単体テストをビルドします。

## <a name="building-a-contact-management-aspnet-mvc-application-vb"></a>Contact Management ASP.NET MVC アプリケーションの構築 (VB)

この一連のチュートリアルでは、最初から最後まで、連絡先管理アプリケーション全体を作成します。 連絡先マネージャーアプリケーションを使用すると、連絡先情報 (名前、電話番号、電子メールアドレスなど) をユーザーの一覧に格納できます。

複数のイテレーションに対してアプリケーションをビルドします。 各イテレーションで、アプリケーションを段階的に改善します。 この複数のイテレーションアプローチの目的は、各変更の理由を理解できるようにすることです。

- イテレーション #1-アプリケーションを作成します。 最初のイテレーションでは、最も簡単な方法で Contact Manager を作成します。 基本的なデータベース操作 (作成、読み取り、更新、削除) のサポートを追加します。

- イテレーション #2-アプリケーションの外観を良くします。 このイテレーションでは、既定の ASP.NET MVC ビューマスターページとカスケードスタイルシートを変更することによって、アプリケーションの外観を改善します。

- イテレーション #3-フォーム検証を追加します。 3番目のイテレーションでは、基本的なフォーム検証を追加します。 必要なフォームフィールドを完了しないで、フォームを送信できないようにします。 また、電子メールアドレスと電話番号も検証します。

- イテレーション #4-アプリケーションの疎結合を実現します。 この4回目のイテレーションでは、複数のソフトウェア設計パターンを利用して、連絡先マネージャーアプリケーションを簡単に管理および変更できるようにします。 たとえば、リポジトリパターンと依存関係の注入パターンを使用するようにアプリケーションをリファクターします。

- イテレーション #5-単体テストを作成します。 5番目のイテレーションでは、単体テストを追加することによって、アプリケーションの保守と変更を容易にします。 データモデルクラスをモック化し、コントローラーと検証ロジックの単体テストをビルドします。

- イテレーション #6-テスト駆動型開発を使用します。 この6番目のイテレーションでは、最初に単体テストを記述し、単体テストに対してコードを記述することによって、アプリケーションに新しい機能を追加します。 このイテレーションでは、連絡先グループを追加します。

- イテレーション #7-Ajax 機能を追加します。 7番目のイテレーションでは、Ajax のサポートを追加することによって、アプリケーションの応答性とパフォーマンスを向上させます。

## <a name="this-iteration"></a>このイテレーション

Contact Manager アプリケーションの前のイテレーションでは、アプリケーションが疎結合されるようにリファクタリングしています。 アプリケーションは、個別のコントローラー、サービス、およびリポジトリレイヤーに分離されています。 各レイヤーは、インターフェイスを介してその下のレイヤーと対話します。

アプリケーションを簡単に管理および変更できるように、アプリケーションをリファクタリングしました。 たとえば、新しいデータアクセステクノロジを使用する必要がある場合は、コントローラーやサービスレイヤーに触れることなくリポジトリレイヤーを変更するだけで済みます。 連絡先マネージャーを疎結合することにより、変更のためにアプリケーションの回復性を高めることができました。

しかし、Contact Manager アプリケーションに新しい機能を追加する必要がある場合はどうなるでしょうか。 バグを修正するとどうなりますか。 悲しいですが、コードを記述すると、コードを操作するたびに新しいバグが発生するリスクが生じます。

たとえば、上司から連絡担当者に新しい機能を追加するように要求される場合があります。 連絡先グループのサポートを追加したいと考えています。 彼女は、友人やビジネスなどのグループに連絡先を整理することをユーザーに許可したいと考えています。

この新機能を実装するには、Contact Manager アプリケーションの3つのレイヤーすべてを変更する必要があります。 コントローラー、サービス層、およびリポジトリに新しい機能を追加する必要があります。 コードの変更を開始するとすぐに、それまでに動作していた機能が中断する危険性があります。

前のイテレーションで行ったように、アプリケーションを別のレイヤーにリファクタリングすることは、良い方法でした。 アプリケーションの他の部分に触れることなく、レイヤー全体に変更を加えることができるため、これは良い方法でした。 ただし、レイヤー内のコードを保守および変更しやすいようにするには、コードの単体テストを作成する必要があります。

単体テストを使用して、個々のコード単位をテストします。 これらのコード単位は、アプリケーションレイヤー全体よりも小さくなります。 通常、単体テストを使用して、コード内の特定のメソッドが期待どおりに動作するかどうかを確認します。 たとえば、ContactManagerService クラスによって公開される CreateContact () メソッドの単体テストを作成します。

アプリケーションの単体テストは、安全性ネットワークと同様に動作します。 アプリケーションのコードを変更するたびに、一連の単体テストを実行して、変更によって既存の機能が破損していないかどうかを確認できます。 単体テストを使用すると、コードの変更を安全に行うことができます。 単体テストを使用すると、アプリケーション内のすべてのコードの変更に対する回復力を高めることができます。

このイテレーションでは、Contact Manager アプリケーションに単体テストを追加します。 このようにして、次のイテレーションでは、既存の機能の中断を気にせずに、連絡先グループをアプリケーションに追加できます。

> [!NOTE] 
> 
> NUnit、xUnit.net、MbUnit などのさまざまな単体テストフレームワークがあります。 このチュートリアルでは、Visual Studio に付属する単体テストフレームワークを使用します。 ただし、これらの代替フレームワークの1つを簡単に使用できます。

## <a name="what-gets-tested"></a>テスト対象

完全な世界では、すべてのコードが単体テストによってカバーされます。 最適な世界では、完全な安全性が確保されています。 アプリケーション内の任意のコード行を変更し、単体テストを実行することで、変更によって既存の機能が破損していないかどうかをすぐに知ることができます。

しかし、完璧な世界では生きていません。 実際には、単体テストを記述するときに、ビジネスロジックのテスト (検証ロジックなど) を記述することに専念します。 特に、データアクセスロジックまたはビューロジックの単体テストは記述し*ません*。

単体テストは非常に短時間で実行する必要があります。 アプリケーションに対して、数百 (または数千単位) の単体テストを簡単に蓄積できます。 単体テストの実行に時間がかかる場合は、単体テストを実行しないようにします。 つまり、実行時間の長い単体テストは、日常のコーディングのためには役に立ちません。

このため、通常は、データベースと対話するコードの単体テストを作成しません。 ライブデータベースに対して数百の単体テストを実行すると、時間がかかりすぎます。 代わりに、データベースをモックし、モックデータベースと対話するコードを記述します (以下のデータベースのモックについて説明します)。

同様の理由から、通常はビューの単体テストを作成しません。 ビューをテストするには、web サーバーを作成する必要があります。 Web サーバーをスピンアップするプロセスは比較的低速であるため、ビューの単体テストを作成することはお勧めできません。

ビューに複雑なロジックが含まれている場合は、ヘルパーメソッドにロジックを移行することを検討してください。 Web サーバーをスピンアップせずに実行するヘルパーメソッドの単体テストを作成できます。

> [!NOTE] 
> 
> 単体テストを作成する場合、データアクセスロジックまたはビューロジックのテストを記述することはお勧めできませんが、これらのテストは、機能テストまたは統合テストをビルドするときに非常に役立ちます。

> [!NOTE] 
> 
> ASP.NET MVC は Web フォームビューエンジンです。 Web フォームビューエンジンは web サーバーに依存しますが、他のビューエンジンは使用できません。

## <a name="using-a-mock-object-framework"></a>モックオブジェクトフレームワークの使用

単体テストをビルドする場合は、ほとんどの場合、モックオブジェクトフレームワークを利用する必要があります。 モックオブジェクトフレームワークを使用すると、アプリケーション内のクラスのモックとスタブを作成できます。

たとえば、モックオブジェクトフレームワークを使用して、リポジトリクラスのモックバージョンを生成できます。 これにより、単体テストで実際のリポジトリクラスではなく、モックリポジトリクラスを使用できます。 モックリポジトリを使用すると、単体テストの実行時にデータベースコードが実行されないようにすることができます。

Visual Studio には、モックオブジェクトフレームワークは含まれていません。 ただし、.NET framework には、いくつかの市販およびオープンソースのモックオブジェクトフレームワークが用意されています。

1. Moq-このフレームワークは、オープンソースの BSD ライセンスで利用できます。 Moq は[https://code.google.com/p/moq/](https://code.google.com/p/moq/)からダウンロードできます。
2. Rhino モック-このフレームワークは、オープンソースの BSD ライセンスで利用できます。 [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)から Rhino モックをダウンロードできます。
3. Typemock Isolator-これは商用フレームワークです。 [http://www.typemock.com/](http://www.typemock.com/)から試用版をダウンロードできます。

このチュートリアルでは、Moq を使用することにしました。 ただし、Rhino モックまたは Typemock Isolator を使用して、Contact Manager アプリケーションのモックオブジェクトを簡単に作成することもできます。

Moq を使用するには、次の手順を実行する必要があります。

1. 。
2. ダウンロードを解凍する前に、ファイルを右クリックし、 **[ブロック解除]** ボタン (図1を参照) をクリックしてください。
3. ダウンロードを解凍します。
4. メニューオプションプロジェクトを選択し **、[参照の追加**] をクリックして [参照の**追加**] ダイアログを開くことにより、moq アセンブリへの参照をテストプロジェクトに追加します。 [参照] タブで、Moq を解凍したフォルダーを参照し、Moq .dll アセンブリを選択します。 **[OK]** ボタンをクリックします (図2を参照)。

[ブロック解除 ![Moq](iteration-5-create-unit-tests-vb/_static/image1.jpg)](iteration-5-create-unit-tests-vb/_static/image1.png)

**図 01**: moq のブロック解除 ([クリックすると、フルサイズの画像が表示](iteration-5-create-unit-tests-vb/_static/image2.png)される)

[Moq を追加した後の参照の ![](iteration-5-create-unit-tests-vb/_static/image2.jpg)](iteration-5-create-unit-tests-vb/_static/image3.png)

**図 02**: moq を追加した後の参照 ([クリックすると、フルサイズの画像が表示](iteration-5-create-unit-tests-vb/_static/image4.png)される)

## <a name="creating-unit-tests-for-the-service-layer"></a>サービス層の単体テストの作成

まず、Contact Manager application s サービスレイヤーの一連の単体テストを作成します。 これらのテストを使用して、検証ロジックを検証します。

ContactManager. テストプロジェクトに、モデルという名前の新しいフォルダーを作成します。 次に、[モデル] フォルダーを右クリックし、[**追加]、[新しいテスト**] の順に選択します。 図3に示されている **[新しいテストの追加]** ダイアログボックスが表示されます。 **単体テスト**テンプレートを選択し、新しいテストに名前を指定します。 **[OK]** ボタンをクリックして、テストプロジェクトに新しいテストを追加します。

> [!NOTE] 
> 
> 通常、テストプロジェクトのフォルダー構造は、ASP.NET MVC プロジェクトのフォルダー構造と一致させる必要があります。 たとえば、コントローラーのテストを Controllers フォルダーに配置し、モデルフォルダー内のテストをモデル化します。

[![Model\ contactmanagerservicetest? cs](iteration-5-create-unit-tests-vb/_static/image3.jpg)](iteration-5-create-unit-tests-vb/_static/image5.png)

**図 03**: Model\ Contactmanagerservicetest/Cs ([クリックすると、フルサイズの画像が表示](iteration-5-create-unit-tests-vb/_static/image6.png)される)

最初に、ContactManagerService クラスによって公開されている CreateContact () メソッドをテストします。 次の5つのテストを作成します。

- CreateContact ()-有効な連絡先がメソッドに渡されたときに、CreateContact () が値 true を返すことをテストします。
- CreateContactRequiredFirstName ()-最初の名前が指定されていない連絡先が CreateContact () メソッドに渡されたときに、モデル状態にエラーメッセージが追加されることをテストします。
- CreateContactRequiredLastName ()-姓が指定されていない連絡先が CreateContact () メソッドに渡されたときに、モデル状態にエラーメッセージが追加されたことをテストします。
- CreateContactInvalidPhone ()-無効な電話番号を持つ連絡先が CreateContact () メソッドに渡されたときに、モデル状態にエラーメッセージが追加されたことをテストします。
- CreateContactInvalidEmail ()-無効な電子メールアドレスを持つ連絡先が CreateContact () メソッドに渡されたときに、モデル状態にエラーメッセージが追加されたことをテストします。

最初のテストでは、有効な連絡先が検証エラーを生成しないことを確認します。 残りのテストでは、各検証規則がチェックされます。

これらのテストのコードは、リスト1に含まれています。

**リスト 1-Model\ contactmanagerservicetest, vb**

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample1.vb)]

リスト1で Contact クラスを使用しているので、Microsoft Entity Framework への参照をテストプロジェクトに追加する必要があります。 System.string アセンブリへの参照を追加します。

リスト1には、[TestInitialize] 属性で修飾された Initialize () という名前のメソッドが含まれています。 このメソッドは、各単体テストの実行前に自動的に呼び出されます (各単体テストの直前に5回呼び出されます)。 Initialize () メソッドは、次のコード行を使用して、モックリポジトリを作成します。

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample2.vb)]

このコード行では、Moq フレームワークを使用して、IContactManagerRepository インターフェイスからモックリポジトリを生成します。 各単体テストの実行時にデータベースにアクセスしないように、実際の EntityContactManagerRepository の代わりにモックリポジトリが使用されます。 モックリポジトリは IContactManagerRepository インターフェイスのメソッドを実装しますが、メソッドは実際には何も行いません。

> [!NOTE] 
> 
> Moq フレームワークを使用する場合、\_mockRepository と \_mockRepository は区別されます。 前者は、モックリポジトリの動作方法を指定するメソッドを含む、モック (Of IContactManagerRepository) クラスを参照します。 後者は、IContactManagerRepository インターフェイスを実装する実際のモックリポジトリを参照します。

モックリポジトリは、ContactManagerService クラスのインスタンスを作成するときに Initialize () メソッドで使用されます。 個々の単体テストでは、ContactManagerService クラスのこのインスタンスが使用されます。

リスト1には、各単体テストに対応する5つのメソッドが含まれています。 これらの各メソッドは、[を持つ] 属性で修飾されています。 単体テストを実行すると、この属性を持つメソッドが呼び出されます。 言い換えると、[状態] 属性で修飾されたメソッドは単体テストです。

CreateContact () という名前の最初の単体テストでは、Contact クラスの有効なインスタンスがメソッドに渡されたときに、CreateContact () の呼び出しで値 true が返されることを確認します。 このテストでは、Contact クラスのインスタンスを作成し、CreateContact () メソッドを呼び出して、CreateContact () が値 true を返すことを確認します。

残りのテストでは、CreateContact () メソッドが無効な連絡先で呼び出されたときに、メソッドが false を返し、予期された検証エラーメッセージがモデルの状態に追加されていることを確認します。 たとえば、CreateContactRequiredFirstName () テストでは、FirstName プロパティの空の文字列を使用して Contact クラスのインスタンスが作成されます。 次に、無効な連絡先で CreateContact () メソッドが呼び出されます。 最後に、テストは CreateContact () が false を返すことを検証し、そのモデルの状態には "First name is required" というエラーメッセージが含まれていることを確認します。

リスト1の単体テストを実行するには、[**ソリューションのテスト]、[実行]、[すべてのテスト] (CTRL + R、A)** の順に選択します。 テストの結果が [テスト結果] ウィンドウに表示されます (図4を参照)。

[![テスト結果](iteration-5-create-unit-tests-vb/_static/image4.jpg)](iteration-5-create-unit-tests-vb/_static/image7.png)

**図 04**: テスト結果 ([クリックしてフルサイズのイメージを表示する](iteration-5-create-unit-tests-vb/_static/image8.png))

## <a name="creating-unit-tests-for-controllers"></a>コントローラーの単体テストの作成

ASP.NET MVC アプリケーションは、ユーザー操作のフローを制御します。 コントローラーをテストするときに、コントローラーが適切なアクションの結果を返し、データを表示するかどうかをテストします。 また、コントローラーが必要な方法でモデルクラスと対話するかどうかをテストすることもできます。

たとえば、リスト2には Contact controller Create () メソッドの2つの単体テストが含まれています。 最初の単体テストでは、有効な連絡先が Create () メソッドに渡されたときに、Create () メソッドによってインデックスアクションにリダイレクトされることを確認します。 つまり、有効な連絡先が渡された場合、Create () メソッドは、インデックスアクションを表す RedirectToRouteResult を返す必要があります。

コントローラーレイヤーをテストするときに、ContactManager サービスレイヤーをテストする必要はありません。 そのため、Initialize メソッドで次のコードを使用してサービスレイヤーをモックします。

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample3.vb)]

CreateValidContact () 単体テストでは、次のコード行を使用して、service layer CreateContact () メソッドを呼び出す動作をモック化します。

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample4.vb)]

このコード行により、CreateContact () メソッドが呼び出されたときに、モック ContactManager サービスによって値 true が返されます。 サービスレイヤーをモックすることで、サービスレイヤーでコードを実行しなくても、コントローラーの動作をテストできます。

2番目の単体テストでは、無効な連絡先がメソッドに渡されたときに create () アクションによって作成ビューが返されることを確認します。 次のコード行を使用して、service layer CreateContact () メソッドが値 false を返すようにします。

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample5.vb)]

Create () メソッドが期待どおりに動作する場合は、サービスレイヤーが false の値を返すと、Create view が返されます。 そうすることで、コントローラーは [作成] ビューに検証エラーメッセージを表示することができ、ユーザーは無効な連絡先プロパティを修正する機会を得られます。

コントローラーの単体テストをビルドする場合は、コントローラーアクションから明示的なビュー名を返す必要があります。 たとえば、次のようなビューを返さないでください。

返されるビュー ()

代わりに、次のようなビューを返します。

返されるビュー ("作成")

ビューを返すときに明示的でない場合、ViewName プロパティは空の文字列を返します。

**リスト 2-コントローラーの一覧表示**

[!code-vb[Main](iteration-5-create-unit-tests-vb/samples/sample6.vb)]

## <a name="summary"></a>まとめ

このイテレーションでは、Contact Manager アプリケーションの単体テストを作成しました。 これらの単体テストをいつでも実行して、アプリケーションが期待どおりに動作することを確認できます。 単体テストは、アプリケーションの安全性を確保するためのものとして機能し、今後、アプリケーションを安全に変更できるようにします。

2つの単体テストのセットを作成しました。 まず、サービスレイヤーの単体テストを作成して、検証ロジックをテストします。 次に、コントローラーレイヤーの単体テストを作成して、フロー制御ロジックをテストします。 サービスレイヤーをテストするときに、リポジトリレイヤーをモック化することで、microsoft のサービスレイヤーのテストをリポジトリレイヤーから分離しています。 コントローラーレイヤーをテストするときに、サービスレイヤーをモックすることによって、コントローラーレイヤーのテストを分離しています。

次のイテレーションでは、連絡先グループをサポートするように Contact Manager アプリケーションを変更します。 この新しい機能は、テスト駆動型開発と呼ばれるソフトウェア設計プロセスを使用して、アプリケーションに追加します。

> [!div class="step-by-step"]
> [前へ](iteration-4-make-the-application-loosely-coupled-vb.md)
> [次へ](iteration-6-use-test-driven-development-vb.md)
