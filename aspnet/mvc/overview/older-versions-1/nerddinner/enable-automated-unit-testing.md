---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: 自動単体テストの有効化 |Microsoft Docs
author: microsoft
description: 手順 12 では、NerdDinner 機能、ことを確認して、これにより、変更を加える信頼度に自動化された単体テストのスイートを開発する方法を示します.
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/06/2019
ms.locfileid: "65117353"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="ccaa5-103">自動化された単体テストを有効にする</span><span class="sxs-lookup"><span data-stu-id="ccaa5-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="ccaa5-104">によって[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="ccaa5-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="ccaa5-105">PDF のダウンロード</span><span class="sxs-lookup"><span data-stu-id="ccaa5-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="ccaa5-106">これは、無料の手順 12 ["NerdDinner"アプリケーションのチュートリアル](introducing-the-nerddinner-tutorial.md)をウォーク スルーの小さなをビルドしても、ASP.NET MVC 1 を使用して web アプリケーションを実行する方法。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="ccaa5-107">手順 12 では、一連の自動化された単体テスト、NerdDinner 機能を確認して、これにより、アプリケーションを今後の機能強化と変更できるという確信を開発する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="ccaa5-108">次のことをお勧め ASP.NET MVC 3 を使用している場合、 [MVC 3 の開始と取得](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md)または[MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md)チュートリアル。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="ccaa5-109">NerdDinner 手順 12:単体テスト</span><span class="sxs-lookup"><span data-stu-id="ccaa5-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="ccaa5-110">NerdDinner 機能、ことを確認して、これにより、アプリケーションを今後の機能強化と変更できるという確信に自動化された単体テストのスイートを開発しましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="ccaa5-111">なぜ単体テストのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-111">Why Unit Test?</span></span>

<span data-ttu-id="ccaa5-112">作業 1 つの朝にドライブ上で作業しているアプリケーションについてのヒントの突然のフラッシュがあります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="ccaa5-113">わかりますが、アプリケーションが大幅に向上する変更を実装することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="ccaa5-114">リファクタリング、コードのクリーンアップ、新しい機能を追加しますまたは、バグが修正される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="ccaa5-115">到着して、コンピューターからでお買い求め問題 –「安全な方法は、この機能強化にでしょうか。」</span><span class="sxs-lookup"><span data-stu-id="ccaa5-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="ccaa5-116">場合、変更を行った副作用を持っているか、何かを中断しますか。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="ccaa5-117">変更は、可能性がありますはシンプルなものを実装するには数分が時間のすべてのアプリケーション シナリオを手動でテストする場合のみ実行されますか。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="ccaa5-118">What-if シナリオをカバーするを忘れるし、壊れたアプリケーションが運用環境にしますか。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="ccaa5-119">すべての労力を費やす価値は本当にこの機能強化を行ってでしょうか。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="ccaa5-120">自動化された単体テストでは、継続的に、アプリケーションを拡張することができます、セーフティ ネットを提供できで作業しているコードを恐れてを回避することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="ccaa5-121">機能を使用すると、コードでは、信頼度 – とを支援することをする可能性がありますそれ以外の場合いないれたように感じている使いやすい機能強化を迅速に確認するテストを自動化することを実行します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="ccaa5-122">これらは、保守しやすくなりますがソリューションを作成し、投資収益率を大幅に上回っている潜在顧客の長い有効期間にも役立ちます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="ccaa5-123">ASP.NET MVC フレームワークを使用すると、簡単かつ自然に単体テスト アプリケーションの機能です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="ccaa5-124">また、テスト駆動開発 (TDD) のワークフロー ベースのテスト ファースト開発できるようにすることもできます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="ccaa5-125">NerdDinner.Tests Project</span><span class="sxs-lookup"><span data-stu-id="ccaa5-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="ccaa5-126">このチュートリアルの先頭に、NerdDinner アプリケーションを作成したときに私たちが表示されたアプリケーション プロジェクトと共に移動する単体テスト プロジェクトを作成したいかどうかを確認するダイアログ。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="ccaa5-127">「はい、単体テスト プロジェクトを作成する」ラジオ ボタンを選択: では、ソリューションに追加される"NerdDinner.Tests"プロジェクトに保存しました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="ccaa5-128">NerdDinner.Tests プロジェクトでは、NerdDinner アプリケーション プロジェクトのアセンブリを参照し、アプリケーションの機能を確認して自動テストを簡単に追加できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="ccaa5-129">Dinner モデル クラスの単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="ccaa5-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="ccaa5-130">NerdDinner.Tests プロジェクト Dinner クラスを構築した時点で、モデルのレイヤーを作成したことを確認するには、いくつかのテストを追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="ccaa5-131">まず、モデルに関連するテストを配置します"Models"というテスト プロジェクト内に新しいフォルダーを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="ccaa5-132">フォルダーを右クリックし、選択、**追加 -&gt;新しいテスト**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="ccaa5-133">「新しいテストの追加」ダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="ccaa5-134">「単体テスト」を作成し、"DinnerTest.cs"を名前を選択します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="ccaa5-135">"Ok"ボタンをクリックすると Visual Studio は追加 (とを開く) DinnerTest.cs ファイルをプロジェクト。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="ccaa5-136">既定の Visual Studio 単体テスト テンプレートが、一連のボイラー プレート コード内でこれを少し乱雑な検出します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="ccaa5-137">みましょうのクリーンアップを次のコードを含めるだけです。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="ccaa5-138">上記 DinnerTest クラス [TestClass] 属性は、テスト、および省略可能なテストの初期化と破棄コードを含むクラスとして識別されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="ccaa5-139">その中のテストに [TestMethod] 属性を持つパブリック メソッドを追加して定義できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="ccaa5-140">Dinner クラスを実行する 2 つのテストを追加の最初の数値を以下に示します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="ccaa5-141">最初のテストでは、Dinner が無効である新しい Dinner が正しく設定されているすべてのプロパティを指定せずに作成された場合を確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="ccaa5-142">2 番目のテストを夕食にすべてのプロパティを有効な値の設定がある場合、Dinner が有効であるかを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="ccaa5-143">わかります上、テスト名でが非常に明示的な (とやや面倒)。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="ccaa5-144">数百または何千もの小規模なテストを作成し終了し、(特に、テスト ランナーでのエラーの一覧を検索) 場合に、それぞれの動作と意図をすばやく判断しやすくために、これを行っています。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="ccaa5-145">テスト名は、テスト機能の後に名前必要があります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="ccaa5-146">使用している以上、"名詞\_する必要があります\_動詞"の名前付けパターン。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="ccaa5-147">"AAA"–「Arrange、Act、Assert」のパターンのテストを使用して、テスト構造化します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="ccaa5-148">配置します。テストする単体のセットアップ</span><span class="sxs-lookup"><span data-stu-id="ccaa5-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="ccaa5-149">Act:テスト対象の単位を実行して結果をキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="ccaa5-150">アサートします。動作を確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="ccaa5-151">記述する場合、個々 のテストを回避するテストが多すぎる行います。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="ccaa5-152">代わりに各テストは、(これはそれがより簡単にエラーの原因を特定) 1 つの概念のみを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="ccaa5-153">試して、アサート ステートメント テストごとに 1 つのみがあることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="ccaa5-154">1 つ以上のテスト メソッドでステートメントのアサートがある場合は、すべて使用されている同じ概念をテストするを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="ccaa5-155">確かでない場合は、別のテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="ccaa5-156">テストを実行しています</span><span class="sxs-lookup"><span data-stu-id="ccaa5-156">Running Tests</span></span>

<span data-ttu-id="ccaa5-157">Visual Studio 2008 Professional (および上位エディション)、IDE 内でプロジェクトを Visual Studio の単体テストの実行に使用できる組み込みのテスト ランナーが含まれます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="ccaa5-158">選択できる、**テスト -&gt;実行 -&gt;ソリューションのすべてのテスト**メニュー コマンド (または ctrl キーを R では、タイプ A) すべての単体テストを実行します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="ccaa5-159">または特定のテスト クラスまたはテスト メソッド内でカーソルを配置し、使用して別の方法として、**テスト -&gt;実行 -&gt;の現在のコンテキストのテスト**単体テストのサブセットを実行するメニュー コマンド (または ctrl キーを R では、T 型)。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="ccaa5-160">みましょう DinnerTest クラス内でカーソルを配置し、定義したテストの実行、2 つに"Ctrl R、T"を入力します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="ccaa5-161">Visual Studio 内でを実行するとこの"テスト結果 ウィンドウが表示され、内に表示されている実行、テストの結果を説明します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="ccaa5-162">*注:VS テストの結果ウィンドウでは、既定では、クラス名の列は表示されません。これは、テスト結果 ウィンドウ内で右クリックし、列の追加/削除 メニューのコマンドを使用して追加できます。*</span><span class="sxs-lookup"><span data-stu-id="ccaa5-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="ccaa5-163">2 つのテストでは、時間に実行して、できる限りの秒の端数のみ渡されるときの両方を参照してください。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="ccaa5-164">移動するようになりましたを特定のルールの検証を確認し、2 つのヘルパー メソッド - IsUserHost() と Dinner クラスに追加した IsUserRegistered() – をカバーするテストを作成してそれらを拡張できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="ccaa5-165">Dinner クラスのためにこれらすべてのテストを持つことによりより簡単かつ安全に、今後の新しいビジネス ルールと検証を追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="ccaa5-166">夕食に新しいルール ロジックを追加し、数秒で、以前のロジックの機能のいずれかが破損していないことすることを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="ccaa5-167">どのようにわかりやすいテスト名を使用して簡単に各テストの検証をすばやく理解に注意してください。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="ccaa5-168">使用することをお勧め、 **Tools -&gt;オプション**メニュー コマンドを開き、テスト ツール-&gt;テストの実行の構成画面で、チェック"ダブルクリックすると失敗したか結果が不確定の単体テストの結果が表示されます。テストの障害発生時点"のチェック ボックスをオンします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="ccaa5-169">これは、使用すると、テストの結果ウィンドウにエラーをダブルクリックし、アサート失敗にすぐにジャンプできます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="ccaa5-170">DinnersController の単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="ccaa5-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="ccaa5-171">DinnersController の機能を確認するいくつかの単体テストを今すぐ作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="ccaa5-172">テスト プロジェクト内の「コント ローラー」フォルダーを右クリックして開始し、いますが、**追加 -&gt;新しいテスト**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="ccaa5-173">「単体テスト」を作成し、"DinnersControllerTest.cs"という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="ccaa5-174">DinnersController Details() アクション メソッドを検証する 2 つのテスト メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="ccaa5-175">1 つ目は、既存の Dinner が要求されたときに、ビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="ccaa5-176">2 つ目は、"NotFound"のビューが存在しない Dinner が要求されたときに返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="ccaa5-177">上記のコードはクリーンにコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-177">The above code compiles clean.</span></span> <span data-ttu-id="ccaa5-178">テストを実行すると、どちらも失敗します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="ccaa5-179">エラー メッセージを見る場合、テストが失敗した理由が、DinnersRepository クラスがデータベースに接続できなかったためにのことを見ていきます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="ccaa5-180">NerdDinner アプリケーションが SQL Server Express のローカル ファイル、\App の下に存在する接続文字列を使用して\_NerdDinner アプリケーション プロジェクトのデータ ディレクトリ。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="ccaa5-181">NerdDinner.Tests プロジェクトがコンパイルし、アプリケーション プロジェクトの別のディレクトリで実行されるため、接続文字列の相対パスの場所が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="ccaa5-182">私たち*でした*テスト プロジェクトに、SQL Express のデータベース ファイルをコピーすることによってこの問題を解決し、テスト プロジェクトの app.config を適切なテスト接続文字列を追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="ccaa5-183">これは、ブロック解除され、実行されている、上記のテストを取得します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="ccaa5-184">実際のデータベースを使用してコードの単体テストが伴います。 さまざまな課題です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="ccaa5-185">具体的には、次のように使用します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-185">Specifically:</span></span>

- <span data-ttu-id="ccaa5-186">単体テストの実行時間を大幅に遅くなります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="ccaa5-187">頻繁に実行している可能性は低くなりますテストを実行する時間がかかります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="ccaa5-188">秒 – で実行されで行うものとして、プロジェクトのコンパイルと自然にすることがあることができるに単体テストをすることが理想的です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="ccaa5-189">テスト内でセットアップおよび後処理用のロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="ccaa5-190">(なし、副作用または依存関係) での他のユーザーから独立して分離するには、各単体テストを必要とします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="ccaa5-191">実際のデータベースに対して作業を行うときに状態に注意してくださいとテストの間のリセットが必要です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="ccaa5-192">これらの問題を回避し、テストで実際のデータベースを使用する必要性を回避に役立つ「注入」と呼ばれるデザイン パターンを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="ccaa5-193">依存関係の挿入</span><span class="sxs-lookup"><span data-stu-id="ccaa5-193">Dependency Injection</span></span>

<span data-ttu-id="ccaa5-194">今すぐ DinnersController は「に密結合」ときは必ず DinnerRepository クラス。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="ccaa5-195">「結合」は、クラスを明示的にクラスに依存別作業するために状態を表します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="ccaa5-196">ときは必ず DinnerRepository クラスには、データベースへのアクセスが必要であるため、密に結合された依存関係 DinnersController クラスに DinnersController のアクション メソッドをテストするためにデータベースを作成するを必要とするときは必ず DinnerRepository が終了します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="ccaa5-197">この問題を回避"依存関係の挿入"– これは、アプローチ (データ アクセスを提供するためのリポジトリ クラス) などの依存関係がそれらを使用するクラス内で不要になった暗黙的に作成される場所と呼ばれるデザイン パターンを採用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="ccaa5-198">代わりに、依存関係に明示的に渡せるそれらを使用するクラスのコンス トラクターの引数を使用します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="ccaa5-199">インターフェイスを使用して、依存関係を定義する場合し、単体テストのシナリオの「偽」依存関係の実装で渡す柔軟性があります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="ccaa5-200">これにより、データベースへのアクセスが実際に必要としないテスト固有の依存関係の実装を作成することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="ccaa5-201">これを実際に見る、DinnersController の依存関係の注入を実装してみましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="ccaa5-202">IDinnerRepository インターフェイスの抽出</span><span class="sxs-lookup"><span data-stu-id="ccaa5-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="ccaa5-203">取得および更新 Dinners、コント ローラーが必要とするリポジトリ コントラクトをカプセル化する新しい IDinnerRepository インターフェイスを作成する、最初のステップになります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="ccaa5-204">このインターフェイスのコントラクトを \Models フォルダーを右クリックし、選択し、手動で定義できます、**追加 -&gt;新しい項目の**メニュー コマンドと IDinnerRepository.cs という名前の新しいインターフェイスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="ccaa5-205">また、リファクタリング ツールの Visual Studio Professional に組み込まれて (および上位エディション) を自動的に抽出を使用して、、既存のときは必ず DinnerRepository クラスからのインターフェイスを作成できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="ccaa5-206">VS を使用したこのインターフェイスに抽出するためだけときは必ず DinnerRepository クラスで、テキスト エディターのカーソルを配置し、右クリックして選択、**リファクター -&gt;インターフェイスの抽出**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="ccaa5-207">"インターフェイスの抽出 ダイアログ ボックスを表示され、私たちを作成するインターフェイスの名前が要求されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="ccaa5-208">IDinnerRepository を既定のされ、既存のときは必ず DinnerRepository クラス、インターフェイスに追加するすべてのパブリック メソッドを自動的に選択します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="ccaa5-209">[Ok] ボタンをクリックして、ときに Visual Studio は、アプリケーションに新しい IDinnerRepository インターフェイスを追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="ccaa5-210">既存のときは必ず DinnerRepository クラスは、インターフェイスを実装できるように更新されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="ccaa5-211">コンス トラクターの挿入をサポートするために DinnersController の更新</span><span class="sxs-lookup"><span data-stu-id="ccaa5-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="ccaa5-212">DinnersController クラスの新しいインターフェイスを使用して今すぐ更新します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="ccaa5-213">現在 DinnersController はハード コーディングされた"ときは必ず dinnerRepository"フィールドがときは必ず DinnerRepository クラスでは常に。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="ccaa5-214">"ときは必ず dinnerRepository"フィールドが型ときは必ず DinnerRepository の代わりに IDinnerRepository ようにに変更します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="ccaa5-215">2 つの DinnersController コンス トラクターを公開し、追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="ccaa5-216">コンス トラクターの 1 つには、引数として渡される、IDinnerRepository が使用できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="ccaa5-217">もう 1 つは、既存のときは必ず DinnerRepository 実装を使用する既定のコンス トラクターです。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="ccaa5-218">既定では、ASP.NET MVC では、既定のコンス トラクターを使用して、コント ローラー クラスを作成するため、実行時に、DinnersController はデータ アクセスを実行するときは必ず DinnerRepository クラスを使用して続けます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="ccaa5-219">渡すパラメーターをコンス トラクターを使用して、「偽」dinner リポジトリの実装、しかし、単体テストを更新できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="ccaa5-220">この「偽」dinner リポジトリでは、実際のデータベースへのアクセスは必要ありませんし、代わりに、インメモリのサンプル データを使用します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="ccaa5-221">FakeDinnerRepository クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="ccaa5-222">FakeDinnerRepository クラスを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="ccaa5-223">NerdDinner.Tests プロジェクト内で「フェイク」ディレクトリを作成して開始されを新しい FakeDinnerRepository クラスを追加し、(フォルダーを右クリックし、選択**追加 -&gt;クラスの新しい**)。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="ccaa5-224">FakeDinnerRepository クラスが IDinnerRepository インターフェイスを実装するため、コードを更新します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="ccaa5-225">右クリックし、「実装インターフェイス IDinnerRepository」コンテキスト メニュー コマンドを使用すると、私たちできます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="ccaa5-226">これは、結果、Visual Studio で自動的に既定の「消去」の実装で、FakeDinnerRepository クラスすべて、IDinnerRepository インターフェイスのメンバーの追加。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="ccaa5-227">メモリ内のリストを使用する FakeDinnerRepository 実装を更新し&lt;Dinner&gt;をコンス トラクター引数として渡されたコレクション。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="ccaa5-228">データベースは必要ありません、Dinner オブジェクトのメモリ内のリストを使用できます代わりに IDinnerRepository 実装があるようになりました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="ccaa5-229">単体テストでの FakeDinnerRepository の使用</span><span class="sxs-lookup"><span data-stu-id="ccaa5-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="ccaa5-230">データベースを使用できなかったために、以前に失敗した DinnersController の単体テストに戻ってみましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="ccaa5-231">サンプル メモリ内 Dinner データは、次のコードを使用した DinnersController を読み込む FakeDinnerRepository を使用するテスト メソッドを更新することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="ccaa5-232">これらのテストを実行すると、両方を渡すようになりました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="ccaa5-233">何よりすばらしいは、実行するには 2 つ目の一部だけと任意の複雑なセットアップ/クリーンアップ ロジックは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="ccaa5-234">ここでは、実際のデータベースに接続することを必要とせずに単体テストすべて、DinnersController アクション メソッド コード (インクルード一覧については、ページング、詳細は、作成、更新、削除) のようになりましたことができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="ccaa5-235">**側のトピック:依存関係挿入フレームワーク**</span><span class="sxs-lookup"><span data-stu-id="ccaa5-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="ccaa5-236">正常に機能しますが、依存関係の数として維持が困難になりますが (上記います) などの手動による依存関係の挿入を実行して、アプリケーションのコンポーネントが増加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="ccaa5-237">さらに多くの依存関係管理の柔軟性を提供するのに役立つ .NET のいくつかの依存関係挿入フレームワークが存在します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="ccaa5-238">これらのフレームワークは、「制御の反転」(IoC) コンテナーとも呼ばを指定して、(最もよく使用コンス トラクターの挿入時のオブジェクトへの依存関係を渡すことの構成サポートの追加レベルを有効にするメカニズムを提供します。).</span><span class="sxs-lookup"><span data-stu-id="ccaa5-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="ccaa5-239">いくつかの人気の OSS 依存関係の挿入]、[.NET の IOC フレームワークが含まれます。AutoFac、Ninject、Spring.NET、StructureMap、Windsor します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="ccaa5-240">ASP.NET MVC の公開機能拡張 Api 開発者は、解像度と、コント ローラーのインスタンス化に参加できるようにして、依存関係の挿入を有効/IoC フレームワークは、このプロセス内で正常に統合します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="ccaa5-241">DI/IOC フレームワークを使用してから、DinnersController は – ときは、必ず DinnerRepository との間の結合を完全に削除すると、既定のコンス トラクターを削除することできます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="ccaa5-242">依存関係の挿入して/NerdDinner アプリケーションで IOC フレームワーク。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="ccaa5-243">NerdDinner コード ベースと機能が拡張された場合、今後のこともできます何か。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="ccaa5-244">編集アクションの単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="ccaa5-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="ccaa5-245">DinnersController の編集機能を確認するいくつかの単体テストを今すぐ作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="ccaa5-246">まず、テスト、編集の操作の HTTP GET バージョン。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="ccaa5-247">有効な dinner が要求されたときに、DinnerFormViewModel オブジェクトによってバックアップされたビューが表示されることを検証するテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="ccaa5-248">テストを実行すると、分かります Edit メソッド Dinner.IsHostedBy() チェックを実行する User.Identity.Name プロパティにアクセスするときに null 参照例外がスローされたために失敗しました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="ccaa5-249">コント ローラーの基本クラスのユーザー オブジェクトでは、ログイン ユーザーの詳細をカプセル化し、実行時に、コント ローラーを作成するときに、ASP.NET MVC によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="ccaa5-250">ユーザー オブジェクトが設定されていないため、DinnersController の web サーバー環境の外部では、テスト、(そのため、null 参照例外)。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="ccaa5-251">モック User.Identity.Name プロパティ</span><span class="sxs-lookup"><span data-stu-id="ccaa5-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="ccaa5-252">モック作成フレームワークでは、テストが簡単に有効にすると、テストをサポートする依存オブジェクトの偽のバージョンを動的に作成することを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="ccaa5-253">たとえば、シミュレートされたユーザー名の参照に使用できる、DinnersController ユーザー オブジェクトを動的に作成するのに、編集操作のテストでモック作成フレームワークを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="ccaa5-254">これにより、このテストを実行するとスローされるから null 参照が回避されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="ccaa5-255">モック フレームワーク ASP.NET MVC で使用できる多くの .NET がある (ここでその一覧を確認できます: [ http://www.mockframeworks.com/ ](http://www.mockframeworks.com/))。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="ccaa5-256">モック作成フレームワーク"Moq"と呼ばれるオープン ソース、使用、NerdDinner アプリケーションをテストするには、ダウンロードできる無料から[ http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="ccaa5-257">ダウンロードされると、Moq.dll アセンブリへの参照を NerdDinner.Tests プロジェクトに追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="ccaa5-258">"CreateDinnersControllerAs(username)"ヘルパー メソッドと、パラメーターとしてユーザー名を受け取りし、「モック」DinnersController のインスタンスで User.Identity.Name プロパティをテスト クラスに追加します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="ccaa5-259">上記は Moq 使用 (これは ASP.NET MVC がユーザー、要求、応答、およびセッションのようなランタイム オブジェクトを公開するのにコント ローラー クラスに渡します) ControllerContext オブジェクトの fakes モック オブジェクトを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="ccaa5-260">ControllerContext HttpContext.User.Identity.Name プロパティが、ヘルパー メソッドに渡されたユーザー名文字列を返すようにするモックで"SetupGet"メソッドの呼び出しいます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="ccaa5-261">ControllerContext プロパティとメソッドの任意の数をモックすることができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="ccaa5-262">これを説明するためにも SetupGet() Request.IsAuthenticated プロパティ (– 以下のテストを実際に必要なはありませんが、要求のプロパティを模擬表示する方法を説明することができます) の呼び出しを追加しました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="ccaa5-263">完了したときに、ヘルパー メソッドを返します DinnersController ControllerContext モックのインスタンスを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="ccaa5-264">このヘルパー メソッドを使用して、別のユーザーに関係する編集シナリオをテストする単体テストを記述できますようになりました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="ccaa5-265">テストを実行すると合格するようになりました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="ccaa5-266">UpdateModel() シナリオのテスト</span><span class="sxs-lookup"><span data-stu-id="ccaa5-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="ccaa5-267">編集の操作の HTTP GET バージョンをカバーしているテストを作成しました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="ccaa5-268">編集の操作の HTTP POST のバージョンを確認するいくつかのテストを今すぐ作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="ccaa5-269">このアクション メソッドをサポートするために私たちにとって興味深い新しいテスト シナリオでは、コント ローラーの基本クラスで UpdateModel() ヘルパー メソッドの使用です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="ccaa5-270">このヘルパー メソッドは、Dinner オブジェクト インスタンスにフォーム ポスト値のバインドを使用していますが。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="ccaa5-271">フォーム ポストされた UpdateModel() ヘルパー メソッドを使用する値の指定を示す 2 つのテストを以下に示します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="ccaa5-272">これは、作成して、FormCollection オブジェクトの作成がされ、コント ローラーの"ValueProvider"プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="ccaa5-273">最初のテストを正常に保存、ブラウザーがリダイレクトされるは、詳細のアクションを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="ccaa5-274">2 番目のテストは、無効な入力が投稿されたときにエラー メッセージでは、編集ビューをもう一度再アクションに表示されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="ccaa5-275">テストのまとめ</span><span class="sxs-lookup"><span data-stu-id="ccaa5-275">Testing Wrap-Up</span></span>

<span data-ttu-id="ccaa5-276">単体テスト コント ローラー クラスに関連する主要な概念を取り上げました。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="ccaa5-277">これらの手法を使用して、何百ものアプリケーションの動作を検証するための簡単なテストを簡単に作成することができます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="ccaa5-278">コント ローラーとモデルのテストでは、実際のデータベースは必要ありません、ため非常に高速で簡単に実行されます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="ccaa5-279">秒単位で何百もの自動テストを実行し、すぐに行った変更が何かを解約するかどうかに関するフィードバックを取得することが予定です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="ccaa5-280">これにより、継続的に向上させるため、リファクタリング、およびアプリケーションを調整できるという確信を提供できます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="ccaa5-281">テストについて説明しました – この章の最後のトピックとして何かがテストためではなく、開発プロセスの最後に行う必要がありますが、!</span><span class="sxs-lookup"><span data-stu-id="ccaa5-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="ccaa5-282">反対に、開発プロセスでできるだけ早く自動テストを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="ccaa5-283">そのため、これを使用すると、きれいにすぐにフィードバックを熟考のうえ、アプリケーションのユース ケース シナリオを考えてし、使用してアプリケーションを設計する方法を紹介する、ことができますも開発するときを重ねると、結合に注意してくださいできます。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="ccaa5-284">この書籍で以降の章は、テスト駆動開発 (TDD) と ASP.NET MVC で使用する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="ccaa5-285">TDD は、反復的なコーディング、テストされるため、結果として得られるコードを記述する場所。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="ccaa5-286">TDD を実装しようとしている機能を検証するテストを作成して各機能を開始します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="ccaa5-287">明確に理解して、機能と動作するはずですが方法はまず、テスト、ユニットを作成します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="ccaa5-288">テストが記述された (および失敗したことを確認した) 後にのみを実行しを検証する実際の機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="ccaa5-289">既に、この機能を活用する方法のユース ケースについて考える時間を費やしてきました、ため、要件の理解を深める必要が、それらを実装する最適な方法です。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="ccaa5-290">– テストを再実行され、迅速なフィードバックとしてを得られる実装が済んだらかどうか、機能が正しく動作します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="ccaa5-291">TDD より 10 章で説明します。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="ccaa5-292">次の手順</span><span class="sxs-lookup"><span data-stu-id="ccaa5-292">Next Step</span></span>

<span data-ttu-id="ccaa5-293">いくつかの最終的なコメントをラップします。</span><span class="sxs-lookup"><span data-stu-id="ccaa5-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="ccaa5-294">[前へ](use-ajax-to-implement-mapping-scenarios.md)
> [次へ](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="ccaa5-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
