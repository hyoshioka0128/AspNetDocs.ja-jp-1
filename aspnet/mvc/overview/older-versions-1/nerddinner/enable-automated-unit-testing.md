---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: 自動単体テストを有効にする |マイクロソフトドキュメント
author: rick-anderson
description: ステップ 12 は、NerdDinner 機能を検証する一連の自動単体テストを開発する方法を示しています。
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 7fe84efd9e4cc359c19d5ab9e22c579b80207e9c
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81541469"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="41865-103">自動化された単体テストを有効にする</span><span class="sxs-lookup"><span data-stu-id="41865-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="41865-104">[マイクロソフト](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="41865-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="41865-105">PDF のダウンロード</span><span class="sxs-lookup"><span data-stu-id="41865-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="41865-106">これは、mvc 1 を使用して小さいが完全な Web アプリケーションを構築する方法を説明する無料の["NerdDinner" アプリケーション チュートリアル](introducing-the-nerddinner-tutorial.md)の手順 12 ASP.NETです。</span><span class="sxs-lookup"><span data-stu-id="41865-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="41865-107">手順 12 は、NerdDinner の機能を検証する自動単体テストのスイートを開発する方法を示し、将来アプリケーションを変更および改善する自信を与えます。</span><span class="sxs-lookup"><span data-stu-id="41865-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="41865-108">mvc 3 ASP.NET使用している場合は、MVC 3 または[MVC ミュージック ストア](../../older-versions/mvc-music-store/mvc-music-store-part-1.md)[チュートリアルの概要に](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md)従うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="41865-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="41865-109">NerdDinner ステップ 12: 単体テスト</span><span class="sxs-lookup"><span data-stu-id="41865-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="41865-110">NerdDinnerの機能を検証し、将来アプリケーションを変更して改善する自信を与えてくれる自動単体テストのスイートを開発しましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="41865-111">なぜ単体テスト?</span><span class="sxs-lookup"><span data-stu-id="41865-111">Why Unit Test?</span></span>

<span data-ttu-id="41865-112">ある朝、仕事にドライブであなたが取り組んでいるアプリケーションについてのインスピレーションの突然のフラッシュがあります。</span><span class="sxs-lookup"><span data-stu-id="41865-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="41865-113">アプリケーションを劇的に改善する変更が実装できることが分かります。</span><span class="sxs-lookup"><span data-stu-id="41865-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="41865-114">コードをクリーンアップしたり、新しい機能を追加したり、バグを修正したりするリファクタリングである場合があります。</span><span class="sxs-lookup"><span data-stu-id="41865-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="41865-115">コンピュータに到着したときに直面する質問は、「この改善を行うことはどのくらい安全ですか?」</span><span class="sxs-lookup"><span data-stu-id="41865-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="41865-116">変更を行うことに副作用がある場合や何かを壊した場合はどうなりますか?</span><span class="sxs-lookup"><span data-stu-id="41865-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="41865-117">変更は簡単で、実装に数分しかかからず、すべてのアプリケーション シナリオを手動でテストするのに数時間かかる場合はどうでしょうか。</span><span class="sxs-lookup"><span data-stu-id="41865-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="41865-118">シナリオをカバーするのを忘れて、壊れたアプリケーションが実稼働に入った場合はどうなりますか?</span><span class="sxs-lookup"><span data-stu-id="41865-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="41865-119">この改善を行うことは本当にすべての努力の価値がありますか?</span><span class="sxs-lookup"><span data-stu-id="41865-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="41865-120">自動単体テストを使用すると、アプリケーションを継続的に強化し、作業中のコードを恐れないようにするセーフティ ネットを提供できます。</span><span class="sxs-lookup"><span data-stu-id="41865-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="41865-121">機能を迅速に検証する自動テストを実施することで、自信を持ってコーディングし、改善を行う力を与え、他の方法では快適に感じがなかった可能性があります。</span><span class="sxs-lookup"><span data-stu-id="41865-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="41865-122">彼らはまた、よりメンテナンスしやすく、寿命が長いソリューションを作成するのに役立ち、投資収益率がはるかに高くなります。</span><span class="sxs-lookup"><span data-stu-id="41865-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="41865-123">ASP.NET MVC フレームワークを使用すると、単体テスト アプリケーションの機能を簡単かつ自然に実行できます。</span><span class="sxs-lookup"><span data-stu-id="41865-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="41865-124">また、テストファーストベースの開発を可能にするテスト駆動開発 (TDD) ワークフローも可能になります。</span><span class="sxs-lookup"><span data-stu-id="41865-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="41865-125">オタクディナー.テストプロジェクト</span><span class="sxs-lookup"><span data-stu-id="41865-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="41865-126">このチュートリアルの最初に NerdDinner アプリケーションを作成すると、アプリケーション プロジェクトと一緒に作業する単体テスト プロジェクトを作成するかどうかを尋ねるダイアログ が表示されました。</span><span class="sxs-lookup"><span data-stu-id="41865-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="41865-127">"はい、単体テスト プロジェクトを作成します" オプション ボタンを選択した状態で、その結果、"NerdDinner.Tests" プロジェクトがソリューションに追加されました。</span><span class="sxs-lookup"><span data-stu-id="41865-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="41865-128">NerdDinner.Tests プロジェクトは NerdDinner アプリケーション プロジェクト アセンブリを参照し、アプリケーションの機能を検証する自動テストを簡単に追加できます。</span><span class="sxs-lookup"><span data-stu-id="41865-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="41865-129">Dinner モデル クラスの単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="41865-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="41865-130">モデルレイヤーを構築したときに作成した Dinner クラスを検証する NerdDinner.Tests プロジェクトにいくつかのテストを追加しましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="41865-131">まず、テスト プロジェクト内に新しいフォルダーを作成する "モデル" モデル関連のテストを配置します。</span><span class="sxs-lookup"><span data-stu-id="41865-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="41865-132">次に、フォルダーを右クリックし、[**新&gt;しいテストの追加**] メニュー コマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="41865-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="41865-133">これにより、[新しいテストの追加] ダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="41865-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="41865-134">「単体テスト」を作成し、「DinnerTest.cs」という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="41865-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="41865-135">「OK」ボタンをクリックすると、Visual Studio はプロジェクトにDinnerTest.csファイルを追加 (および開く) します。</span><span class="sxs-lookup"><span data-stu-id="41865-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="41865-136">既定の Visual Studio 単体テスト テンプレートには、その中にボイラー プレート コードがたくさん含まれています。</span><span class="sxs-lookup"><span data-stu-id="41865-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="41865-137">以下のコードを含むだけで、それをクリーンアップしてみましょう:</span><span class="sxs-lookup"><span data-stu-id="41865-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="41865-138">上記の DinnerTest クラスの [TestClass] 属性は、テストを含むクラスとして識別し、オプションのテスト初期化コードとティアダウン コードを含みます。</span><span class="sxs-lookup"><span data-stu-id="41865-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="41865-139">テスト内にテストを定義するには、テストに [TestMethod] 属性を持つパブリック メソッドを追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="41865-140">以下は、Dinnerクラスを追加する2つのテストのうちの最初のテストです。</span><span class="sxs-lookup"><span data-stu-id="41865-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="41865-141">最初のテストでは、すべてのプロパティが正しく設定されずに新しい Dinner が作成された場合、Dinner が無効であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="41865-142">2 番目のテストでは、Dinner に有効な値を持つすべてのプロパティが設定されている場合に、Dinner が有効であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="41865-143">上記のテスト名は非常に明示的です (やや冗長です)。</span><span class="sxs-lookup"><span data-stu-id="41865-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="41865-144">これは、何百、何千もの小さなテストを作成することになり、それぞれの意図と動作を簡単に特定できるようにするためです(特にテストランナーの失敗のリストを調べている場合)。</span><span class="sxs-lookup"><span data-stu-id="41865-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="41865-145">テスト名は、テストする機能の名前に付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="41865-146">上記では、「名詞\_は\_動詞」の命名パターンを使用しています。</span><span class="sxs-lookup"><span data-stu-id="41865-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="41865-147">「アヤア」テストパターンを使用してテストを構築しています。</span><span class="sxs-lookup"><span data-stu-id="41865-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="41865-148">配置: テスト対象のユニットをセットアップします。</span><span class="sxs-lookup"><span data-stu-id="41865-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="41865-149">行動:テスト対象のユニットを行使し、結果をキャプチャする</span><span class="sxs-lookup"><span data-stu-id="41865-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="41865-150">アサート: 動作を確認する</span><span class="sxs-lookup"><span data-stu-id="41865-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="41865-151">テストを書くとき、個々のテストがあまりにも多くのことを避けたいと思います。</span><span class="sxs-lookup"><span data-stu-id="41865-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="41865-152">代わりに、各テストでは単一の概念のみを検証する必要があります (これにより、失敗の原因を特定することがはるかに容易になります)。</span><span class="sxs-lookup"><span data-stu-id="41865-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="41865-153">良いガイドラインは、テストごとに 1 つのアサート ステートメントのみを実行することです。</span><span class="sxs-lookup"><span data-stu-id="41865-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="41865-154">テスト メソッドに複数の assert ステートメントがある場合は、すべてのステートメントが同じ概念をテストするために使用されていることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="41865-155">疑わしい場合は、別のテストを行います。</span><span class="sxs-lookup"><span data-stu-id="41865-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="41865-156">テストの実行</span><span class="sxs-lookup"><span data-stu-id="41865-156">Running Tests</span></span>

<span data-ttu-id="41865-157">Visual Studio 2008 プロフェッショナル (および上位エディション) には、IDE 内で Visual Studio 単体テスト プロジェクトを実行するために使用できる組み込みのテスト ランナーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="41865-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="41865-158">**[ソリューション内のすべての&gt;テスト&gt;**] メニュー コマンドを選択 (または Ctrl R、A と入力) して、すべての単体テストを実行できます。</span><span class="sxs-lookup"><span data-stu-id="41865-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="41865-159">または、特定のテストクラスまたはテストメソッド内にカーソルを配置し、[**現在のコンテキストでテスト&gt;-&gt;テスト- テスト**]メニューコマンドを使用して(またはCtrl R、Tを入力)単体テストのサブセットを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="41865-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="41865-160">DinnerTest クラス内にカーソルを置き、"Ctrl R, T" と入力して、定義した 2 つのテストを実行してみましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="41865-161">これを行うと、Visual Studio 内に "テスト結果" ウィンドウが表示され、テストの実行結果が表示されます。</span><span class="sxs-lookup"><span data-stu-id="41865-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="41865-162">*注: VS テスト結果ウィンドウには、既定では [クラス名] 列は表示されません。これを追加するには、[テスト結果] ウィンドウ内を右クリックし、[列の追加と削除] メニュー コマンドを使用します。*</span><span class="sxs-lookup"><span data-stu-id="41865-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="41865-163">2 つのテストは、実行に要する秒数のほんの一部に過ぎません。</span><span class="sxs-lookup"><span data-stu-id="41865-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="41865-164">ここでは、特定のルール検証を検証する追加のテストを作成し、Dinner クラスに追加した 2 つのヘルパー メソッドである IsUserHost() と IsUserRegistered() を取り上げ、それらを拡張できます。</span><span class="sxs-lookup"><span data-stu-id="41865-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="41865-165">Dinner クラスに対してこれらのすべてのテストを実施すると、将来、新しいビジネス ルールと検証を追加する方がはるかに簡単で安全になります。</span><span class="sxs-lookup"><span data-stu-id="41865-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="41865-166">Dinner に新しいルール ロジックを追加し、数秒以内に以前のロジック機能が破損していないことを確認できます。</span><span class="sxs-lookup"><span data-stu-id="41865-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="41865-167">説明的なテスト名を使用すると、各テストで確認されている内容をすばやく理解しやすくなります。</span><span class="sxs-lookup"><span data-stu-id="41865-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="41865-168">**[ツール]&gt;メニュー**の [オプション] メニューコマンドを使用して、[テスト ツール -&gt;テスト実行] 構成画面を開き、[失敗した単体テスト結果または決定的な単体テストの結果をダブルクリックすると、テストの失敗点が表示される] チェック ボックスをオンにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="41865-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="41865-169">これにより、テスト結果ウィンドウで失敗をダブルクリックし、アサートの失敗にすぐにジャンプすることができます。</span><span class="sxs-lookup"><span data-stu-id="41865-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="41865-170">ディナーコントローラ単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="41865-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="41865-171">ここで、DinnersController の機能を検証する単体テストをいくつか作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="41865-172">まず、テスト プロジェクト内の "コントローラー" フォルダーを右クリックし、[**新&gt;しいテストの追加**] メニュー コマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="41865-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="41865-173">「単体テスト」を作成し、"DinnersControllerTest.cs"という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="41865-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="41865-174">DinnersController で Details() アクション メソッドを検証する 2 つのテスト メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="41865-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="41865-175">最初の方法では、既存の Dinner が要求されたときにビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="41865-176">2 つ目は、存在しない Dinner が要求されたときに "NotFound" ビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="41865-177">上記のコードはクリーンコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="41865-177">The above code compiles clean.</span></span> <span data-ttu-id="41865-178">ただし、テストを実行すると、両方とも失敗します。</span><span class="sxs-lookup"><span data-stu-id="41865-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="41865-179">エラー メッセージを見ると、DinnersRepository クラスがデータベースに接続できなかったため、テストが失敗した理由がわかります。</span><span class="sxs-lookup"><span data-stu-id="41865-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="41865-180">NerdDinner アプリケーションは、NerdDinner アプリケーション プロジェクトの \App\_データ ディレクトリの下に存在するローカル SQL Server Express ファイルへの接続文字列を使用しています。</span><span class="sxs-lookup"><span data-stu-id="41865-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="41865-181">NerdDinner.Tests プロジェクトは、アプリケーション プロジェクトの次に別のディレクトリでコンパイルおよび実行されるため、接続文字列の相対パスの場所が正しくありません。</span><span class="sxs-lookup"><span data-stu-id="41865-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="41865-182">この問題*を修正するには、SQL* Express データベース ファイルをテスト プロジェクトにコピーし、テスト プロジェクトの App.config に適切なテスト接続文字列を追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="41865-183">これにより、上記のテストのブロック解除と実行が行われます。</span><span class="sxs-lookup"><span data-stu-id="41865-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="41865-184">しかし、実際のデータベースを使用してコードを単体テストすると、多くの課題が伴います。</span><span class="sxs-lookup"><span data-stu-id="41865-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="41865-185">具体的な内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="41865-185">Specifically:</span></span>

- <span data-ttu-id="41865-186">単体テストの実行時間が大幅に遅くなります。</span><span class="sxs-lookup"><span data-stu-id="41865-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="41865-187">テストの実行にかかる時間が長いほど、頻繁にテストを実行する可能性は低くなります。</span><span class="sxs-lookup"><span data-stu-id="41865-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="41865-188">理想的には、単体テストを数秒で実行し、プロジェクトのコンパイルと同じくらい自然に行うようにします。</span><span class="sxs-lookup"><span data-stu-id="41865-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="41865-189">テスト内のセットアップとクリーンアップのロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="41865-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="41865-190">各単体テストを分離し、他の単体テストに依存しない (副作用や依存関係がない) 必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="41865-191">実際のデータベースに対して作業するときは、状態に注意し、テストの間にリセットする必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="41865-192">これらの問題を回避し、テストで実際のデータベースを使用する必要を回避するのに役立つ"依存関係の注入"と呼ばれるデザイン パターンを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="41865-193">依存関係の挿入</span><span class="sxs-lookup"><span data-stu-id="41865-193">Dependency Injection</span></span>

<span data-ttu-id="41865-194">今、ディナーコントローラは、ディナーリポジトリクラスにしっかりと「結合」されています。</span><span class="sxs-lookup"><span data-stu-id="41865-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="41865-195">「結合」とは、クラスが明示的に別のクラスに依存して動作する状況を指します。</span><span class="sxs-lookup"><span data-stu-id="41865-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="41865-196">DinnerRepository クラスはデータベースへのアクセスを必要とするため、DinnersController クラスが DinnersController に対して持つ緊密に結合された依存関係は、DinnersController アクション メソッドをテストするためにデータベースを持つ必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="41865-197">この問題を回避するには、"依存関係の注入" というデザイン パターンを使用して、依存関係 (データ アクセスを提供するリポジトリ クラスなど) が、それらを使用するクラス内で暗黙的に作成されなくなるアプローチです。</span><span class="sxs-lookup"><span data-stu-id="41865-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="41865-198">代わりに、コンストラクター引数を使用して、依存関係を使用するクラスに明示的に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="41865-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="41865-199">依存関係がインターフェイスを使用して定義されている場合、単体テスト シナリオの "fake" 依存関係実装を柔軟に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="41865-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="41865-200">これにより、実際にはデータベースへのアクセスを必要としないテスト固有の依存関係の実装を作成できます。</span><span class="sxs-lookup"><span data-stu-id="41865-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="41865-201">この動作を確認するには、DinnersController で依存関係の注入を実装してみましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="41865-202">IDinner リポジトリ インターフェイスの抽出</span><span class="sxs-lookup"><span data-stu-id="41865-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="41865-203">最初の手順は、私たちのコントローラが Dinners を取得して更新するために必要なリポジトリ コントラクトをカプセル化する新しい IDinnerRepository インターフェイスを作成することです。</span><span class="sxs-lookup"><span data-stu-id="41865-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="41865-204">このインターフェイス コントラクトを手動で定義するには、\Models フォルダーを右クリックし、[**追加 -&gt;新しい項目]** メニュー コマンドを選択し、IDinnerRepository.csという名前の新しいインターフェイスを作成します。</span><span class="sxs-lookup"><span data-stu-id="41865-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="41865-205">または、Visual Studio Professional (および上位エディション) に組み込まれているリファクタリング ツールを使用して、既存の DinnerRepository クラスからインターフェイスを自動的に抽出して作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="41865-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="41865-206">VS を使用してこのインターフェイスを抽出するには、DinnerRepository クラスのテキスト エディターにカーソルを置いて右クリックし、**リファクタリング&gt;- インターフェイスの抽出**メニュー コマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="41865-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="41865-207">これにより、「インターフェイスの抽出」ダイアログが起動し、作成するインタフェースの名前を入力するよう促されます。</span><span class="sxs-lookup"><span data-stu-id="41865-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="41865-208">これは、IDinnerRepository にデフォルト設定され、インターフェイスに追加する既存の DinnerRepository クラスのすべてのパブリック メソッドを自動的に選択します。</span><span class="sxs-lookup"><span data-stu-id="41865-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="41865-209">"OK" ボタンをクリックすると、Visual Studio は新しい IDinnerRepository インターフェイスをアプリケーションに追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="41865-210">既存の DinnerRepository クラスが、インターフェイスを実装するように更新されます。</span><span class="sxs-lookup"><span data-stu-id="41865-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="41865-211">コンストラクタの注入をサポートするために DinnersController を更新しています</span><span class="sxs-lookup"><span data-stu-id="41865-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="41865-212">新しいインターフェイスを使用するように DinnersController クラスを更新します。</span><span class="sxs-lookup"><span data-stu-id="41865-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="41865-213">現在、DinnersController は、"dinnerRepository" フィールドが常に DinnerRepository クラスになるようにハードコーディングされています。</span><span class="sxs-lookup"><span data-stu-id="41865-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="41865-214">"dinnerRepository" フィールドが Dinner リポジトリではなく IDinnerRepository 型になるように変更します。</span><span class="sxs-lookup"><span data-stu-id="41865-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="41865-215">次に、2 つのパブリック DinnersController コンストラクターを追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="41865-216">コンストラクタの 1 つを使用すると、引数として IDinnerRepository を渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="41865-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="41865-217">もう 1 つは、既存の DinnerRepository 実装を使用する既定のコンストラクターです。</span><span class="sxs-lookup"><span data-stu-id="41865-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="41865-218">既定では、既定ASP.NET MVC は既定のコンストラクターを使用してコントローラー クラスを作成するため、実行時に DinnersController は DinnerRepository クラスを使用してデータ アクセスを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="41865-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="41865-219">しかし、パラメータコンストラクタを使用して「偽の」ディナーリポジトリの実装に合格するように、単体テストを更新できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="41865-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="41865-220">この"fake"dinnerリポジトリは、実際のデータベースへのアクセスを必要とせず、代わりにインメモリサンプルデータを使用します。</span><span class="sxs-lookup"><span data-stu-id="41865-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="41865-221">クラスを作成する</span><span class="sxs-lookup"><span data-stu-id="41865-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="41865-222">クラスを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="41865-223">まず、NerdDinner.Tests プロジェクト内に 「Fakes」ディレクトリを作成し、そのディレクトリに新しい FakeDinnerRepository クラスを追加します (フォルダーを右クリックして **[Add-&gt;New Class]** を選択します)。</span><span class="sxs-lookup"><span data-stu-id="41865-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="41865-224">コードを更新して、FakeDinnerRepository クラスが IDinnerRepository インターフェイスを実装するようにします。</span><span class="sxs-lookup"><span data-stu-id="41865-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="41865-225">その後、それを右クリックして、コンテキストメニューコマンド「インターフェイスIDinnerRepositoryを実装する」を選択することができます。</span><span class="sxs-lookup"><span data-stu-id="41865-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="41865-226">これにより、Visual Studio は、既定の "スタブ アウト" 実装を使用して、すべての IDinnerRepository インターフェイス メンバーを FakeDinnerRepository クラスに自動的に追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="41865-227">その後、FakeDinnerRepository の実装を更新して、コンストラクタ引数として渡された&lt;メモリ&gt;内リストディナーコレクションをオフにします。</span><span class="sxs-lookup"><span data-stu-id="41865-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="41865-228">これで、データベースを必要とせず、代わりに Dinner オブジェクトのメモリ内リストを処理できる偽の IDinnerRepository 実装が用意されています。</span><span class="sxs-lookup"><span data-stu-id="41865-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="41865-229">単体テストでのフェイクディナーリポジトリの使用</span><span class="sxs-lookup"><span data-stu-id="41865-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="41865-230">データベースが使用できなかったために、以前に失敗した DinnersController 単体テストに戻りましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="41865-231">以下のコードを使用して、サンプルのメモリ内のディナー データが入力された FakeDinnerRepository を DinnersController に使用するようにテスト メソッドを更新できます。</span><span class="sxs-lookup"><span data-stu-id="41865-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="41865-232">そして今、これらのテストを実行すると、両方とも合格します。</span><span class="sxs-lookup"><span data-stu-id="41865-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="41865-233">何よりも、実行にほんの数秒しかかからず、複雑なセットアップ/クリーンアップロジックは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="41865-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="41865-234">実際のデータベースに接続しなくても、DinnersController アクション メソッド のコード (リスト、ページング、詳細、作成、更新、削除など) をすべて単体テストできるようになりました。</span><span class="sxs-lookup"><span data-stu-id="41865-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="41865-235">**サイドトピック: 依存関係の注入フレームワーク**</span><span class="sxs-lookup"><span data-stu-id="41865-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="41865-236">手動依存性注入 (上記のように) の実行は正常に動作しますが、アプリケーション内の依存関係とコンポーネントの数が増えると、保守が困難になります。</span><span class="sxs-lookup"><span data-stu-id="41865-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="41865-237">.NET には、依存関係管理の柔軟性をさらに高めるいくつかの依存関係挿入フレームワークが存在します。</span><span class="sxs-lookup"><span data-stu-id="41865-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="41865-238">これらのフレームワークは、"制御の反転" (IoC) コンテナーとも呼ばれ、実行時にオブジェクトに依存関係を指定および渡すための追加のレベルの構成サポートを可能にするメカニズムを提供します (ほとんどの場合、コンストラクターの挿入を使用)。</span><span class="sxs-lookup"><span data-stu-id="41865-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="41865-239">NET で最も人気のある OSS 依存性の注入/ IOC フレームワークの一部: AutoFac、 Ninject、 Spring.NET、構造マップ、ウィンザー。</span><span class="sxs-lookup"><span data-stu-id="41865-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="41865-240">ASP.NET MVC は、開発者がコントローラの解決とインスタンス化に参加できるようにする機能拡張 API を公開し、このプロセス内で依存関係の挿入 /IoC フレームワークをクリーンに統合できるようにします。</span><span class="sxs-lookup"><span data-stu-id="41865-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="41865-241">DI/IOC フレームワークを使用すると、DinnersController から既定のコンストラクタを削除することもできます。</span><span class="sxs-lookup"><span data-stu-id="41865-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="41865-242">NerdDinner アプリケーションでは、依存関係の挿入/IOC フレームワークを使用しません。</span><span class="sxs-lookup"><span data-stu-id="41865-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="41865-243">しかし、NerdDinnerのコードベースと機能が成長した場合、将来のために考慮できるものです。</span><span class="sxs-lookup"><span data-stu-id="41865-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="41865-244">編集アクション単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="41865-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="41865-245">次に、DinnersController の編集機能を検証する単体テストをいくつか作成します。</span><span class="sxs-lookup"><span data-stu-id="41865-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="41865-246">まず、編集アクションの HTTP-GET バージョンをテストします。</span><span class="sxs-lookup"><span data-stu-id="41865-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="41865-247">有効なディナーが要求されたときに、DinnerFormViewModel オブジェクトによってバックアップされたビューがレンダリングされることを確認するテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="41865-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="41865-248">ただし、テストを実行すると、Edit メソッドが dinner.IsHostedBy() チェックを実行するために User.Identity.Name プロパティにアクセスしたときに null 参照例外がスローされるため、テストが失敗することがわかります。</span><span class="sxs-lookup"><span data-stu-id="41865-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="41865-249">コント ローラーの基本クラスの User オブジェクトは、ログインしているユーザーに関する詳細をカプセル化し、実行時にコントローラーを作成するときにASP.NET MVC によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="41865-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="41865-250">Web サーバー環境の外部で DinnersController をテストしているため、User オブジェクトが設定されていません (したがって、null 参照例外)。</span><span class="sxs-lookup"><span data-stu-id="41865-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="41865-251">User.Identity.Nameプロパティのモック</span><span class="sxs-lookup"><span data-stu-id="41865-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="41865-252">モック フレームワークは、テストをサポートする依存オブジェクトの偽のバージョンを動的に作成できるようにすることで、テストを容易にします。</span><span class="sxs-lookup"><span data-stu-id="41865-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="41865-253">たとえば、Edit アクション テストでモック フレームワークを使用して、DinnersController がシミュレートされたユーザー名を検索するために使用できるユーザー オブジェクトを動的に作成できます。</span><span class="sxs-lookup"><span data-stu-id="41865-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="41865-254">これにより、テストを実行するときに null 参照がスローされるのを回避できます。</span><span class="sxs-lookup"><span data-stu-id="41865-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="41865-255">ASP.NET MVC で使用できる .NET モック フレームワークはたくさんあります (ここでは、その一覧を参照[http://www.mockframeworks.com/](http://www.mockframeworks.com/)できます)。</span><span class="sxs-lookup"><span data-stu-id="41865-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="41865-256">NerdDinnerアプリケーションのテストでは、"Moq"と呼ばれるオープンソースのモックフレームワークを使用[http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)します。</span><span class="sxs-lookup"><span data-stu-id="41865-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="41865-257">ダウンロードしたら、NerdDinner.Tests プロジェクトの参照を Moq.dll アセンブリに追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="41865-258">次に、ユーザー名をパラメーターとして受け取り、DinnersController インスタンスのUser.Identity.Nameプロパティを "モック" する "CreateDinnersControllerAs(ユーザー名)" ヘルパー メソッドをテスト クラスに追加します。</span><span class="sxs-lookup"><span data-stu-id="41865-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="41865-259">上記では、Moq を使用して ControllerContext オブジェクトを偽装するモック オブジェクトを作成しています (これは、ユーザー、要求、応答、セッションなどのランタイム オブジェクトを公開するために、mvc がコントローラー クラスに渡ASP.NETものです)。</span><span class="sxs-lookup"><span data-stu-id="41865-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="41865-260">モックの "SetupGet" メソッドを呼び出して、ControllerContext のHttpContext.User.Identity.Nameプロパティがヘルパー メソッドに渡したユーザー名文字列を返す必要があることを示しています。</span><span class="sxs-lookup"><span data-stu-id="41865-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="41865-261">任意の数の ControllerContext プロパティとメソッドをモックできます。</span><span class="sxs-lookup"><span data-stu-id="41865-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="41865-262">これを説明するために、Request.IsAuthenticated プロパティの SetupGet() 呼び出しも追加しました (これは、以下のテストでは実際には必要ではありませんが、要求プロパティをモックする方法を説明するのに役立ちます)。</span><span class="sxs-lookup"><span data-stu-id="41865-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="41865-263">完了したら、ControllerContext モックのインスタンスを DinnersController ヘルパー メソッドが返すに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="41865-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="41865-264">このヘルパー メソッドを使用して、さまざまなユーザーが関与する編集シナリオをテストする単体テストを記述できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="41865-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="41865-265">そして今、我々はテストを実行すると、彼らは合格します:</span><span class="sxs-lookup"><span data-stu-id="41865-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="41865-266">テストモデル() シナリオ</span><span class="sxs-lookup"><span data-stu-id="41865-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="41865-267">編集アクションの HTTP-GET バージョンをカバーするテストを作成しました。</span><span class="sxs-lookup"><span data-stu-id="41865-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="41865-268">ここで、HTTP-POST バージョンの編集アクションを検証するテストをいくつか作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="41865-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="41865-269">このアクションメソッドでサポートする興味深い新しいテストシナリオは、コントローラの基本クラスでの UpdateModel() ヘルパーメソッドの使用です。</span><span class="sxs-lookup"><span data-stu-id="41865-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="41865-270">このヘルパー メソッドを使用して、フォームポストの値を Dinner オブジェクトインスタンスにバインドしています。</span><span class="sxs-lookup"><span data-stu-id="41865-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="41865-271">以下に、使用する UpdateModel() ヘルパー メソッドに対してフォームポスト値を指定する方法を示す 2 つのテストを示します。</span><span class="sxs-lookup"><span data-stu-id="41865-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="41865-272">この操作を行うには、FormCollection オブジェクトを作成して設定し、コントローラーの "ValueProvider" プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="41865-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="41865-273">最初のテストでは、正常に保存されたブラウザーが詳細アクションにリダイレクトされることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="41865-274">2 番目のテストでは、無効な入力がポストされると、アクションが再び編集ビューを再表示し、エラー メッセージが表示されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="41865-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="41865-275">テストのラップアップ</span><span class="sxs-lookup"><span data-stu-id="41865-275">Testing Wrap-Up</span></span>

<span data-ttu-id="41865-276">ここでは、単体テスト のコントローラー クラスに関連する中心的な概念について説明しました。</span><span class="sxs-lookup"><span data-stu-id="41865-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="41865-277">これらの手法を使用して、アプリケーションの動作を検証する数百の簡単なテストを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="41865-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="41865-278">コントローラとモデルのテストでは実際のデータベースは必要ないので、非常に高速で簡単に実行できます。</span><span class="sxs-lookup"><span data-stu-id="41865-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="41865-279">数秒で何百もの自動テストを実行し、変更が何かを壊したかどうかについてすぐにフィードバックを得ることができます。</span><span class="sxs-lookup"><span data-stu-id="41865-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="41865-280">これは、アプリケーションを継続的に改善し、リファクタリングし、洗練するための自信を提供するのに役立ちます。</span><span class="sxs-lookup"><span data-stu-id="41865-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="41865-281">この章の最後のトピックとしてテストを取り上げますが、テストは開発プロセスの最後に行う必要があるからです。</span><span class="sxs-lookup"><span data-stu-id="41865-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="41865-282">それどころか、開発プロセスでできるだけ早く自動テストを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="41865-283">これにより、開発中にすぐにフィードバックを得ることができ、アプリケーションのユースケースシナリオについて慎重に考え、クリーンな層と結合を念頭に置いてアプリケーションを設計するガイドを得ることができます。</span><span class="sxs-lookup"><span data-stu-id="41865-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="41865-284">本書の後の章では、テスト駆動開発 (TDD) と、ASP.NET MVC での使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="41865-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="41865-285">TDD は、結果として得られるコードが満たすテストを最初に記述する反復的なコーディング方法です。</span><span class="sxs-lookup"><span data-stu-id="41865-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="41865-286">TDD を使用すると、実装しようとしている機能を検証するテストを作成して、各機能を開始します。</span><span class="sxs-lookup"><span data-stu-id="41865-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="41865-287">単体テストを最初に記述すると、機能と機能がどのように機能するかを明確に理解できます。</span><span class="sxs-lookup"><span data-stu-id="41865-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="41865-288">テストが記述された後 (そして失敗したことを確認した場合) にのみ、テストで検証される実際の機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="41865-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="41865-289">機能の動作のユース ケースについて考える時間は既に費やされているため、要件と実装の最善の方法について理解を深める必要があります。</span><span class="sxs-lookup"><span data-stu-id="41865-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="41865-290">実装が完了したら、テストを再実行し、機能が正しく動作するかどうかのフィードバックをすぐに得ることができます。</span><span class="sxs-lookup"><span data-stu-id="41865-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="41865-291">第 10 章で TDD について詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="41865-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="41865-292">次の手順</span><span class="sxs-lookup"><span data-stu-id="41865-292">Next Step</span></span>

<span data-ttu-id="41865-293">いくつかの最終的なコメントをまとめる。</span><span class="sxs-lookup"><span data-stu-id="41865-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="41865-294">[前へ](use-ajax-to-implement-mapping-scenarios.md)
> [次へ](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="41865-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
