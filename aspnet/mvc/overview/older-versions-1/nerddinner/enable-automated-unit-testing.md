---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: 自動単体テストを有効にする |Microsoft Docs
author: microsoft
description: 手順 12. では、一連の自動単体テストを開発し、その機能を確認して、変更を行うための信頼を付与する方法を示します。
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78435592"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="e3401-103">自動化された単体テストを有効にする</span><span class="sxs-lookup"><span data-stu-id="e3401-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="e3401-104">[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="e3401-104">by [Microsoft](https://github.com/microsoft)</span></span>

<span data-ttu-id="e3401-105">[[Download PDF]\(PDF をダウンロード\)](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)</span><span class="sxs-lookup"><span data-stu-id="e3401-105">[Download PDF](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)</span></span>

> <span data-ttu-id="e3401-106">これは、ASP.NET MVC 1 を使用して小規模で完成した web アプリケーションを構築する方法を説明する、無料の["" アプリケーションのチュートリアル](introducing-the-nerddinner-tutorial.md)の手順12です。</span><span class="sxs-lookup"><span data-stu-id="e3401-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="e3401-107">手順 12. では、自動単体テストのスイートを開発し、その機能を検証します。これにより、将来アプリケーションの変更や機能強化を行う自信が得られます。</span><span class="sxs-lookup"><span data-stu-id="e3401-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="e3401-108">ASP.NET MVC 3 を使用している場合は、MVC 3 または[Mvc ミュージックストア](../../older-versions/mvc-music-store/mvc-music-store-part-1.md)[のチュートリアルではじめに](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md)に従うことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e3401-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="e3401-109">ステップ 12: 単体テストを実行する</span><span class="sxs-lookup"><span data-stu-id="e3401-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="e3401-110">この一連の自動化された単体テストを開発して、その機能を確認します。これにより、将来、アプリケーションの変更や改善を行う自信が得られます。</span><span class="sxs-lookup"><span data-stu-id="e3401-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="e3401-111">単体テストの理由</span><span class="sxs-lookup"><span data-stu-id="e3401-111">Why Unit Test?</span></span>

<span data-ttu-id="e3401-112">このドライブを使用すると、作業中のアプリケーションに関するインスピレーションの突然のフラッシュが発生します。</span><span class="sxs-lookup"><span data-stu-id="e3401-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="e3401-113">アプリケーションのパフォーマンスを大幅に向上させるために実装できる変更があることを認識しています。</span><span class="sxs-lookup"><span data-stu-id="e3401-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="e3401-114">コードをクリーンアップしたり、新しい機能を追加したり、バグを修正したりするリファクタリングが考えられます。</span><span class="sxs-lookup"><span data-stu-id="e3401-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="e3401-115">お客様のコンピューターに到着したときの問題は、「この改善にはどの程度の安全性がありますか」ということです。</span><span class="sxs-lookup"><span data-stu-id="e3401-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="e3401-116">変更を行うと副作用が発生したり、何かが壊れる場合はどうなるでしょうか。</span><span class="sxs-lookup"><span data-stu-id="e3401-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="e3401-117">変更は単純で、実装には数分かかりますが、すべてのアプリケーションシナリオを手動でテストするのに数時間かかる場合はどうでしょうか。</span><span class="sxs-lookup"><span data-stu-id="e3401-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="e3401-118">シナリオの内容を忘れた場合、アプリケーションの運用が中断された場合はどうなりますか。</span><span class="sxs-lookup"><span data-stu-id="e3401-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="e3401-119">この機能強化によってすべての作業に大きな価値を持たせるのでしょうか。</span><span class="sxs-lookup"><span data-stu-id="e3401-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="e3401-120">自動化された単体テストは、アプリケーションを継続的に強化し、作業しているコードを恐れることがないようにする安全なネットワークを提供できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="e3401-121">機能を迅速に検証する自動テストを使用すると、自信を持ってコーディングすることができ、それ以外の方法では満足できないように改善することができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="e3401-122">また、保守性が高く、有効期間が長いソリューションを作成するのにも役立ちます。これにより、投資収益率が大幅に向上します。</span><span class="sxs-lookup"><span data-stu-id="e3401-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="e3401-123">ASP.NET MVC フレームワークを使用すると、単体テストアプリケーションの機能が簡単かつ自然になります。</span><span class="sxs-lookup"><span data-stu-id="e3401-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="e3401-124">また、テスト駆動開発 (TDD) ワークフローを有効にして、テストファーストベースの開発を可能にします。</span><span class="sxs-lookup"><span data-stu-id="e3401-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="e3401-125">NerdDinner.Tests Project</span><span class="sxs-lookup"><span data-stu-id="e3401-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="e3401-126">このチュートリアルの最初に、このチュートリアルの最初に「このアプリケーションを作成したときに、アプリケーションプロジェクトと一緒に実行する単体テストプロジェクトを作成する必要があるかどうかを確認するダイアログが表示されました。</span><span class="sxs-lookup"><span data-stu-id="e3401-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="e3401-127">[はい、単体テストプロジェクトを作成する] オプションボタンをオンにしました。これにより、ソリューションに追加される "実行中のテスト" プロジェクトになります。</span><span class="sxs-lookup"><span data-stu-id="e3401-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="e3401-128">このプロジェクトでは、このプロジェクトアセンブリを参照して、アプリケーションの機能を確認する自動テストを簡単に追加できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="e3401-129">ディナーモデルクラスの単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="e3401-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="e3401-130">モデルレイヤーを構築したときに作成したディナークラスを検証するテストを、このプロジェクトに追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="e3401-131">まず、"モデル" という名前のテストプロジェクト内に新しいフォルダーを作成します。このフォルダーには、モデル関連のテストを配置します。</span><span class="sxs-lookup"><span data-stu-id="e3401-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="e3401-132">次に、フォルダーを右クリックし、[**新しいテストの&gt;追加**] メニューコマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="e3401-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="e3401-133">[新しいテストの追加] ダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="e3401-134">"単体テスト" を作成し、"DinnerTest.cs" という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="e3401-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="e3401-135">[Ok] ボタンをクリックすると、Visual Studio によって DinnerTest.cs ファイルがプロジェクトに追加 (開き) されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="e3401-136">既定の Visual Studio 単体テストテンプレートには、少し乱雑なボイラーコードが含まれています。</span><span class="sxs-lookup"><span data-stu-id="e3401-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="e3401-137">次のコードを含むようにクリーンアップしてみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="e3401-138">上記の Dinのテストクラスの [TestClass] 属性は、テストを含むクラスとして、およびオプションのテストの初期化および破棄コードを指定します。</span><span class="sxs-lookup"><span data-stu-id="e3401-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="e3401-139">この中に、[設定可能] 属性を持つパブリックメソッドを追加することによって、テストを定義できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="e3401-140">次に、ディナークラスを実行する2つのテストの最初の例を示します。</span><span class="sxs-lookup"><span data-stu-id="e3401-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="e3401-141">最初のテストでは、すべてのプロパティが正しく設定されていない状態で新しいディナーが作成された場合に、ディナーが無効であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="e3401-142">2番目のテストでは、ディナーがすべてのプロパティに有効な値を設定しているときに、ディナーが有効であることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="e3401-143">上記のテスト名は、非常に明確なものです (多少詳細)。</span><span class="sxs-lookup"><span data-stu-id="e3401-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="e3401-144">これは、数百または数千の小さなテストが作成される可能性があり、それぞれの意図と動作を簡単に判断できるようにするためです (特に、テストランナーでのエラーの一覧を参照している場合)。</span><span class="sxs-lookup"><span data-stu-id="e3401-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="e3401-145">テスト名は、テスト対象の機能の後に名前を付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="e3401-146">上の例では、"名詞\_\_動詞" という名前付けパターンを使用しています。</span><span class="sxs-lookup"><span data-stu-id="e3401-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="e3401-147">"AAA" テストパターンを使用してテストを構成しています。これは "Arrange, Act, Assert" を意味します。</span><span class="sxs-lookup"><span data-stu-id="e3401-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="e3401-148">配置: テスト対象の単位を設定します。</span><span class="sxs-lookup"><span data-stu-id="e3401-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="e3401-149">Act: テストとキャプチャの結果で単位を練習する</span><span class="sxs-lookup"><span data-stu-id="e3401-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="e3401-150">Assert: 動作を確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="e3401-151">テストを作成するときは、個々のテストがあまり多くなることを避ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="e3401-152">代わりに、各テストで1つの概念のみを検証する必要があります (これにより、障害の原因を特定しやすくなります)。</span><span class="sxs-lookup"><span data-stu-id="e3401-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="e3401-153">テストごとに1つの assert ステートメントのみを使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e3401-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="e3401-154">テストメソッドに複数の assert ステートメントがある場合は、それらがすべて同じ概念のテストに使用されていることを確認してください。</span><span class="sxs-lookup"><span data-stu-id="e3401-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="e3401-155">不明な場合は、別のテストを行います。</span><span class="sxs-lookup"><span data-stu-id="e3401-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="e3401-156">テストの実行</span><span class="sxs-lookup"><span data-stu-id="e3401-156">Running Tests</span></span>

<span data-ttu-id="e3401-157">Visual Studio 2008 Professional (およびそれ以降のエディション) には、IDE 内で Visual Studio 単体テストプロジェクトを実行するために使用できる組み込みのテストランナーが含まれています。</span><span class="sxs-lookup"><span data-stu-id="e3401-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="e3401-158">[ソリューション] メニューコマンド (または、Ctrl + A) を押してすべての単体テストを実行するには、**テスト&gt;実行&gt;すべてのテスト**を選択できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="e3401-159">または、特定のテストクラスまたはテストメソッド内にカーソルを配置し、[現在のコンテキストメニューコマンド**でテスト&gt;実行&gt;テスト**を使用する] (または、Ctrl + t キーを押して) 単体テストのサブセットを実行することもできます。</span><span class="sxs-lookup"><span data-stu-id="e3401-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="e3401-160">Dinのテストクラス内にカーソルを置き、「Ctrl R, T」と入力して、先ほど定義した2つのテストを実行します。</span><span class="sxs-lookup"><span data-stu-id="e3401-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="e3401-161">これを行うと、Visual Studio 内に "テスト結果" ウィンドウが表示され、テストの実行結果がその中に表示されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="e3401-162">*注: [VS テストの結果] ウィンドウには、既定では [クラス名] 列が表示されません。これを追加するには、[テスト結果] ウィンドウ内で右クリックし、[列の追加と削除] メニューコマンドを使用します。*</span><span class="sxs-lookup"><span data-stu-id="e3401-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="e3401-163">2つのテストが実行されるのは1秒未満で、両方が成功したことがわかります。</span><span class="sxs-lookup"><span data-stu-id="e3401-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="e3401-164">ここでは、特定の規則の検証を確認する追加のテストを作成してそれを拡張し、ディナークラスに追加した2つのヘルパーメソッドである IsUserHost () と Isuserhost () について説明します。</span><span class="sxs-lookup"><span data-stu-id="e3401-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="e3401-165">これらのすべてのテストをディナークラスに対して実施することで、将来的に新しいビジネスルールと検証を追加することがより簡単かつ安全になります。</span><span class="sxs-lookup"><span data-stu-id="e3401-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="e3401-166">新しいルールロジックをディナーに追加し、数秒以内に以前のロジック機能が壊れていないことを確認できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="e3401-167">説明的なテスト名を使用することにより、各テストがどのように検証されているかを簡単に把握できることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="e3401-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="e3401-168">[**ツール]-&gt;[オプション**] メニューコマンドを使用して、[テストツール-&gt;テスト実行構成] 画面を開き、[失敗または結果不確定の単体テストの結果をダブルクリックするとテストの失敗ポイントを表示する] チェックボックスをオンにすることをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="e3401-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="e3401-169">これにより、[テスト結果] ウィンドウでエラーをダブルクリックして、すぐにアサートエラーに戻ることができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="e3401-170">Dincontroller の単体テストの作成</span><span class="sxs-lookup"><span data-stu-id="e3401-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="e3401-171">次に、Dincontroller 機能を検証する単体テストを作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="e3401-172">まず、テストプロジェクト内の "Controllers" フォルダーを右クリックし、[**新しいテストの&gt;追加**] メニューコマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="e3401-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="e3401-173">"単体テスト" を作成し、"DinnersControllerTest.cs" という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="e3401-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="e3401-174">Dinで Details () アクションメソッドを確認する2つのテストメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="e3401-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="e3401-175">最初のは、既存のディナーが要求されたときにビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="e3401-176">2番目の方法では、存在しないディナーが要求されたときに "NotFound" ビューが返されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="e3401-177">上記のコードはクリーンをコンパイルします。</span><span class="sxs-lookup"><span data-stu-id="e3401-177">The above code compiles clean.</span></span> <span data-ttu-id="e3401-178">ただし、テストを実行すると、どちらも失敗します。</span><span class="sxs-lookup"><span data-stu-id="e3401-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="e3401-179">エラーメッセージが表示された場合、テストが失敗した理由は、Dinは Srepository クラスがデータベースに接続できなかったためです。</span><span class="sxs-lookup"><span data-stu-id="e3401-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="e3401-180">Linux アプリケーションでは、ローカル SQL Server Express ファイルへの接続文字列を使用しています。このファイルは、linux アプリケーションプロジェクトの \ App\_Data ディレクトリに存在します。</span><span class="sxs-lookup"><span data-stu-id="e3401-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="e3401-181">このテストプロジェクトは別のディレクトリでコンパイルおよび実行されるため、アプリケーションプロジェクトでは、接続文字列の相対パスの場所は正しくありません。</span><span class="sxs-lookup"><span data-stu-id="e3401-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="e3401-182">この問題*を解決する*には、SQL Express データベースファイルをテストプロジェクトにコピーし、テストプロジェクトの app.config に適切なテスト接続文字列を追加します。</span><span class="sxs-lookup"><span data-stu-id="e3401-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="e3401-183">これにより、上記のテストがブロック解除され、実行されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="e3401-184">ただし、実際のデータベースを使用した単体テストのコードには、多くの課題があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="e3401-185">具体的な内容は次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="e3401-185">Specifically:</span></span>

- <span data-ttu-id="e3401-186">単体テストの実行時間が大幅に低下します。</span><span class="sxs-lookup"><span data-stu-id="e3401-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="e3401-187">テストの実行にかかる時間が長くなるほど、頻繁に実行される可能性が低くなります。</span><span class="sxs-lookup"><span data-stu-id="e3401-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="e3401-188">単体テストを数秒で実行できるようにすることをお勧めします。これは、プロジェクトをコンパイルするのと同じように行うことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="e3401-189">これにより、テスト内のセットアップロジックとクリーンアップロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="e3401-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="e3401-190">各単体テストが分離され、他の単体テストに依存しないようにする必要があります (副作用も依存関係もありません)。</span><span class="sxs-lookup"><span data-stu-id="e3401-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="e3401-191">実際のデータベースに対して作業する場合は、状態を考慮して、テスト間でリセットする必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="e3401-192">これらの問題を回避し、実際のデータベースをテストで使用する必要がないようにするための "依存関係の注入" という設計パターンを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="e3401-193">依存関係の挿入</span><span class="sxs-lookup"><span data-stu-id="e3401-193">Dependency Injection</span></span>

<span data-ttu-id="e3401-194">現在では、コントローラーは dinのリポジトリクラスに密に "結合" されています。</span><span class="sxs-lookup"><span data-stu-id="e3401-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="e3401-195">"結合" とは、クラスが動作するために別のクラスに明示的に依存している状況を指します。</span><span class="sxs-lookup"><span data-stu-id="e3401-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="e3401-196">Dinのリポジトリクラスはデータベースへのアクセスを必要とするため、dinを使用したのと同じように結合された依存関係は、dinのコントローラーのアクションメソッドをテストするためにデータベースを用意する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="e3401-197">この問題を回避するには、"依存関係の挿入" というデザインパターンを使用します。これは、依存関係 (データアクセスを提供するリポジトリクラスなど) が、それらを使用するクラス内で暗黙的に作成されなくなる方法です。</span><span class="sxs-lookup"><span data-stu-id="e3401-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="e3401-198">代わりに、コンストラクター引数を使用して、依存関係を使用するクラスに明示的に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="e3401-199">依存関係がインターフェイスを使用して定義されている場合、単体テストシナリオの "偽の" 依存関係の実装を柔軟に渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="e3401-200">これにより、実際にはデータベースへのアクセスを必要としない、テスト固有の依存関係の実装を作成できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="e3401-201">この動作を確認するために、Dinのコントローラーとの依存関係の挿入を実装してみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="e3401-202">IDinnerRepository インターフェイスを抽出しています</span><span class="sxs-lookup"><span data-stu-id="e3401-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="e3401-203">最初の手順として、コントローラーがディナーを取得して更新するために必要なリポジトリコントラクトをカプセル化する新しい IDinnerRepository インターフェイスを作成します。</span><span class="sxs-lookup"><span data-stu-id="e3401-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="e3401-204">このインターフェイスコントラクトを手動で定義するには、[モデル] フォルダーを右クリックし、[**新しい項目の&gt;追加**] メニューコマンドを選択して、IDinnerRepository.cs という名前の新しいインターフェイスを作成します。</span><span class="sxs-lookup"><span data-stu-id="e3401-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="e3401-205">または、リファクタリングツールを組み込み Visual Studio Professional (およびそれ以降のエディション) を使用して、既存の Dinのリポジトリクラスから自動的にインターフェイスを抽出して作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="e3401-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="e3401-206">VS を使用してこのインターフェイスを抽出するには、Dinレポジトリクラスのテキストエディターにカーソルを置き、右クリックして [**リファクター-&gt;Extract インターフェイス**] メニューコマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="e3401-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="e3401-207">[インターフェイスの抽出] ダイアログボックスが開き、作成するインターフェイスの名前を入力するように求められます。</span><span class="sxs-lookup"><span data-stu-id="e3401-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="e3401-208">既定では IDinnerRepository に設定され、既存の Dinのリポジトリクラスのすべてのパブリックメソッドを自動的に選択して、インターフェイスに追加します。</span><span class="sxs-lookup"><span data-stu-id="e3401-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="e3401-209">[Ok] ボタンをクリックすると、Visual Studio によって、新しい IDinnerRepository インターフェイスがアプリケーションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="e3401-210">また、既存の Dinのリポジトリクラスは、インターフェイスを実装するように更新されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="e3401-211">コンストラクターの挿入をサポートするように Dinを更新しています</span><span class="sxs-lookup"><span data-stu-id="e3401-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="e3401-212">次に、新しいインターフェイスを使用するように Dinのコントローラークラスを更新します。</span><span class="sxs-lookup"><span data-stu-id="e3401-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="e3401-213">現在は、"Dinのリポジトリ" フィールドが常に Dinのリポジトリクラスであるように、次のようにハードコーディングされています。</span><span class="sxs-lookup"><span data-stu-id="e3401-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="e3401-214">これを変更して、"Dinレポジトリ" フィールドの種類が、Dinではなく IDinnerRepository になるようにします。</span><span class="sxs-lookup"><span data-stu-id="e3401-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="e3401-215">次に、2つのパブリック Dinscontroller コンストラクターを追加します。</span><span class="sxs-lookup"><span data-stu-id="e3401-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="e3401-216">コンストラクターの1つで、IDinnerRepository を引数として渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="e3401-217">もう1つは、既存の Dinのリポジトリ実装を使用する既定のコンストラクターです。</span><span class="sxs-lookup"><span data-stu-id="e3401-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="e3401-218">既定の ASP.NET MVC では既定のコンストラクターを使用してコントローラークラスが作成されるため、実行時の dinは、データアクセスを実行するために dinのリポジトリクラスを引き続き使用します。</span><span class="sxs-lookup"><span data-stu-id="e3401-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="e3401-219">ここでは、単体テストを更新して、パラメーターコンストラクターを使用して "偽の" ディナーリポジトリの実装を渡すことができるようになりました。</span><span class="sxs-lookup"><span data-stu-id="e3401-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="e3401-220">この "偽の" ディナーリポジトリは実際のデータベースへのアクセスを必要とせず、代わりにメモリ内のサンプルデータを使用します。</span><span class="sxs-lookup"><span data-stu-id="e3401-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="e3401-221">FakeDinnerRepository クラスの作成</span><span class="sxs-lookup"><span data-stu-id="e3401-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="e3401-222">FakeDinnerRepository クラスを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="e3401-223">まず、このプロジェクト内に "フェイク" ディレクトリを作成してから、新しい FakeDinnerRepository クラスを追加します (フォルダーを右クリックし、[&gt;追加]、 **[新しいクラス]** の順に選択します)。</span><span class="sxs-lookup"><span data-stu-id="e3401-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="e3401-224">ここでは、FakeDinnerRepository クラスが IDinnerRepository インターフェイスを実装するようにコードを更新します。</span><span class="sxs-lookup"><span data-stu-id="e3401-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="e3401-225">次に、それを右クリックし、[interface IDinnerRepository を実装する] コンテキストメニューコマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="e3401-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="e3401-226">これにより、Visual Studio は、既定の "スタブアウト" の実装を使用して、すべての IDinnerRepository インターフェイスメンバーを FakeDinnerRepository クラスに自動的に追加します。</span><span class="sxs-lookup"><span data-stu-id="e3401-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="e3401-227">次に、Fakedinを更新して、メモリ内のリスト&lt;ディナー&gt; コレクションをコンストラクター引数として渡すことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="e3401-228">これで、データベースを必要としないフェイクの IDinnerRepository 実装が作成されました。代わりに、ディナーオブジェクトのメモリ内リストを使用できなくなります。</span><span class="sxs-lookup"><span data-stu-id="e3401-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="e3401-229">単体テストでの Fakedinを使用したリポジトリの使用</span><span class="sxs-lookup"><span data-stu-id="e3401-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="e3401-230">データベースが使用できなかったために、前に失敗した Dincontroller の単体テストに戻りましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="e3401-231">テストメソッドを更新して、次のコードを使用して、メモリ内のディナーデータをサンプルに設定した Fakedinのリポジトリを使用するように更新できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="e3401-232">これらのテストを実行すると、両方とも次のようになります。</span><span class="sxs-lookup"><span data-stu-id="e3401-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="e3401-233">何よりも、実行にはほんの数分しかかかりません。複雑なセットアップ/クリーンアップロジックは必要ありません。</span><span class="sxs-lookup"><span data-stu-id="e3401-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="e3401-234">これで、実際のデータベースに接続しなくても、すべての Dinのコントローラーのアクションメソッドコード (リスティング、ページング、詳細、作成、更新、削除など) を単体テストできるようになりました。</span><span class="sxs-lookup"><span data-stu-id="e3401-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="e3401-235">**サイドトピック: 依存関係挿入フレームワーク**</span><span class="sxs-lookup"><span data-stu-id="e3401-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="e3401-236">(上記のように) 手動による依存関係の挿入の実行は正常に機能しますが、アプリケーション内の依存関係とコンポーネントの数が増えるにつれて、保守が困難になります。</span><span class="sxs-lookup"><span data-stu-id="e3401-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="e3401-237">.NET には、依存関係の管理の柔軟性をさらに高めるのに役立つ、いくつかの依存関係挿入フレームワークが用意されています。</span><span class="sxs-lookup"><span data-stu-id="e3401-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="e3401-238">これらのフレームワークは、"コントロールの反転" (IoC) コンテナーとも呼ばれ、実行時に依存関係を指定してオブジェクトに渡すための構成サポートのレベルを追加できるようにするメカニズムを提供します (ほとんどの場合、コンストラクターの挿入を使用します)。).</span><span class="sxs-lookup"><span data-stu-id="e3401-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="e3401-239">.NET での OSS 依存関係の注入/IOC フレームワークの中には、AutoFac、Ninject、Spring.NET、構造マップ、Windsor といった一般的なものがあります。</span><span class="sxs-lookup"><span data-stu-id="e3401-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="e3401-240">ASP.NET MVC は、開発者がコントローラーの解決とインスタンス化に参加できるようにする機能拡張 Api を公開します。これにより、このプロセス内で依存関係の挿入/IoC フレームワークを完全に統合できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="e3401-241">DI/IOC フレームワークを使用すると、Dinのコントローラーから既定のコンストラクターを削除することもできます。これにより、このコンストラクターと Dinのリポジトリ間の結合が完全に削除されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="e3401-242">私たちは、このアプリケーションでは、依存関係の注入/IOC フレームワークを使用しません。</span><span class="sxs-lookup"><span data-stu-id="e3401-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="e3401-243">しかし、これは将来のコードベースと機能が拡張された場合に考えられるものです。</span><span class="sxs-lookup"><span data-stu-id="e3401-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="e3401-244">編集アクションの単体テストを作成する</span><span class="sxs-lookup"><span data-stu-id="e3401-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="e3401-245">次に、Dinのコントローラーの編集機能を検証する単体テストを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="e3401-246">まず、編集操作の HTTP-GET バージョンをテストします。</span><span class="sxs-lookup"><span data-stu-id="e3401-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="e3401-247">次に、有効なディナーが要求されたときに Dinによってサポートされるビューが返されることを確認するテストを作成します。</span><span class="sxs-lookup"><span data-stu-id="e3401-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="e3401-248">ただし、テストを実行すると失敗することがわかります。これは、Edit メソッドが User.Identity.Name プロパティにアクセスして IsHostedBy () チェックを実行すると null 参照例外がスローされるためです。</span><span class="sxs-lookup"><span data-stu-id="e3401-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="e3401-249">コントローラーの基本クラスの User オブジェクトは、ログインしているユーザーに関する詳細をカプセル化し、実行時にコントローラーを作成するときに ASP.NET MVC によって設定されます。</span><span class="sxs-lookup"><span data-stu-id="e3401-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="e3401-250">Web サーバー環境の外部で Dinをテストしているため、ユーザーオブジェクトが設定されていません (したがって、null 参照の例外が発生します)。</span><span class="sxs-lookup"><span data-stu-id="e3401-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="e3401-251">User.Identity.Name プロパティのモック</span><span class="sxs-lookup"><span data-stu-id="e3401-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="e3401-252">モックフレームワークを使用すると、テストをサポートする依存オブジェクトのフェイクバージョンを動的に作成できるようになるため、テストが容易になります。</span><span class="sxs-lookup"><span data-stu-id="e3401-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="e3401-253">たとえば、編集アクションテストでモックフレームワークを使用して、ユーザーオブジェクトを動的に作成することができます。このオブジェクトは、ユーザーオブジェクトを使用して、シミュレートされたユーザー名を検索するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="e3401-254">これにより、テストの実行時に null 参照がスローされるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="e3401-255">ASP.NET MVC では、多くの .NET モックフレームワークを使用できます (ここでは、 [http://www.mockframeworks.com/](http://www.mockframeworks.com/))。</span><span class="sxs-lookup"><span data-stu-id="e3401-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="e3401-256">このアプリケーションをテストするために、"Moq" と呼ばれるオープンソースのモックフレームワークを使用します。これは、 [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)から無料でダウンロードできます。</span><span class="sxs-lookup"><span data-stu-id="e3401-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="e3401-257">ダウンロードが完了したら、次のように Moq .dll アセンブリに参照を追加します。</span><span class="sxs-lookup"><span data-stu-id="e3401-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="e3401-258">次に、"CreateDinnersControllerAs (username)" というヘルパーメソッドをテストクラスに追加します。このメソッドは、パラメーターとしてユーザー名を受け取り、次に "モック" を使用します。</span><span class="sxs-lookup"><span data-stu-id="e3401-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="e3401-259">上の例では、Moq を使用して、コントローラーのコンテキストオブジェクトをフェイクするモックオブジェクトを作成します (ASP.NET MVC は、ユーザー、要求、応答、セッションなどのランタイムオブジェクトを公開するためにコントローラークラスに渡されます)。</span><span class="sxs-lookup"><span data-stu-id="e3401-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="e3401-260">モックで "SetupGet" メソッドを呼び出して、コントローラーの HttpContext.User.Identity.Name プロパティがヘルパーメソッドに渡されたユーザー名文字列を返す必要があることを示しています。</span><span class="sxs-lookup"><span data-stu-id="e3401-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="e3401-261">任意の数のコントローラーのコンテキストプロパティとメソッドをモックできます。</span><span class="sxs-lookup"><span data-stu-id="e3401-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="e3401-262">このことを示すために、要求の IsAuthenticated プロパティのための SetupGet () 呼び出しも追加しました (以下のテストでは実際には必要ありませんが、要求プロパティをモックする方法を説明しています)。</span><span class="sxs-lookup"><span data-stu-id="e3401-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="e3401-263">この作業が完了したら、ヘルパーメソッドが返す、コントローラーに対して、コントローラーに対して、コントローラーのインスタンスを割り当てます。</span><span class="sxs-lookup"><span data-stu-id="e3401-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="e3401-264">このヘルパーメソッドを使用して、さまざまなユーザーに関係する編集シナリオをテストする単体テストを作成できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="e3401-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="e3401-265">テストを実行すると、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="e3401-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="e3401-266">UpdateModel () シナリオのテスト</span><span class="sxs-lookup"><span data-stu-id="e3401-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="e3401-267">編集アクションの HTTP GET バージョンをカバーするテストを作成しました。</span><span class="sxs-lookup"><span data-stu-id="e3401-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="e3401-268">次に、編集アクションの HTTP ポストバージョンを検証するテストを作成しましょう。</span><span class="sxs-lookup"><span data-stu-id="e3401-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="e3401-269">このアクションメソッドをサポートするための興味深い新しいテストシナリオは、コントローラーの基本クラスで UpdateModel () ヘルパーメソッドを使用することです。</span><span class="sxs-lookup"><span data-stu-id="e3401-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="e3401-270">このヘルパーメソッドを使用して、フォームポストの値をディナーオブジェクトインスタンスにバインドしています。</span><span class="sxs-lookup"><span data-stu-id="e3401-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="e3401-271">次の2つのテストは、使用する UpdateModel () ヘルパーメソッドのフォームポスト値を指定する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="e3401-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="e3401-272">これを行うには、FormCollection オブジェクトを作成および設定してから、コントローラーの "ValueProvider" プロパティに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="e3401-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="e3401-273">最初のテストでは、保存が成功したときに、ブラウザーが詳細アクションにリダイレクトされることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="e3401-274">2番目のテストでは、無効な入力が投稿されたときに、操作によって編集ビューが再度表示され、エラーメッセージが表示されることを確認します。</span><span class="sxs-lookup"><span data-stu-id="e3401-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="e3401-275">テストのラップアップ</span><span class="sxs-lookup"><span data-stu-id="e3401-275">Testing Wrap-Up</span></span>

<span data-ttu-id="e3401-276">ここでは、単体テストコントローラークラスに関連する主要な概念について説明しました。</span><span class="sxs-lookup"><span data-stu-id="e3401-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="e3401-277">これらの手法を使用すると、アプリケーションの動作を検証する数百の単純なテストを簡単に作成できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="e3401-278">コントローラーとモデルのテストは実際のデータベースを必要としないため、非常に高速で簡単に実行できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="e3401-279">数百の自動テストを数秒で実行できるようになり、加えた変更によって何かが破損していないかどうかについてすぐにフィードバックを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="e3401-280">これにより、アプリケーションを継続的に改善、リファクタリング、および改良することができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="e3401-281">この章の最後のトピックとして、テストについて説明しました。テストは開発プロセスの最後に行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="e3401-282">逆に、開発プロセスでできるだけ早く自動テストを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="e3401-283">これにより、開発時にすぐにフィードバックを取得できるようになり、アプリケーションのユースケースシナリオについて熟考と考えることができます。また、クリーンなレイヤーと結合を念頭に置いてアプリケーションを設計するためのガイドもあります。</span><span class="sxs-lookup"><span data-stu-id="e3401-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="e3401-284">この書籍の後半の章では、テスト駆動開発 (TDD) について説明し、ASP.NET MVC での使用方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="e3401-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="e3401-285">TDD は反復的なコーディング手法であり、結果のコードが満たすテストを最初に記述します。</span><span class="sxs-lookup"><span data-stu-id="e3401-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="e3401-286">TDD では、実装する機能を検証するテストを作成して、各機能を開始します。</span><span class="sxs-lookup"><span data-stu-id="e3401-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="e3401-287">最初に単体テストを記述することで、機能を明確に理解し、それがどのように動作するかを明確に把握できます。</span><span class="sxs-lookup"><span data-stu-id="e3401-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="e3401-288">テストが作成された後にのみ (エラーが発生したことを確認した後)、テストによって検証される実際の機能を実装します。</span><span class="sxs-lookup"><span data-stu-id="e3401-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="e3401-289">機能がどのように動作するかについての考慮事項を既に費やしているので、要件とその実装に最適な方法を理解する必要があります。</span><span class="sxs-lookup"><span data-stu-id="e3401-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="e3401-290">実装が完了したら、テストを再実行して、機能が正しく動作するかどうかについてすぐにフィードバックを受け取ることができます。</span><span class="sxs-lookup"><span data-stu-id="e3401-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="e3401-291">TDD の詳細については、10章を参照してください。</span><span class="sxs-lookup"><span data-stu-id="e3401-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="e3401-292">次の手順</span><span class="sxs-lookup"><span data-stu-id="e3401-292">Next Step</span></span>

<span data-ttu-id="e3401-293">最後にコメントをラップします。</span><span class="sxs-lookup"><span data-stu-id="e3401-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="e3401-294">[前へ](use-ajax-to-implement-mapping-scenarios.md)
> [次へ](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="e3401-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
