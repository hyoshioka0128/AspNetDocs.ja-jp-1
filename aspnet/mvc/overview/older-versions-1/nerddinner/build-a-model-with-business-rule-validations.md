---
uid: mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
title: ビジネス ルール検証とモデルの構築 |Microsoft Docs
author: microsoft
description: 手順 3 では、モデルを作成すること両方のクエリを使用し、NerdDinner アプリケーション データベースを更新する方法を示します。
ms.author: riande
ms.date: 07/27/2010
ms.assetid: 0bc191b2-4311-479a-a83a-7f1b1c32e6fe
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/build-a-model-with-business-rule-validations
msc.type: authoredcontent
ms.openlocfilehash: 6ebf1b71c089229ba9139ff7dc788b8978724046
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/06/2019
ms.locfileid: "65117617"
---
# <a name="build-a-model-with-business-rule-validations"></a><span data-ttu-id="13be0-103">ビジネス ルール検証でモデルをビルドする</span><span class="sxs-lookup"><span data-stu-id="13be0-103">Build a Model with Business Rule Validations</span></span>

<span data-ttu-id="13be0-104">によって[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="13be0-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="13be0-105">PDF のダウンロード</span><span class="sxs-lookup"><span data-stu-id="13be0-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="13be0-106">これは、無料の手順 3 ["NerdDinner"アプリケーションのチュートリアル](introducing-the-nerddinner-tutorial.md)をウォーク スルーの小さなをビルドしても、ASP.NET MVC 1 を使用して web アプリケーションを実行する方法。</span><span class="sxs-lookup"><span data-stu-id="13be0-106">This is step 3 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="13be0-107">手順 3 では、モデルを作成すること両方のクエリを使用し、NerdDinner アプリケーション データベースを更新する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="13be0-107">Step 3 shows how to create a model that we can use to both query and update the database for our NerdDinner application.</span></span>
> 
> <span data-ttu-id="13be0-108">次のことをお勧め ASP.NET MVC 3 を使用している場合、 [MVC 3 の開始と取得](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md)または[MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md)チュートリアル。</span><span class="sxs-lookup"><span data-stu-id="13be0-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-3-building-the-model"></a><span data-ttu-id="13be0-109">NerdDinner 手順 3:モデルを構築します。</span><span class="sxs-lookup"><span data-stu-id="13be0-109">NerdDinner Step 3: Building the Model</span></span>

<span data-ttu-id="13be0-110">モデル-ビュー-コント ローラー フレームワークでは、「モデル」という用語は、対応するドメイン ロジックと検証とビジネス ルールを統合すると、アプリケーションのデータを表すオブジェクトを指します。</span><span class="sxs-lookup"><span data-stu-id="13be0-110">In a model-view-controller framework the term "model" refers to the objects that represent the data of the application, as well as the corresponding domain logic that integrates validation and business rules with it.</span></span> <span data-ttu-id="13be0-111">モデルでは、MVC ベースのアプリケーションのさまざまな方法「心臓部」し、後で根本的に表示されるようの動作をドライブします。</span><span class="sxs-lookup"><span data-stu-id="13be0-111">The model is in many ways the "heart" of an MVC-based application, and as we'll see later fundamentally drives the behavior of it.</span></span>

<span data-ttu-id="13be0-112">ASP.NET MVC フレームワークには、任意のデータ アクセス テクノロジを使用して、開発者は、さまざまななど、モデルを実装するために豊富な .NET データのオプションから選択できます。LINQ to エンティティ、LINQ to SQL、NHibernate、LLBLGen Pro、SubSonic、WilsonORM、または単なる生 ADO.NET Datareader またはデータセットです。</span><span class="sxs-lookup"><span data-stu-id="13be0-112">The ASP.NET MVC framework supports using any data access technology, and developers can choose from a variety of rich .NET data options to implement their models including: LINQ to Entities, LINQ to SQL, NHibernate, LLBLGen Pro, SubSonic, WilsonORM, or just raw ADO.NET DataReaders or DataSets.</span></span>

<span data-ttu-id="13be0-113">NerdDinner アプリケーションは、LINQ to SQL を使用して、データベースの設計に忠実に対応し、いくつかのカスタム検証ロジックとビジネス ルールを追加する単純なモデルを作成するでしょう。</span><span class="sxs-lookup"><span data-stu-id="13be0-113">For our NerdDinner application we are going to use LINQ to SQL to create a simple model that corresponds fairly closely to our database design, and adds some custom validation logic and business rules.</span></span> <span data-ttu-id="13be0-114">データ永続化の実装を簡単に単体テストにより、アプリケーションの残りの部分から抽象離れたときに役立つリポジトリ クラスを実装しますが、します。</span><span class="sxs-lookup"><span data-stu-id="13be0-114">We will then implement a repository class that helps abstract away the data persistence implementation from the rest of the application, and enables us to easily unit test it.</span></span>

### <a name="linq-to-sql"></a><span data-ttu-id="13be0-115">LINQ to SQL</span><span class="sxs-lookup"><span data-stu-id="13be0-115">LINQ to SQL</span></span>

<span data-ttu-id="13be0-116">LINQ to SQL は、.NET 3.5 の一部として同梱されている ORM (オブジェクト リレーショナル マッパーです)。</span><span class="sxs-lookup"><span data-stu-id="13be0-116">LINQ to SQL is an ORM (object relational mapper) that ships as part of .NET 3.5.</span></span>

<span data-ttu-id="13be0-117">LINQ to SQL では、.NET クラスのコードにはデータベース テーブルにマップする簡単な方法を提供します。</span><span class="sxs-lookup"><span data-stu-id="13be0-117">LINQ to SQL provides an easy way to map database tables to .NET classes we can code against.</span></span> <span data-ttu-id="13be0-118">NerdDinner アプリケーションの Dinner および RSVP のクラスに、データベース内で、Dinners および RSVP テーブルにマップするのにに使用します。</span><span class="sxs-lookup"><span data-stu-id="13be0-118">For our NerdDinner application we'll use it to map the Dinners and RSVP tables within our database to Dinner and RSVP classes.</span></span> <span data-ttu-id="13be0-119">Dinners および RSVP のテーブルの列は、Dinner と RSVP クラスのプロパティに対応します。</span><span class="sxs-lookup"><span data-stu-id="13be0-119">The columns of the Dinners and RSVP tables will correspond to properties on the Dinner and RSVP classes.</span></span> <span data-ttu-id="13be0-120">Dinner および RSVP の各オブジェクトは、データベース内の Dinners または RSVP のテーブル内の個別の行を表します。</span><span class="sxs-lookup"><span data-stu-id="13be0-120">Each Dinner and RSVP object will represent a separate row within the Dinners or RSVP tables in the database.</span></span>

<span data-ttu-id="13be0-121">LINQ to SQL では、Dinner および RSVP を取得および更新の SQL ステートメントを手動で作成しなくてもすむようににより、データベースのデータ オブジェクト。</span><span class="sxs-lookup"><span data-stu-id="13be0-121">LINQ to SQL allows us to avoid having to manually construct SQL statements to retrieve and update Dinner and RSVP objects with database data.</span></span> <span data-ttu-id="13be0-122">代わりにマップする方法との間、データベース、およびそれらの関係は、Dinner および RSVP クラスで定義します。</span><span class="sxs-lookup"><span data-stu-id="13be0-122">Instead, we'll define the Dinner and RSVP classes, how they map to/from the database, and the relationships between them.</span></span> <span data-ttu-id="13be0-123">LINQ to SQL は私たちを操作し、それらを使用時に、実行時に使用する適切な SQL の実行ロジックを生成する処理を引き継ぎます。</span><span class="sxs-lookup"><span data-stu-id="13be0-123">LINQ to SQL will then takes care of generating the appropriate SQL execution logic to use at runtime when we interact and use them.</span></span>

<span data-ttu-id="13be0-124">VB と c# 内での LINQ の言語サポートを使用して Dinner と RSVP を取得する表現力豊かなクエリの作成、データベースのオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="13be0-124">We can use the LINQ language support within VB and C# to write expressive queries that retrieve Dinner and RSVP objects from the database.</span></span> <span data-ttu-id="13be0-125">これによりデータのコードを記述する必要がありますの量を最小限にし、本当に優れたアプリケーションを構築することができます。</span><span class="sxs-lookup"><span data-stu-id="13be0-125">This minimizes the amount of data code we need to write, and allows us to build really clean applications.</span></span>

### <a name="adding-linq-to-sql-classes-to-our-project"></a><span data-ttu-id="13be0-126">追加の LINQ to SQL クラスをプロジェクト</span><span class="sxs-lookup"><span data-stu-id="13be0-126">Adding LINQ to SQL Classes to our project</span></span>

<span data-ttu-id="13be0-127">このプロジェクト内で"Models"フォルダーを右クリックして開始を選択し、**追加 -&gt;新しい項目の**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="13be0-127">We'll begin by right-clicking on the "Models" folder within our project, and select the **Add-&gt;New Item** menu command:</span></span>

![](build-a-model-with-business-rule-validations/_static/image1.png)

<span data-ttu-id="13be0-128">「新しい項目の追加」ダイアログが表示されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-128">This will bring up the "Add New Item" dialog.</span></span> <span data-ttu-id="13be0-129">「データ」カテゴリでフィルター処理、内に"LINQ to SQL Classes"テンプレートを選択します。</span><span class="sxs-lookup"><span data-stu-id="13be0-129">We'll filter by the "Data" category and select the "LINQ to SQL Classes" template within it:</span></span>

![](build-a-model-with-business-rule-validations/_static/image2.png)

<span data-ttu-id="13be0-130">項目"NerdDinner"という名前がされ、[追加] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="13be0-130">We'll name the item "NerdDinner" and click the "Add" button.</span></span> <span data-ttu-id="13be0-131">Visual Studio は、\Models ディレクトリの下で NerdDinner.dbml ファイルを追加し、LINQ to SQL オブジェクト リレーショナル デザイナーを開きます。</span><span class="sxs-lookup"><span data-stu-id="13be0-131">Visual Studio will add a NerdDinner.dbml file under our \Models directory, and then open the LINQ to SQL object relational designer:</span></span>

![](build-a-model-with-business-rule-validations/_static/image3.png)

### <a name="creating-data-model-classes-with-linq-to-sql"></a><span data-ttu-id="13be0-132">LINQ to SQL でのデータ モデル クラスの作成</span><span class="sxs-lookup"><span data-stu-id="13be0-132">Creating Data Model Classes with LINQ to SQL</span></span>

<span data-ttu-id="13be0-133">LINQ to SQL では、既存のデータベース スキーマからデータ モデル クラスをすばやく作成できます。</span><span class="sxs-lookup"><span data-stu-id="13be0-133">LINQ to SQL enables us to quickly create data model classes from existing database schema.</span></span> <span data-ttu-id="13be0-134">To do がモデル化するこの NerdDinner データベースをサーバー エクスプ ローラーで開くし、テーブルを選択します。</span><span class="sxs-lookup"><span data-stu-id="13be0-134">To-do this we'll open the NerdDinner database in the Server Explorer, and select the Tables we want to model in it:</span></span>

![](build-a-model-with-business-rule-validations/_static/image4.png)

<span data-ttu-id="13be0-135">SQL デザイナー画面に、LINQ にテーブルをドラッグしたことができます。</span><span class="sxs-lookup"><span data-stu-id="13be0-135">We can then drag the tables onto the LINQ to SQL designer surface.</span></span> <span data-ttu-id="13be0-136">操作の場合この LINQ to SQL と、Dinner が自動的に作成し、(データベース テーブルの列にマップされるクラス プロパティ) を持つテーブルのスキーマを使用して、RSVP クラス。</span><span class="sxs-lookup"><span data-stu-id="13be0-136">When we do this LINQ to SQL will automatically create Dinner and RSVP classes using the schema of the tables (with class properties that map to the database table columns):</span></span>

![](build-a-model-with-business-rule-validations/_static/image5.png)

<span data-ttu-id="13be0-137">既定では、LINQ to SQL デザイナー自動的に「複数」テーブルおよび列名、データベース スキーマに基づくクラスを作成するとき。</span><span class="sxs-lookup"><span data-stu-id="13be0-137">By default the LINQ to SQL designer automatically "pluralizes" table and column names when it creates classes based on a database schema.</span></span> <span data-ttu-id="13be0-138">例: 上記の例で"Dinners"テーブル"Dinner"クラスが発生しました。</span><span class="sxs-lookup"><span data-stu-id="13be0-138">For example: the "Dinners" table in our example above resulted in a "Dinner" class.</span></span> <span data-ttu-id="13be0-139">このクラスの名前付けでは、モデルに .NET の命名規則に一貫性のあるなってし、そのデザイナーの修正プログラムこのようにする便利な (特に多くのテーブルを追加する) 場合は、通常の検索します。</span><span class="sxs-lookup"><span data-stu-id="13be0-139">This class naming helps make our models consistent with .NET naming conventions, and I usually find that having the designer fix this up convenient (especially when adding lots of tables).</span></span> <span data-ttu-id="13be0-140">クラスまたは常にこのメソッドをオーバーライドし、任意の名前に変更できますが、デザイナーが生成されるプロパティの名前を取り消す場合。</span><span class="sxs-lookup"><span data-stu-id="13be0-140">If you don't like the name of a class or property that the designer generates, though, you can always override it and change it to any name you want.</span></span> <span data-ttu-id="13be0-141">これを行う、エンティティ/プロパティ名の行のデザイナー内での編集をするか、プロパティ グリッドを使用して変更します。</span><span class="sxs-lookup"><span data-stu-id="13be0-141">You can do this either by editing the entity/property name in-line within the designer or by modifying it via the property grid.</span></span>

<span data-ttu-id="13be0-142">既定では、LINQ to SQL デザイナーはまた、テーブルの主キー/外部キーのリレーションシップを検査し、自動的にそれらに基づくには、「リレーションシップ関連付け」デフォルトを作成、間別のモデル クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="13be0-142">By default the LINQ to SQL designer also inspects the primary key/foreign key relationships of the tables, and based on them automatically creates default "relationship associations" between the different model classes it creates.</span></span> <span data-ttu-id="13be0-143">たとえば、ドラッグ、Dinners と RSVP テーブル、LINQ to SQL デザイナー上に 2 つの間の関連付けを一対多のリレーションシップが推定された、という事実に基づいて RSVP テーブルには、Dinners テーブルへの外部キーが必要がある (これで、矢印によって示されますが、デザイナーの):</span><span class="sxs-lookup"><span data-stu-id="13be0-143">For example, when we dragged the Dinners and RSVP tables onto the LINQ to SQL designer a one-to-many relationship association between the two was inferred based on the fact that the RSVP table had a foreign-key to the Dinners table (this is indicated by the arrow in the designer):</span></span>

![](build-a-model-with-business-rule-validations/_static/image6.png)

<span data-ttu-id="13be0-144">上記のアソシエーションでは、SQL には、開発者は、指定された予約に関連付けられている Dinner へのアクセスに使用できる RSVP クラスに厳密に型指定された"Dinner"プロパティを追加する LINQ が発生します。</span><span class="sxs-lookup"><span data-stu-id="13be0-144">The above association will cause LINQ to SQL to add a strongly typed "Dinner" property to the RSVP class that developers can use to access the Dinner associated with a given RSVP.</span></span> <span data-ttu-id="13be0-145">開発者を取得し、特定の夕食に関連付けられている RSVP オブジェクトを更新できるようにする"RSVPs"コレクション プロパティを持つ Dinner クラスにもなります。</span><span class="sxs-lookup"><span data-stu-id="13be0-145">It will also cause the Dinner class to have a "RSVPs" collection property that enables developers to retrieve and update RSVP objects associated with a particular Dinner.</span></span>

<span data-ttu-id="13be0-146">次に示す新しい RSVP オブジェクトを作成し、Dinner の予約したコレクションに追加するときに、Visual Studio 内での intellisense の例を確認できます。</span><span class="sxs-lookup"><span data-stu-id="13be0-146">Below you can see an example of intellisense within Visual Studio when we create a new RSVP object and add it to a Dinner's RSVPs collection.</span></span> <span data-ttu-id="13be0-147">方法 LINQ to SQL に自動的に「受理」コレクションに追加 Dinner オブジェクトに注意してください。</span><span class="sxs-lookup"><span data-stu-id="13be0-147">Notice how LINQ to SQL automatically added a "RSVPs" collection on the Dinner object:</span></span>

![](build-a-model-with-business-rule-validations/_static/image7.png)

<span data-ttu-id="13be0-148">RSVP オブジェクトを Dinner の予約したコレクションに追加することでは、to、Dinner とデータベースに RSVP 行の間の外部キー リレーションシップに関連付ける SQL、LINQ を指示します。</span><span class="sxs-lookup"><span data-stu-id="13be0-148">By adding the RSVP object to the Dinner's RSVPs collection we are telling LINQ to SQL to associate a foreign-key relationship between the Dinner and the RSVP row in our database:</span></span>

![](build-a-model-with-business-rule-validations/_static/image8.png)

<span data-ttu-id="13be0-149">デザイナーのモデル化やという名前のテーブルの関連付けの方法が気をオーバーライドできます。</span><span class="sxs-lookup"><span data-stu-id="13be0-149">If you don't like how the designer has modeled or named a table association, you can override it.</span></span> <span data-ttu-id="13be0-150">デザイナー内での関連付けの矢印をクリックし、名前の変更、削除または変更するには、プロパティ グリッドを使用してそのプロパティにアクセスだけです。</span><span class="sxs-lookup"><span data-stu-id="13be0-150">Just click on the association arrow within the designer and access its properties via the property grid to rename, delete or modify it.</span></span> <span data-ttu-id="13be0-151">NerdDinner アプリケーションでは、既定のアソシエーション ルールが構築されたデータ モデル クラスにも作業して、次の既定の動作を使用できます。</span><span class="sxs-lookup"><span data-stu-id="13be0-151">For our NerdDinner application, though, the default association rules work well for the data model classes we are building and we can just use the default behavior.</span></span>

### <a name="nerddinnerdatacontext-class"></a><span data-ttu-id="13be0-152">NerdDinnerDataContext クラス</span><span class="sxs-lookup"><span data-stu-id="13be0-152">NerdDinnerDataContext Class</span></span>

<span data-ttu-id="13be0-153">Visual Studio では、モデルと LINQ to SQL デザイナーを使用して定義されているデータベースのリレーションシップを表す .NET クラスを自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-153">Visual Studio will automatically create .NET classes that represent the models and database relationships defined using the LINQ to SQL designer.</span></span> <span data-ttu-id="13be0-154">各 LINQ to SQL デザイナー ファイルをソリューションに追加の LINQ to SQL DataContext クラスが生成されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-154">A LINQ to SQL DataContext class is also generated for each LINQ to SQL designer file added to the solution.</span></span> <span data-ttu-id="13be0-155">SQL クラスの項目"NerdDinner"に、LINQ、という名前であるために、作成された DataContext クラスには、"NerdDinnerDataContext"が呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-155">Because we named our LINQ to SQL class item "NerdDinner", the DataContext class created will be called "NerdDinnerDataContext".</span></span> <span data-ttu-id="13be0-156">NerdDinnerDataContext クラスは、データベースと対話する主な方法です。</span><span class="sxs-lookup"><span data-stu-id="13be0-156">This NerdDinnerDataContext class is the primary way we will interact with the database.</span></span>

<span data-ttu-id="13be0-157">NerdDinnerDataContext クラスは、データベース内でモデル化 2 つのテーブルを表す"Dinners"と"RSVPs"- - 2 つのプロパティを公開します。</span><span class="sxs-lookup"><span data-stu-id="13be0-157">Our NerdDinnerDataContext class exposes two properties - "Dinners" and "RSVPs" - that represent the two tables we modeled within the database.</span></span> <span data-ttu-id="13be0-158">C# を使用しますと、Dinner と RSVP のオブジェクトをキャッシュにクエリをデータベースからこれらのプロパティに対する LINQ クエリを記述します。</span><span class="sxs-lookup"><span data-stu-id="13be0-158">We can use C# to write LINQ queries against those properties to query and retrieve Dinner and RSVP objects from the database.</span></span>

<span data-ttu-id="13be0-159">次のコードでは、NerdDinnerDataContext オブジェクトをインスタンス化し、今後の予定 Dinners のシーケンスを取得することに対して LINQ クエリを実行する方法を示します。</span><span class="sxs-lookup"><span data-stu-id="13be0-159">The following code demonstrates how to instantiate a NerdDinnerDataContext object and perform a LINQ query against it to obtain a sequence of Dinners that occur in the future.</span></span> <span data-ttu-id="13be0-160">Visual Studio は、LINQ クエリの作成時に intellisense の全機能を提供し、そこから返されるオブジェクトは厳密に型指定されたも intellisense をサポートします。</span><span class="sxs-lookup"><span data-stu-id="13be0-160">Visual Studio provides full intellisense when writing the LINQ query, and the objects returned from it are strongly-typed and also support intellisense:</span></span>

![](build-a-model-with-business-rule-validations/_static/image9.png)

<span data-ttu-id="13be0-161">Dinner および RSVP オブジェクトを照会することを許可するだけでなく、NerdDinnerDataContext も自動的に、その後、Dinner と RSVP オブジェクトを取得しますに加えた変更を追跡します。</span><span class="sxs-lookup"><span data-stu-id="13be0-161">In addition to allowing us to query for Dinner and RSVP objects, a NerdDinnerDataContext also automatically tracks any changes we subsequently make to the Dinner and RSVP objects we retrieve through it.</span></span> <span data-ttu-id="13be0-162">この機能を使用して、-明示的な SQL 更新プログラム コードを記述することがなく元のデータベースに簡単に変更を保存することができます。</span><span class="sxs-lookup"><span data-stu-id="13be0-162">We can use this functionality to easily save the changes back to the database - without having to write any explicit SQL update code.</span></span>

<span data-ttu-id="13be0-163">たとえば、次のコードでは、LINQ クエリを使用して、データベースから 1 つの Dinner オブジェクトを取得、Dinner のプロパティ の 2 つの更新、および元のデータベースに変更を保存する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="13be0-163">For example, the code below demonstrates how to use a LINQ query to retrieve a single Dinner object from the database, update two of the Dinner properties, and then save the changes back to the database:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample1.cs)]

<span data-ttu-id="13be0-164">前のコードで NerdDinnerDataContext オブジェクトは、そこから取得した Dinner オブジェクトに対して行われたプロパティの変更を自動的に追跡します。</span><span class="sxs-lookup"><span data-stu-id="13be0-164">The NerdDinnerDataContext object in the code above automatically tracked the property changes made to the Dinner object we retrieved from it.</span></span> <span data-ttu-id="13be0-165">私たちには、"SubmitChanges()"メソッドが呼び出されると、更新された値を保持するデータベースに適切な SQL「更新」ステートメントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-165">When we called the "SubmitChanges()" method, it will execute an appropriate SQL "UPDATE" statement to the database to persist the updated values back.</span></span>

### <a name="creating-a-dinnerrepository-class"></a><span data-ttu-id="13be0-166">ときは必ず DinnerRepository クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="13be0-166">Creating a DinnerRepository Class</span></span>

<span data-ttu-id="13be0-167">小規模なアプリケーションは、LINQ to SQL DataContext クラスに対して直接動作し、コント ローラー内での LINQ クエリを埋め込むのコント ローラーを用意しても構いませんがあります。</span><span class="sxs-lookup"><span data-stu-id="13be0-167">For small applications it is sometimes fine to have Controllers work directly against a LINQ to SQL DataContext class, and embed LINQ queries within the Controllers.</span></span> <span data-ttu-id="13be0-168">大規模なアプリケーションとして、ただし、このアプローチに維持し、テストする面倒ななります。</span><span class="sxs-lookup"><span data-stu-id="13be0-168">As applications get larger, though, this approach becomes cumbersome to maintain and test.</span></span> <span data-ttu-id="13be0-169">これは、場合も複数の場所で同じ LINQ クエリを複製することにつながります。</span><span class="sxs-lookup"><span data-stu-id="13be0-169">It can also lead to us duplicating the same LINQ queries in multiple places.</span></span>

<span data-ttu-id="13be0-170">メンテナンスやテストを容易にアプリケーションをすることが 1 つの方法では、「リポジトリ」のパターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="13be0-170">One approach that can make applications easier to maintain and test is to use a "repository" pattern.</span></span> <span data-ttu-id="13be0-171">リポジトリのクラスにより、データのクエリを実行して、永続化ロジックと抽象アプリケーションからのデータの永続化の実装の詳細をカプセル化します。</span><span class="sxs-lookup"><span data-stu-id="13be0-171">A repository class helps encapsulate data querying and persistence logic, and abstracts away the implementation details of the data persistence from the application.</span></span> <span data-ttu-id="13be0-172">アプリケーション コードを簡潔に行うには、だけでなくリポジトリ パターンを使用してやすく、後では、データ ストレージの実装を変更して、単体テストの実際のデータベースを必要とせず、アプリケーションを容易にするために役立ちます。</span><span class="sxs-lookup"><span data-stu-id="13be0-172">In addition to making application code cleaner, using a repository pattern can make it easier to change data storage implementations in the future, and it can help facilitate unit testing an application without requiring a real database.</span></span>

<span data-ttu-id="13be0-173">NerdDinner アプリケーションを持つときは必ず DinnerRepository クラスを定義します、署名の下。</span><span class="sxs-lookup"><span data-stu-id="13be0-173">For our NerdDinner application we'll define a DinnerRepository class with the below signature:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample2.cs)]

<span data-ttu-id="13be0-174">*注:この章では後でこのクラスから IDinnerRepository インターフェイスの抽出がされ、コント ローラーでそれに依存関係の挿入を有効にします。まず、ここを簡単に開始し、ときは必ず DinnerRepository クラスを直接操作だけです。*</span><span class="sxs-lookup"><span data-stu-id="13be0-174">*Note: Later in this chapter we'll extract an IDinnerRepository interface from this class and enable dependency injection with it on our Controllers. To begin with, though, we are going to start simple and just work directly with the DinnerRepository class.*</span></span>

<span data-ttu-id="13be0-175">"Models"フォルダーを右クリックしを選択しましたが、このクラスを実装するために、**追加 -&gt;新しい項目の**メニュー コマンド。</span><span class="sxs-lookup"><span data-stu-id="13be0-175">To implement this class we'll right-click on our "Models" folder and choose the **Add-&gt;New Item** menu command.</span></span> <span data-ttu-id="13be0-176">"新しい項目の追加 ダイアログ ボックスでは、「クラス」テンプレートを選択し、ファイルの名前を"DinnerRepository.cs"しましたします。</span><span class="sxs-lookup"><span data-stu-id="13be0-176">Within the "Add New Item" dialog we'll select the "Class" template and name the file "DinnerRepository.cs":</span></span>

![](build-a-model-with-business-rule-validations/_static/image10.png)

<span data-ttu-id="13be0-177">次のコードを使用するときは必ず DinnerRepository クラスを実装しましたできます。</span><span class="sxs-lookup"><span data-stu-id="13be0-177">We can then implement our DinnerRepository class using the code below:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample3.cs)]

### <a name="retrieving-updating-inserting-and-deleting-using-the-dinnerrepository-class"></a><span data-ttu-id="13be0-178">取得、更新、挿入およびときは必ず DinnerRepository クラスを使用して削除します。</span><span class="sxs-lookup"><span data-stu-id="13be0-178">Retrieving, Updating, Inserting and Deleting using the DinnerRepository class</span></span>

<span data-ttu-id="13be0-179">ときは必ず DinnerRepository クラスを作成しましたので、次のことができるかの一般的なタスクを示すいくつかのコード例を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="13be0-179">Now that we've created our DinnerRepository class, let's look at a few code examples that demonstrate common tasks we can do with it:</span></span>

#### <a name="querying-examples"></a><span data-ttu-id="13be0-180">例のクエリを実行します。</span><span class="sxs-lookup"><span data-stu-id="13be0-180">Querying Examples</span></span>

<span data-ttu-id="13be0-181">次のコードは、DinnerID 値を使用して 1 つの夕食を取得します。</span><span class="sxs-lookup"><span data-stu-id="13be0-181">The code below retrieves a single Dinner using the DinnerID value:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample4.cs)]

<span data-ttu-id="13be0-182">次のコードは、上にすべての今後の dinners とループを取得します。</span><span class="sxs-lookup"><span data-stu-id="13be0-182">The code below retrieves all upcoming dinners and loops over them:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample5.cs)]

#### <a name="insert-and-update-examples"></a><span data-ttu-id="13be0-183">挿入と更新プログラムの例</span><span class="sxs-lookup"><span data-stu-id="13be0-183">Insert and Update Examples</span></span>

<span data-ttu-id="13be0-184">次のコードでは、2 つの新しい dinners を追加することを示します。</span><span class="sxs-lookup"><span data-stu-id="13be0-184">The code below demonstrates adding two new dinners.</span></span> <span data-ttu-id="13be0-185">上の"Save()"メソッドが呼び出されるまでの追加/変更をリポジトリには、データベースにコミットはありません。</span><span class="sxs-lookup"><span data-stu-id="13be0-185">Additions/modifications to the repository aren't committed to the database until the "Save()" method is called on it.</span></span> <span data-ttu-id="13be0-186">LINQ to SQL を使用 – データベースのトランザクションのため、すべての変更が発生するか、リポジトリに保存するときに、いずれのすべての変更が自動的に折り返さ。</span><span class="sxs-lookup"><span data-stu-id="13be0-186">LINQ to SQL automatically wraps all changes in a database transaction – so either all changes happen or none of them do when our repository saves:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample6.cs)]

<span data-ttu-id="13be0-187">次のコードでは、既存の Dinner オブジェクトを取得し、2 つのプロパティを変更します。</span><span class="sxs-lookup"><span data-stu-id="13be0-187">The code below retrieves an existing Dinner object, and modifies two properties on it.</span></span> <span data-ttu-id="13be0-188">当社のリポジトリ上の"Save()"メソッドが呼び出されたときに、変更を元のデータベースにコミットします。</span><span class="sxs-lookup"><span data-stu-id="13be0-188">The changes are committed back to the database when the "Save()" method is called on our repository:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample7.cs)]

<span data-ttu-id="13be0-189">次のコードを夕食を取得し、予約を追加します。</span><span class="sxs-lookup"><span data-stu-id="13be0-189">The code below retrieves a dinner and then adds an RSVP to it.</span></span> <span data-ttu-id="13be0-190">これは、(データベース内の 2 つのプライマリのキー/外部キー リレーションシップがある) ための LINQ to SQL を作成する Dinner オブジェクトに予約したコレクションを使用します。</span><span class="sxs-lookup"><span data-stu-id="13be0-190">It does this using the RSVPs collection on the Dinner object that LINQ to SQL created for us (because there is a primary-key/foreign-key relationship between the two in the database).</span></span> <span data-ttu-id="13be0-191">この変更 RSVP の新しいテーブル行としてデータベースに永続化、リポジトリ上の"Save()"メソッドが呼び出されたときに。</span><span class="sxs-lookup"><span data-stu-id="13be0-191">This change is persisted back to the database as a new RSVP table row when the "Save()" method is called on the repository:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample8.cs)]

#### <a name="delete-example"></a><span data-ttu-id="13be0-192">削除の例</span><span class="sxs-lookup"><span data-stu-id="13be0-192">Delete Example</span></span>

<span data-ttu-id="13be0-193">次のコードでは、既存の Dinner オブジェクトを取得し、削除のマークを付けます。</span><span class="sxs-lookup"><span data-stu-id="13be0-193">The code below retrieves an existing Dinner object, and then marks it to be deleted.</span></span> <span data-ttu-id="13be0-194">リポジトリの"Save()"メソッドが呼び出されたときに、削除を元のデータベースにコミットします。</span><span class="sxs-lookup"><span data-stu-id="13be0-194">When the "Save()" method is called on the repository it will commit the delete back to the database:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample9.cs)]

### <a name="integrating-validation-and-business-rule-logic-with-model-classes"></a><span data-ttu-id="13be0-195">モデル クラスを検証し、ビジネス ルール ロジックの統合</span><span class="sxs-lookup"><span data-stu-id="13be0-195">Integrating Validation and Business Rule Logic with Model Classes</span></span>

<span data-ttu-id="13be0-196">検証とビジネス ルールのロジックは、データで動作する任意のアプリケーションの重要な部分を統合します。</span><span class="sxs-lookup"><span data-stu-id="13be0-196">Integrating validation and business rule logic is a key part of any application that works with data.</span></span>

#### <a name="schema-validation"></a><span data-ttu-id="13be0-197">スキーマの検証</span><span class="sxs-lookup"><span data-stu-id="13be0-197">Schema Validation</span></span>

<span data-ttu-id="13be0-198">LINQ to SQL デザイナーを使用してモデル クラスを定義したら、データ モデル クラス内のプロパティのデータ型は、データベース テーブルのデータ型に対応します。</span><span class="sxs-lookup"><span data-stu-id="13be0-198">When model classes are defined using the LINQ to SQL designer, the datatypes of the properties in the data model classes correspond to the datatypes of the database table.</span></span> <span data-ttu-id="13be0-199">例: Dinners テーブル内の"EventDate"列が"datetime"の場合は、LINQ to SQL によって作成されたデータ モデル クラスが型"DateTime"(つまり、組み込みの .NET データ型) になります。</span><span class="sxs-lookup"><span data-stu-id="13be0-199">For example: if the "EventDate" column in the Dinners table is a "datetime", the data model class created by LINQ to SQL will be of type "DateTime" (which is a built-in .NET datatype).</span></span> <span data-ttu-id="13be0-200">これにして、コードから整数またはブール値を割り当てようとして、エラーが発生、自動的に実行時に有効でない文字列型を暗黙的に変換しようとした場合にコンパイル エラーが発生することを意味します。</span><span class="sxs-lookup"><span data-stu-id="13be0-200">This means you will get compile errors if you attempt to assign an integer or boolean to it from code, and it will raise an error automatically if you attempt to implicitly convert a non-valid string type to it at runtime.</span></span>

<span data-ttu-id="13be0-201">どの保護に役立ちます SQL インジェクション攻撃からそれを使用する場合、文字列を使用するときに LINQ to SQL はするのも自動的に SQL のエスケープ値を処理します。</span><span class="sxs-lookup"><span data-stu-id="13be0-201">LINQ to SQL will also automatically handles escaping SQL values for you when using strings - which helps protect you against SQL injection attacks when using it.</span></span>

#### <a name="validation-and-business-rule-logic"></a><span data-ttu-id="13be0-202">検証とビジネス ルールのロジック</span><span class="sxs-lookup"><span data-stu-id="13be0-202">Validation and Business Rule Logic</span></span>

<span data-ttu-id="13be0-203">スキーマの検証は、最初の手順として役に立ちますが、ほとんどだけで十分です。</span><span class="sxs-lookup"><span data-stu-id="13be0-203">Schema validation is useful as a first step, but is rarely sufficient.</span></span> <span data-ttu-id="13be0-204">ほとんどの現実のシナリオを複数のプロパティにまたがる、コードを実行および多くの場合、モデルの状態を認識している高度な検証ロジックを指定する機能が必要 (例: が作成/更新/削除、またはドメイン固有の状態このような「アーカイブ」)。</span><span class="sxs-lookup"><span data-stu-id="13be0-204">Most real-world scenarios require the ability to specify richer validation logic that can span multiple properties, execute code, and often have awareness of a model's state (for example: is it being created /updated/deleted, or within a domain-specific state like "archived").</span></span> <span data-ttu-id="13be0-205">さまざまなさまざまなパターンや定義およびモデルのクラスに検証規則を適用するのに使用できるフレームワークがあるし、いくつか .NET ベースのフレームワークがこれを支援するために使用できます。</span><span class="sxs-lookup"><span data-stu-id="13be0-205">There are a variety of different patterns and frameworks that can be used to define and apply validation rules to model classes, and there are several .NET based frameworks out there that can be used to help with this.</span></span> <span data-ttu-id="13be0-206">ASP.NET MVC アプリケーション内でそれらのほぼすべてを使用することができます。</span><span class="sxs-lookup"><span data-stu-id="13be0-206">You can use pretty much any of them within ASP.NET MVC applications.</span></span>

<span data-ttu-id="13be0-207">NerdDinner アプリケーションのために、使用します比較的単純でわかりやすいパターン Dinner モデル オブジェクトで、IsValid プロパティと GetRuleViolations() メソッドを公開します場所。</span><span class="sxs-lookup"><span data-stu-id="13be0-207">For the purposes of our NerdDinner application, we'll use a relatively simple and straight-forward pattern where we expose an IsValid property and a GetRuleViolations() method on our Dinner model object.</span></span> <span data-ttu-id="13be0-208">True または false、検証とビジネス ルールがすべて有効かどうかに応じて、IsValid プロパティを返します。</span><span class="sxs-lookup"><span data-stu-id="13be0-208">The IsValid property will return true or false depending on whether the validation and business rules are all valid.</span></span> <span data-ttu-id="13be0-209">GetRuleViolations() メソッドでは、ルール エラーの一覧を返します。</span><span class="sxs-lookup"><span data-stu-id="13be0-209">The GetRuleViolations() method will return a list of any rule errors.</span></span>

<span data-ttu-id="13be0-210">「部分クラス」をプロジェクトに追加することで私たちの Dinner モデルの IsValid と GetRuleViolations() を実装します。</span><span class="sxs-lookup"><span data-stu-id="13be0-210">We'll implement IsValid and GetRuleViolations() for our Dinner model by adding a "partial class" to our project.</span></span> <span data-ttu-id="13be0-211">部分クラスは、(LINQ to SQL デザイナーによって生成された Dinner クラス) などの VS デザイナーによって管理されるクラスにメソッド/プロパティ/イベントを追加するために使用して、ツール、コードを使って時間を浪費するを回避します。</span><span class="sxs-lookup"><span data-stu-id="13be0-211">Partial classes can be used to add methods/properties/events to classes maintained by a VS designer (like the Dinner class generated by the LINQ to SQL designer) and help avoid the tool from messing with our code.</span></span> <span data-ttu-id="13be0-212">\Models フォルダーを右クリックして、プロジェクトに新しい部分クラスを追加し、「新しい項目の追加」メニュー コマンドを選択します。</span><span class="sxs-lookup"><span data-stu-id="13be0-212">We can add a new partial class to our project by right-clicking on the \Models folder, and then select the "Add New Item" menu command.</span></span> <span data-ttu-id="13be0-213">"新しい項目の追加 ダイアログ ボックスで、「クラス」のテンプレートを選択しを Dinner.cs という名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="13be0-213">We can then choose the "Class" template within the "Add New Item" dialog and name it Dinner.cs.</span></span>

![](build-a-model-with-business-rule-validations/_static/image11.png)

<span data-ttu-id="13be0-214">[追加] ボタンをクリックすると、Dinner.cs ファイルをプロジェクトに追加し、IDE 内で開くこと。</span><span class="sxs-lookup"><span data-stu-id="13be0-214">Clicking the "Add" button will add a Dinner.cs file to our project and open it within the IDE.</span></span> <span data-ttu-id="13be0-215">使用して基本的なルールの検証/強制フレームワークを実装できるし、次のコード。</span><span class="sxs-lookup"><span data-stu-id="13be0-215">We can then implement a basic rule/validation enforcement framework using the below code:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample10.cs)]

<span data-ttu-id="13be0-216">上記のコードに関するいくつかの注意:</span><span class="sxs-lookup"><span data-stu-id="13be0-216">A few notes about the above code:</span></span>

- <span data-ttu-id="13be0-217">Dinner クラスには、"partial"キーワード: つまりそれに含まれるコードは LINQ to SQL デザイナーによって生成された管理クラスを使用して結合し、1 つのクラスにコンパイルは付けません。</span><span class="sxs-lookup"><span data-stu-id="13be0-217">The Dinner class is prefaced with a "partial" keyword – which means the code contained within it will be combined with the class generated/maintained by the LINQ to SQL designer and compiled into a single class.</span></span>
- <span data-ttu-id="13be0-218">RuleViolation クラスは、規則違反に関する詳細を提供できるようにするプロジェクトに追加しますヘルパー クラスです。</span><span class="sxs-lookup"><span data-stu-id="13be0-218">The RuleViolation class is a helper class we'll add to the project that allows us to provide more details about a rule violation.</span></span>
- <span data-ttu-id="13be0-219">Dinner.GetRuleViolations() メソッドにより、検証とビジネス ルール評価される (すぐ実装にします)。</span><span class="sxs-lookup"><span data-stu-id="13be0-219">The Dinner.GetRuleViolations() method causes our validation and business rules to be evaluated (we'll implement them shortly).</span></span> <span data-ttu-id="13be0-220">返さ規則エラーの詳細を提供する RuleViolation オブジェクトのシーケンス。</span><span class="sxs-lookup"><span data-stu-id="13be0-220">It then returns back a sequence of RuleViolation objects that provide more details about any rule errors.</span></span>
- <span data-ttu-id="13be0-221">Dinner.IsValid プロパティは、Dinner オブジェクトが、アクティブな RuleViolations を持つかどうかを示す便利なヘルパー プロパティを提供します。</span><span class="sxs-lookup"><span data-stu-id="13be0-221">The Dinner.IsValid property provides a convenient helper property that indicates whether the Dinner object has any active RuleViolations.</span></span> <span data-ttu-id="13be0-222">Dinner オブジェクトを使用して、いつでも開発者によって事前にチェックすることができます (および例外は発生しません)。</span><span class="sxs-lookup"><span data-stu-id="13be0-222">It can be proactively checked by a developer using the Dinner object at anytime (and does not raise an exception).</span></span>
- <span data-ttu-id="13be0-223">Dinner.OnValidate() 部分メソッドは、Dinner オブジェクトがデータベース内で永続化するときにいつでも通知できるようにする LINQ to SQL を提供するフックです。</span><span class="sxs-lookup"><span data-stu-id="13be0-223">The Dinner.OnValidate() partial method is a hook that LINQ to SQL provides that allows us to be notified anytime the Dinner object is about to be persisted within the database.</span></span> <span data-ttu-id="13be0-224">上記 OnValidate() 実装により、Dinner はない RuleViolations 保存されるまで。</span><span class="sxs-lookup"><span data-stu-id="13be0-224">Our OnValidate() implementation above ensures that the Dinner has no RuleViolations before it is saved.</span></span> <span data-ttu-id="13be0-225">無効な状態である場合は、LINQ to SQL トランザクションを中止すると、例外を生成します。</span><span class="sxs-lookup"><span data-stu-id="13be0-225">If it is in an invalid state it raises an exception, which will cause LINQ to SQL to abort the transaction.</span></span>

<span data-ttu-id="13be0-226">このアプローチでは、検証とにビジネス ルールと統合できるシンプルなフレームワークを提供します。</span><span class="sxs-lookup"><span data-stu-id="13be0-226">This approach provides a simple framework that we can integrate validation and business rules into.</span></span> <span data-ttu-id="13be0-227">ここでは追加、GetRuleViolations() 方法では、ルールの下。</span><span class="sxs-lookup"><span data-stu-id="13be0-227">For now let's add the below rules to our GetRuleViolations() method:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample11.cs)]

<span data-ttu-id="13be0-228">C# の"yield return"機能は使用 RuleViolations 任意のシーケンスを返します。</span><span class="sxs-lookup"><span data-stu-id="13be0-228">We are using the "yield return" feature of C# to return a sequence of any RuleViolations.</span></span> <span data-ttu-id="13be0-229">上記の最初の 6 つのルール チェックは、null または空の文字列プロパティ、夕食がすることはできませんを適用します。</span><span class="sxs-lookup"><span data-stu-id="13be0-229">The first six rule checks above simply enforce that string properties on our Dinner cannot be null or empty.</span></span> <span data-ttu-id="13be0-230">前回のルールは、もう少し興味深いと呼び出しを追加できることを確認するには、このプロジェクトに、ContactPhone PhoneValidator.IsValidNumber() ヘルパー メソッドの番号形式と一致する Dinner の国。</span><span class="sxs-lookup"><span data-stu-id="13be0-230">The last rule is a little more interesting, and calls a PhoneValidator.IsValidNumber() helper method that we can add to our project to verify that the ContactPhone number format matches the Dinner's country.</span></span>

<span data-ttu-id="13be0-231">使用できます。このサポートの電話番号の検証を実装するために NET の正規表現のサポート。</span><span class="sxs-lookup"><span data-stu-id="13be0-231">We can use .NET's regular expression support to implement this phone validation support.</span></span> <span data-ttu-id="13be0-232">追加する単純な PhoneValidator 実装を次に示します、プロジェクトで、国固有の正規表現パターンのチェックを追加することにします。</span><span class="sxs-lookup"><span data-stu-id="13be0-232">Below is a simple PhoneValidator implementation that we can add to our project that enables us to add country-specific Regex pattern checks:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample12.cs)]

#### <a name="handling-validation-and-business-logic-violations"></a><span data-ttu-id="13be0-233">処理の検証とビジネス ロジックの違反</span><span class="sxs-lookup"><span data-stu-id="13be0-233">Handling Validation and Business Logic Violations</span></span>

<span data-ttu-id="13be0-234">上の検証とビジネス ルールのコードで作成または更新を夕食をいつでも追加しました、これで、検証ロジックの規則が評価され、適用されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-234">Now that we've added the above validation and business rule code, any time we try to create or update a Dinner, our validation logic rules will be evaluated and enforced.</span></span>

<span data-ttu-id="13be0-235">開発者は、事前に決定する Dinner オブジェクトは、有効なかどうかに次のようなコードし、すべての例外は生成せずにすべての違反の一覧を取得を記述できます。</span><span class="sxs-lookup"><span data-stu-id="13be0-235">Developers can write code like below to proactively determine if a Dinner object is valid, and retrieve a list of all violations in it without raising any exceptions:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample13.cs)]

<span data-ttu-id="13be0-236">無効な状態で、夕食を保存しようとしましたがある場合、ときは必ず DinnerRepository の Save() メソッドを呼び出すと例外が生成されます。</span><span class="sxs-lookup"><span data-stu-id="13be0-236">If we attempt to save a Dinner in an invalid state, an exception will be raised when we call the Save() method on the DinnerRepository.</span></span> <span data-ttu-id="13be0-237">これは、LINQ to SQL は、Dinner の変更を保存して、夕食に規則違反が存在しない場合は、例外を発生させる Dinner.OnValidate() にコードを追加しました前に自動的に、Dinner.OnValidate() 部分メソッドを呼び出すために発生します。</span><span class="sxs-lookup"><span data-stu-id="13be0-237">This occurs because LINQ to SQL automatically calls our Dinner.OnValidate() partial method before it saves the Dinner's changes, and we added code to Dinner.OnValidate() to raise an exception if any rule violations exist in the Dinner.</span></span> <span data-ttu-id="13be0-238">この例外をキャッチして事後対応的に修正する違反の一覧を取得します。</span><span class="sxs-lookup"><span data-stu-id="13be0-238">We can catch this exception and reactively retrieve a list of the violations to fix:</span></span>

[!code-csharp[Main](build-a-model-with-business-rule-validations/samples/sample14.cs)]

<span data-ttu-id="13be0-239">UI 層内ではなく、モデル レイヤー内で、検証とビジネス ルールが実装されるためが適用され、アプリケーション内のすべてのシナリオを使用します。</span><span class="sxs-lookup"><span data-stu-id="13be0-239">Because our validation and business rules are implemented within our model layer, and not within the UI layer, they will be applied and used across all scenarios within our application.</span></span> <span data-ttu-id="13be0-240">後で変更してまたはビジネス ルールの追加を Dinner オブジェクトとの連携がそれを利用しているすべてのコードがあります。</span><span class="sxs-lookup"><span data-stu-id="13be0-240">We can later change or add business rules and have all code that works with our Dinner objects honor them.</span></span>

<span data-ttu-id="13be0-241">1 か所でビジネス ルールを変更する柔軟性を持ち、これらの変更、アプリケーションと、UI ロジック全体に広がる必要はありませんは、適切に記述されたアプリケーションと、MVC フレームワークでは、推奨するのに役立ちの特典。</span><span class="sxs-lookup"><span data-stu-id="13be0-241">Having the flexibility to change business rules in one place, without having these changes ripple throughout the application and UI logic, is a sign of a well-written application, and a benefit that an MVC framework helps encourage.</span></span>

### <a name="next-step"></a><span data-ttu-id="13be0-242">次の手順</span><span class="sxs-lookup"><span data-stu-id="13be0-242">Next Step</span></span>

<span data-ttu-id="13be0-243">モデルのクエリし、データベースを更新するために使用できるようになりましたね。</span><span class="sxs-lookup"><span data-stu-id="13be0-243">We've now got a model that we can use to both query and update our database.</span></span>

<span data-ttu-id="13be0-244">みましょういくつかのコント ローラーとビューを追加を使用して、その周囲の HTML UI エクスペリエンスをビルドするプロジェクト。</span><span class="sxs-lookup"><span data-stu-id="13be0-244">Let's now add some controllers and views to the project that we can use to build an HTML UI experience around it.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="13be0-245">[前へ](create-a-database.md)
> [次へ](use-controllers-and-views-to-implement-a-listingdetails-ui.md)</span><span class="sxs-lookup"><span data-stu-id="13be0-245">[Previous](create-a-database.md)
[Next](use-controllers-and-views-to-implement-a-listingdetails-ui.md)</span></span>
