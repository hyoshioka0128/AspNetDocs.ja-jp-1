---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: 大量のデータを効率的にページングするC#() |Microsoft Docs
author: rick-anderson
description: データ表示コントロールの既定のページングオプションは、大量のデータを操作する場合は、基になるデータソースコントロール retriev...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: a3e9562035cb24987b01fcdff5fbfb5fa8a1f894
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78477010"
---
# <a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="fd6fd-103">大量のデータを効率的にページングする (C#)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>

<span data-ttu-id="fd6fd-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="fd6fd-105">[サンプルアプリのダウンロード](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe)または[PDF のダウンロード](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="fd6fd-106">データ表示コントロールの既定のページングオプションは、データのサブセットのみが表示されている場合でも、基になるデータソースコントロールによってすべてのレコードが取得されるため、大量のデータを処理する場合には適していません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="fd6fd-107">このような状況では、カスタムページングを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="fd6fd-108">はじめに</span><span class="sxs-lookup"><span data-stu-id="fd6fd-108">Introduction</span></span>

<span data-ttu-id="fd6fd-109">前のチュートリアルで説明したように、ページングは次の2つの方法のいずれかで実装できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="fd6fd-110">**既定のページング**は、データ Web コントロール s スマートタグの [ページングの有効化] オプションをオンにするだけで実装できます。ただし、データページを表示するたびに、ObjectDataSource によって*すべて*のレコードが取得されますが、それらのサブセットのみがページに表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="fd6fd-111">**カスタムページング**を使用すると、ユーザーによって要求されたデータの特定のページに表示する必要があるレコードだけをデータベースから取得することで、既定のページングのパフォーマンスが向上します。ただし、カスタムページングでは、既定のページングよりも実装に多少の労力が必要になります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="fd6fd-112">実装が簡単であるため、チェックボックスをオンにするだけで完了です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="fd6fd-113">既定のページングは魅力的なオプションです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-113">default paging is an attractive option.</span></span> <span data-ttu-id="fd6fd-114">ただし、すべてのレコードを取得するには、na ve アプローチを使用します。これは、大量のデータをページングする場合、または多数の同時実行ユーザーがいるサイトに対しては、信じの選択になります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="fd6fd-115">このような状況では、応答性の高いシステムを提供するために、カスタムページングを有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="fd6fd-116">カスタムページングの課題は、データの特定のページに必要なレコードの正確なセットを返すクエリを記述できることです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="fd6fd-117">幸い Microsoft SQL Server 2005 では、結果の順位付けに新しいキーワードが提供されているため、レコードの適切なサブセットを効率的に取得するためのクエリを作成できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="fd6fd-118">このチュートリアルでは、この新しい SQL Server 2005 キーワードを使用して、GridView コントロールにカスタムページングを実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="fd6fd-119">カスタムページング用のユーザーインターフェイスは、既定のページングの場合と同じですが、カスタムページングを使用して1つのページから次のページにステップインすると、既定のページングよりもはるかに高速に処理されることがあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="fd6fd-120">カスタムページングによって発生する実際のパフォーマンスの向上は、ページングされているレコードの総数と、データベースサーバーへの負荷の発生回数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="fd6fd-121">このチュートリアルの最後では、カスタムページングを通じて得られるパフォーマンスの利点を示す、いくつかの大まかなメトリックについて説明します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="fd6fd-122">手順 1: カスタムページングプロセスを理解する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="fd6fd-123">データをページングする場合、ページに表示される正確なレコードは、要求されているデータのページと、ページごとに表示されるレコードの数によって異なります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="fd6fd-124">たとえば、ページごとに10個の製品を表示して81製品を使用するとします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="fd6fd-125">最初のページを表示するときは、製品 1 ~ 10 が必要です。2番目のページを表示する場合は、製品 11 ~ 20 を対象としています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="fd6fd-126">取得する必要があるレコードと、ページングインターフェイスをどのようにレンダリングするかを決定する変数が3つあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="fd6fd-127">**開始行インデックス**表示するデータページの最初の行のインデックス。このインデックスを計算するには、ページインデックスに、ページごとに表示するレコードを乗算して追加します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="fd6fd-128">たとえば、一度に10個のレコードを使用してページングを実行する場合、最初のページ (ページインデックスは 0) では、開始行インデックスは 0 \* 10 + 1 または1になります。2番目のページ (ページインデックスが 1) の場合、開始行インデックスは 1 \* 10 + 1、または11です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="fd6fd-129">**[最大行数]** ページごとに表示するレコードの最大数。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="fd6fd-130">最後のページでは、ページサイズよりも多くのレコードが返される可能性があるため、この変数は最大行数と呼ばれます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="fd6fd-131">たとえば、ページごとに81製品10件のレコードをページングする場合、9番目と最後のページには1つのレコードのみが表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="fd6fd-132">ただし、ページがない場合は、[最大行数] の値よりも多くのレコードが表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="fd6fd-133">**合計レコード数**ページングされているレコードの合計数。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="fd6fd-134">この変数は、特定のページに対して取得するレコードを決定するために必要ではありませんが、ページングインターフェイスを決定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="fd6fd-135">たとえば、81製品がページングされている場合、ページングインターフェイスはページング UI に9ページの番号を表示することを認識します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="fd6fd-136">既定のページングでは、開始行インデックスは、ページインデックスとページサイズの積として計算されます。一方、最大行数は単にページサイズになります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="fd6fd-137">既定のページングでは、データのページを表示するときに、データベースからすべてのレコードが取得されるため、各行のインデックスが認識されるため、開始行のインデックス行を簡単なタスクに移動できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="fd6fd-138">さらに、レコード数の合計はすぐに使用できます。これは、DataTable 内のレコードの数 (または、データベースの結果を保持するために使用されている任意のオブジェクト) にすぎません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="fd6fd-139">開始行インデックスと最大行数変数を指定した場合、カスタムページングの実装では、先頭行のインデックスから始まるレコードの正確なサブセットと、その後の最大行数までのレコードのみを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="fd6fd-140">カスタムページングには2つの課題があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="fd6fd-141">行インデックスは、ページングされているデータ全体の各行に効率的に関連付ける必要があります。これにより、指定された開始行インデックスでレコードを返すことができます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="fd6fd-142">ページングされているレコードの合計数を指定する必要があります</span><span class="sxs-lookup"><span data-stu-id="fd6fd-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="fd6fd-143">次の2つの手順では、これら2つの課題に対応するために必要な SQL スクリプトを確認します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="fd6fd-144">SQL スクリプトに加えて、DAL および BLL でメソッドを実装する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="fd6fd-145">手順 2: ページングされているレコードの合計数を取得する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="fd6fd-146">表示されるページのレコードの正確なサブセットを取得する方法を確認する前に、まず、ページングされているレコードの合計数を取得する方法を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="fd6fd-147">この情報は、ページングユーザーインターフェイスを適切に構成するために必要です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="fd6fd-148">特定の SQL クエリによって返されるレコードの合計数は、 [`COUNT` 集計関数](https://msdn.microsoft.com/library/ms175997.aspx)を使用して取得できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="fd6fd-149">たとえば、`Products` テーブル内のレコードの合計数を確認するには、次のクエリを使用します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="fd6fd-150">この情報を返すメソッドを DAL に追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="fd6fd-151">特に、前に示した `SELECT` ステートメントを実行する `TotalNumberOfProducts()` という DAL メソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="fd6fd-152">まず、`App_Code/DAL` フォルダー内の `Northwind.xsd` 型指定されたデータセットファイルを開きます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="fd6fd-153">次に、デザイナーで `ProductsTableAdapter` を右クリックし、[クエリの追加] を選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="fd6fd-154">前のチュートリアルで説明したように、これにより、新しいメソッドを DAL に追加することができます。このメソッドを呼び出すと、特定の SQL ステートメントまたはストアドプロシージャが実行されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="fd6fd-155">この記事では、前のチュートリアルの TableAdapter メソッドと同様に、アドホック SQL ステートメントを使用することを選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![アドホック SQL ステートメントを使用する](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="fd6fd-157">**図 1**: アドホック SQL ステートメントを使用する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="fd6fd-158">次の画面で、作成するクエリの種類を指定できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="fd6fd-159">このクエリは単一のスカラー値を返すので、`Products` テーブルのレコードの合計数は、1つの値オプションを返す `SELECT` を選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![1つの値を返す SELECT ステートメントを使用するようにクエリを構成する](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="fd6fd-161">**図 2**: 単一の値を返す SELECT ステートメントを使用するようにクエリを構成する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="fd6fd-162">使用するクエリの種類を指定したら、次にクエリを指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-162">After indicating the type of query to use, we must next specify the query.</span></span>

![SELECT COUNT (\*) FROM Products クエリ](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="fd6fd-164">**図 3**: PRODUCTS クエリからの SELECT COUNT (\*) の使用</span><span class="sxs-lookup"><span data-stu-id="fd6fd-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="fd6fd-165">最後に、メソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="fd6fd-166">前述のように、では `TotalNumberOfProducts`を使用します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![DAL メソッドに TotalNumberOfProducts という名前を指定する](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="fd6fd-168">**図 4**: DAL メソッド TotalNumberOfProducts に名前を指定する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="fd6fd-169">[完了] をクリックすると、ウィザードによって `TotalNumberOfProducts` メソッドが DAL に追加されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="fd6fd-170">DAL 内のスカラーを返すメソッドは、SQL クエリの結果が `NULL`場合に、null 許容型を返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="fd6fd-171">ただし、`COUNT` クエリでは、常に`NULL` 以外の値が返されます。とは無関係に、DAL メソッドは null 許容の整数を返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="fd6fd-172">DAL メソッドに加えて、BLL にもメソッドが必要です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="fd6fd-173">`ProductsBLL` クラスファイルを開き、次のように DAL の `TotalNumberOfProducts` メソッドに単にを呼び出して、`TotalNumberOfProducts` メソッドを追加します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="fd6fd-174">DAL の `TotalNumberOfProducts` メソッドは、null 許容の整数を返します。ただし、`ProductsBLL` クラス s `TotalNumberOfProducts` メソッドを作成して、標準の整数を返すようにしました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="fd6fd-175">したがって、`ProductsBLL` クラスの `TotalNumberOfProducts` メソッドは、DAL の `TotalNumberOfProducts` メソッドによって返される null 許容の整数の値部分を返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="fd6fd-176">`GetValueOrDefault()` を呼び出すと、null 値が許容される整数 (存在する場合) の値が返されます。ただし、null 許容の整数が `null`場合は、既定の整数値0が返されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="fd6fd-177">手順 3: レコードの正確なサブセットを取得する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="fd6fd-178">次のタスクでは、DAL でメソッドを作成します。このメソッドは、前に説明した行の開始インデックスと最大行数変数を受け取り、適切なレコードを返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="fd6fd-179">これを行う前に、まず必要な SQL スクリプトを見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="fd6fd-180">私たちが直面する課題は、開始行のインデックス (およびレコードの最大数) で開始されたレコードだけを返すことができるように、結果全体の行にインデックスを効率的に割り当てることができることです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="fd6fd-181">これは、データベーステーブルに行インデックスとして機能する列が既に存在する場合は問題になりません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="fd6fd-182">一見すると、最初の製品の `ProductID` が1、2番目の製品が2であるため、`Products` table s `ProductID` フィールドには十分であると考えられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="fd6fd-183">ただし、製品を削除すると、シーケンスのギャップが残りますので、この方法は無効化です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="fd6fd-184">行インデックスをデータに効率的に関連付けるために使用される一般的な手法には、次の2つがあります。これにより、レコードの正確なサブセットを取得できるようになります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="fd6fd-185">`ROW_NUMBER()` キーワードを**使用して SQL Server 2005 s `ROW_NUMBER()`** SQL Server 2005 に新しいキーワードを使用すると、順序付けに基づいて、返された各レコードに順位が関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="fd6fd-186">この順位付けは、各行の行インデックスとして使用できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="fd6fd-187">**テーブル変数と `SET ROWCOUNT`の使用**SQL Server s [`SET ROWCOUNT` ステートメント](https://msdn.microsoft.com/library/ms188774.aspx)を使用すると、クエリが終了する前に処理する必要があるレコードの合計数を指定できます。[テーブル変数](http://www.sqlteam.com/item.asp?ItemID=9454)は、[一時テーブル](http://www.sqlteam.com/item.asp?ItemID=2029)に似た表形式データを保持できるローカル t-sql 変数です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="fd6fd-188">このアプローチは、Microsoft SQL Server 2005 と SQL Server 2000 の両方で同様に機能します (一方、`ROW_NUMBER()` アプローチは SQL Server 2005 でのみ機能します)。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="fd6fd-189">ここでの考え方は、データがページングされているテーブルの主キーに対して、`IDENTITY` の列と列を持つテーブル変数を作成することです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="fd6fd-190">次に、データがページングされているテーブルの内容がテーブル変数にダンプされます。これにより、テーブル内の各レコードに対して (`IDENTITY` 列を介して) 連続する行インデックスが関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="fd6fd-191">テーブル変数に値が設定されると、基になるテーブルと結合されたテーブル変数の `SELECT` ステートメントを実行して、特定のレコードを取得できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="fd6fd-192">`SET ROWCOUNT` ステートメントを使用して、テーブル変数にダンプする必要があるレコードの数をインテリジェントに制限します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="fd6fd-193">この方法の効率は、要求されているページ番号に基づいています。 `SET ROWCOUNT` 値には、開始行インデックスと最大行数の値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="fd6fd-194">データの最初のいくつかのページなど、番号の小さいページを使用してページングを行う場合、この方法は非常に効率的です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="fd6fd-195">ただし、最後の近くにページを取得すると、既定のページングのようなパフォーマンスが示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="fd6fd-196">このチュートリアルでは、`ROW_NUMBER()` キーワードを使用してカスタムページングを実装します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="fd6fd-197">テーブル変数と `SET ROWCOUNT` 手法の使用方法の詳細については、[大きな結果セットを使用したページングのより効率的な方法](http://www.4guysfromrolla.com/webtech/042606-1.shtml)に関するページを参照してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="fd6fd-198">`ROW_NUMBER()` キーワードは、次の構文を使用して、特定の順序で返される各レコードの順位付けに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="fd6fd-199">`ROW_NUMBER()` は、指定された順序に関して各レコードのランクを指定する数値を返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="fd6fd-200">たとえば、各製品の順位を最も高価なものから順に確認するには、次のクエリを使用します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="fd6fd-201">図5に、Visual Studio のクエリウィンドウで実行した場合のクエリの結果を示します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="fd6fd-202">製品は、各行の価格と共に価格で並べ替えられていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![返されたレコードごとに価格順位が含まれます。](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="fd6fd-204">**図 5**: 返されたレコードごとに価格順位が含まれる</span><span class="sxs-lookup"><span data-stu-id="fd6fd-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="fd6fd-205">`ROW_NUMBER()` は SQL Server 2005 で利用できる多くの新しい順位付け関数の1つにすぎません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="fd6fd-206">`ROW_NUMBER()`とその他の順位付け関数の詳細については、「 [Microsoft SQL Server 2005 を使用して順位](http://www.4guysfromrolla.com/webtech/010406-1.shtml)付けされた結果を返す」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="fd6fd-207">`OVER` 句の指定した `ORDER BY` 列 (上記の例では`UnitPrice`) によって結果に順位を付けた場合、SQL Server は結果を並べ替える必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="fd6fd-208">これは、結果が並べ替えられている列にクラスター化インデックスがある場合、またはカバリングインデックスがある場合は、簡単な操作ですが、それ以外の場合はコストが高くなる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="fd6fd-209">十分に大きなクエリのパフォーマンスを向上させるには、結果の並べ替えに使用する列に非クラスター化インデックスを追加することを検討してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="fd6fd-210">パフォーマンスに関する考慮事項の詳細については、「 [SQL Server 2005 の順位付け関数とパフォーマンス](http://www.sql-server-performance.com/ak_ranking_functions.asp)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="fd6fd-211">`ROW_NUMBER()` によって返される順位付け情報は、`WHERE` 句で直接使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="fd6fd-212">ただし、派生テーブルを使用して `ROW_NUMBER()` の結果を返すことができます。これは、`WHERE` 句に記述できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="fd6fd-213">たとえば、次のクエリでは、派生テーブルを使用して、ProductName 列と UnitPrice 列を返し、`ROW_NUMBER()` 結果と共に、`WHERE` 句を使用して、価格順位が 11 ~ 20 の製品のみを返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="fd6fd-214">この概念をさらに拡張すると、この方法を使用して、目的の開始行インデックスと最大行数値を指定して、特定のデータページを取得できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="fd6fd-215">このチュートリアルで後ほど説明するように、ObjectDataSource によって提供される *`StartRowIndex`* は0から始まるインデックスが作成されますが、SQL Server 2005 によって返される `ROW_NUMBER()` 値のインデックスは1から始まります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="fd6fd-216">したがって、`WHERE` 句は、`PriceRank` が *`StartRowIndex`* より厳密に大きく、 *`StartRowIndex`*  +  *`MaximumRows`* 以下であるレコードを返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="fd6fd-217">ここでは、`ROW_NUMBER()` を使用してデータの特定のページを取得する方法について説明しました。開始行インデックスと最大行数の値を指定して、このロジックを DAL および BLL のメソッドとして実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="fd6fd-218">このクエリを作成するときは、結果の順位付け順序を決める必要があります。製品の名前をアルファベット順に並べ替えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="fd6fd-219">これは、このチュートリアルのカスタムページング実装では、並べ替えを行うこともできないカスタムページングレポートを作成できないことを意味します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="fd6fd-220">次のチュートリアルでは、このような機能を提供する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="fd6fd-221">前のセクションでは、DAL メソッドをアドホック SQL ステートメントとして作成しました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="fd6fd-222">残念ながら、TableAdapter ウィザードで使用される Visual Studio の T-sql パーサーは、`ROW_NUMBER()` 関数で使用される `OVER` 構文とはまったく同じではありません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="fd6fd-223">このため、この DAL メソッドはストアドプロシージャとして作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="fd6fd-224">[表示] メニューからサーバーエクスプローラーを選択して (または Ctrl + Alt + S キーを押して)、[`NORTHWND.MDF`] ノードを展開します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="fd6fd-225">新しいストアドプロシージャを追加するには、[ストアドプロシージャ] ノードを右クリックし、[新しいストアドプロシージャの追加] を選択します (図6を参照)。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![製品のページング用に新しいストアドプロシージャを追加する](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="fd6fd-227">**図 6**: 製品を使用したページング用の新しいストアドプロシージャの追加</span><span class="sxs-lookup"><span data-stu-id="fd6fd-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="fd6fd-228">このストアドプロシージャは、2つの整数入力パラメーター (`@startRowIndex` と `@maximumRows` を受け入れ、`ProductName` フィールドによって並べ替えられた `ROW_NUMBER()` 関数を使用して、指定した `@startRowIndex` を超える行と `@startRowIndex` + `@maximumRow` 以下の行だけを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="fd6fd-229">新しいストアドプロシージャに次のスクリプトを入力し、[保存] アイコンをクリックして、ストアドプロシージャをデータベースに追加します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="fd6fd-230">ストアドプロシージャを作成した後、すぐにテストしてみてください。サーバーエクスプローラーで `GetProductsPaged` ストアドプロシージャ名を右クリックし、[実行] オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="fd6fd-231">その後、Visual Studio によって入力パラメーターの入力が求められ、`@startRowIndex` と `@maximumRow` s が表示されます (図7を参照)。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="fd6fd-232">異なる値を試し、結果を確認します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-232">Try different values and examine the results.</span></span>

![@startRowIndex パラメーターと @maximumRows パラメーターの値を入力してください](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="fd6fd-234"><strong>図 7</strong>: @startRowIndex と @maximumRows パラメーターの値を入力する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="fd6fd-235">これらの入力パラメーター値を選択すると、出力ウィンドウに結果が表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="fd6fd-236">図8は、`@startRowIndex` と `@maximumRows` の両方のパラメーターに対して10を渡した場合の結果を示しています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="fd6fd-237">[データの2ページ目に表示されるレコード ![返されます。](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="fd6fd-238">**図 8**: データの2番目のページに表示されるレコードが返されます ([クリックすると、フルサイズの画像が表示](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png)されます)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>

<span data-ttu-id="fd6fd-239">このストアドプロシージャを作成したので、`ProductsTableAdapter` メソッドを作成する準備ができました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="fd6fd-240">`Northwind.xsd` 型指定されたデータセットを開き、`ProductsTableAdapter`を右クリックして、[クエリの追加] オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="fd6fd-241">アドホック SQL ステートメントを使用してクエリを作成する代わりに、既存のストアドプロシージャを使用してクエリを作成します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![既存のストアドプロシージャを使用した DAL メソッドの作成](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="fd6fd-243">**図 9**: 既存のストアドプロシージャを使用して DAL メソッドを作成する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="fd6fd-244">次に、呼び出すストアドプロシージャを選択するように求められます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="fd6fd-245">ドロップダウンリストから `GetProductsPaged` ストアドプロシージャを選択します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![ドロップダウンリストから [GetProductsPaged 切れ] ストアドプロシージャを選択します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="fd6fd-247">**図 10**: ドロップダウンリストから GetProductsPaged 切れストアドプロシージャを選択する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="fd6fd-248">次の画面では、ストアドプロシージャによって返されるデータの種類 (表形式データ、単一値、値なし) を求められます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="fd6fd-249">`GetProductsPaged` ストアドプロシージャは複数のレコードを返すことができるため、表形式のデータを返すことを示します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![ストアドプロシージャが表形式データを返すことを示します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="fd6fd-251">**図 11**: ストアドプロシージャが表形式データを返すことを示す</span><span class="sxs-lookup"><span data-stu-id="fd6fd-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="fd6fd-252">最後に、作成するメソッドの名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="fd6fd-253">前のチュートリアルと同様に、DataTable への Fill と DataTable の両方を使用してメソッドを作成します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="fd6fd-254">最初のメソッド `FillPaged` と2番目の `GetProductsPaged`の名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![メソッドに FillPaged と GetProductsPaged 切れの名前を指定します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="fd6fd-256">**図 12**: メソッドに fillpaged と GetProductsPaged 切れの名前を指定する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="fd6fd-257">DAL メソッドを作成して製品の特定のページを返すだけでなく、BLL にもそのような機能を提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="fd6fd-258">DAL メソッドと同様に、BLL s GetProductsPaged 切れのメソッドは、開始行インデックスと最大行数を指定するために2つの整数入力を受け取る必要があり、指定された範囲内に収まるレコードだけを返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="fd6fd-259">このような BLL メソッドを Productbll クラスに作成します。このクラスは、次のように、DAL s GetProductsPaged 切れのメソッドに単にを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="fd6fd-260">BLL メソッドの入力パラメーターには任意の名前を使用できますが、このメソッドを使用するように ObjectDataSource を構成する場合は、後で `startRowIndex` を使用することを選択して `maximumRows` を追加して保存します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="fd6fd-261">手順 4: カスタムページングを使用するように ObjectDataSource を構成する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="fd6fd-262">特定のレコードのサブセットにアクセスするための BLL メソッドと DAL メソッドを使用すると、カスタムページングを使用して基になるレコードをページ化する GridView コントロールを作成できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="fd6fd-263">まず、`PagingAndSorting` フォルダーの [`EfficientPaging.aspx`] ページを開き、GridView をページに追加して、新しい ObjectDataSource コントロールを使用するように構成します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="fd6fd-264">これまでのチュートリアルでは、`ProductsBLL` クラス s `GetProducts` メソッドを使用するように ObjectDataSource が構成されていることがよくあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="fd6fd-265">ただし、ここでは、`GetProducts` メソッドがデータベース内の*すべて*の製品を返すのに対し、`GetProductsPaged` は特定のレコードのサブセットのみを返すため、代わりに `GetProductsPaged` メソッドを使用します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![Productbll クラス s GetProductsPaged 切れメソッドを使用するように ObjectDataSource を構成する](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="fd6fd-267">**図 13**: Productbll クラス s GetProductsPaged 切れメソッドを使用するように ObjectDataSource を構成する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="fd6fd-268">読み取り専用の GridView を作成しているため、[挿入]、[更新]、および [削除] タブの [メソッド] ドロップダウンリストを [(なし)] に設定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="fd6fd-269">次に、ObjectDataSource ウィザードによって、`GetProductsPaged` メソッドの `startRowIndex` のソースと `maximumRows` 入力パラメーターの値が要求されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="fd6fd-270">これらの入力パラメーターは、実際に GridView によって自動的に設定されるので、[ソース] を [なし] のままにし、[完了] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![入力パラメーターソースは None のままにします。](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="fd6fd-272">**図 14**: 入力パラメーターソースを [なし] のままにする</span><span class="sxs-lookup"><span data-stu-id="fd6fd-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="fd6fd-273">ObjectDataSource ウィザードを完了すると、GridView には各製品データフィールドの BoundField または CheckBoxField が含まれます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="fd6fd-274">必要に応じて、GridView の外観を自由に調整してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="fd6fd-275">`ProductName`、`CategoryName`、`SupplierName`、`QuantityPerUnit`、および `UnitPrice` BoundFields のみを表示するように選択しました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="fd6fd-276">また、そのスマートタグの [ページングを有効にする] チェックボックスをオンにして、ページングをサポートするように GridView を構成します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="fd6fd-277">これらの変更が完了すると、GridView および ObjectDataSource の宣言マークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="fd6fd-278">ただし、ブラウザーを使用してページにアクセスした場合、GridView は見つかりません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![GridView が表示されない](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="fd6fd-280">**図 15**: GridView が表示されない</span><span class="sxs-lookup"><span data-stu-id="fd6fd-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="fd6fd-281">ObjectDataSource が現在、両方の `GetProductsPaged` `startRowIndex` と `maximumRows` 入力パラメーターの値として0を使用しているため、GridView が見つかりません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="fd6fd-282">そのため、結果として得られる SQL クエリはレコードを返さないため、GridView は表示されません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="fd6fd-283">これを解決するには、カスタムページングを使用するように ObjectDataSource を構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="fd6fd-284">これは、次の手順で実現できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="fd6fd-285">**Objectdatasource s `EnablePaging` プロパティをに設定**します。これにより、`SelectMethod` 2 つの追加パラメーター (先頭行のインデックス ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) を指定するためのパラメーターと、最大行数を指定するパラメーター ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)) が `true`になります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="fd6fd-286">**ObjectDataSource s `StartRowIndexParameterName` と `MaximumRowsParameterName` プロパティを設定**します。これにより `StartRowIndexParameterName` および `MaximumRowsParameterName` プロパティは、カスタムページングのために `SelectMethod` に渡される入力パラメーターの名前を示します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="fd6fd-287">既定では、これらのパラメーター名は `startIndexRow` および `maximumRows`ます。そのため、BLL で `GetProductsPaged` メソッドを作成するときに、入力パラメーターとしてこれらの値を使用しました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="fd6fd-288">`startIndex` や `maxRows`など、BLL の `GetProductsPaged` メソッドに異なるパラメーター名を使用することを選択した場合は、ObjectDataSource s `StartRowIndexParameterName` および `MaximumRowsParameterName` の maxRows (`StartRowIndexParameterName` の場合は startIndex など) に適宜設定する必要があります。`MaximumRowsParameterName`</span><span class="sxs-lookup"><span data-stu-id="fd6fd-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="fd6fd-289">**ObjectDataSource s [`SelectCountMethod` プロパティ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)を、ページングされるレコードの総数 (`TotalNumberOfProducts`) を返すメソッドの名前に設定**します。 `ProductsBLL` クラス s `TotalNumberOfProducts` メソッドは、`SELECT COUNT(*) FROM Products` クエリを実行する DAL メソッドを使用して、ページングされているレコードの合計数を返します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="fd6fd-290">この情報は、ページングインターフェイスを正しく表示するために ObjectDataSource によって必要になります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="fd6fd-291">ウィザードを使用して ObjectDataSource を構成するときに**objectdatasource s 宣言マークアップから `startRowIndex` および `maximumRows` `<asp:Parameter>` 要素を削除すると**、Visual Studio によって、`GetProductsPaged` メソッドの入力パラメーターに対して2つの `<asp:Parameter>` 要素が自動的に追加されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="fd6fd-292">`EnablePaging` を `true`に設定すると、これらのパラメーターは自動的に渡されます。宣言構文にも含まれている場合、ObjectDataSource は、`GetProductsPaged` メソッドに*4*つのパラメーターを渡し、`TotalNumberOfProducts` メソッドに2つのパラメーターを渡すことを試みます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="fd6fd-293">これらの `<asp:Parameter>` 要素を削除し忘れた場合、ブラウザーを使用してページを閲覧すると、次のようなエラーメッセージが表示されます。 *ObjectDataSource ' ObjectDataSource1 ' は、パラメーター: startRowIndex, maximumRows を持つ非ジェネリックメソッド ' TotalNumberOfProducts ' を見つける*ことができませんでした。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="fd6fd-294">これらの変更を行った後、ObjectDataSource s 宣言構文は次のようになります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="fd6fd-295">`EnablePaging` と `SelectCountMethod` のプロパティが設定されており、`<asp:Parameter>` 要素が削除されていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="fd6fd-296">図16は、これらの変更が加えられた後のプロパティウィンドウのスクリーンショットを示しています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![カスタムページングを使用するには、ObjectDataSource コントロールを構成します。](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="fd6fd-298">**図 16**: カスタムページングを使用するには、ObjectDataSource コントロールを構成する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="fd6fd-299">これらの変更を行った後、ブラウザーを使用してこのページにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="fd6fd-300">10個の製品がアルファベット順に並べられて表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="fd6fd-301">一度に1ページずつデータをステップ実行します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="fd6fd-302">既定のページングとカスタムページングの間のエンドユーザーの視点とは視覚的な違いはありませんが、カスタムページングでは、特定のページに表示する必要があるレコードのみを取得するため、大量のデータをより効率的にページングできます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="fd6fd-303">[製品名によって並べ替えられたデータ ![、カスタムページングを使用してページングされます。](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="fd6fd-304">**図 17**: 製品名の順に並べられたデータは、カスタムページングを使用してページングされます ([クリックすると、フルサイズの画像が表示](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png)されます)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="fd6fd-305">カスタムページングでは、ObjectDataSource s `SelectCountMethod` によって返されるページ数の値は、GridView のビューステートに格納されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="fd6fd-306">その他の GridView 変数 `PageIndex`、`EditIndex`、`SelectedIndex`、`DataKeys` コレクションなどが、*コントロールの状態*に格納されます。これは、gridview の `EnableViewState` プロパティの値に関係なく保持されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="fd6fd-307">`PageCount` 値はビューステートを使用してポストバック間で永続化されるため、最後のページに移動するためのリンクを含むページングインターフェイスを使用する場合は、GridView のビューステートが有効になっている必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="fd6fd-308">(ページングインターフェイスに最後のページへの直接リンクが含まれていない場合は、ビューステートを無効にすることができます)。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="fd6fd-309">最後のページのリンクをクリックするとポストバックが発生し、その `PageIndex` プロパティを更新するように GridView に指示します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="fd6fd-310">最後のページのリンクがクリックされた場合、GridView は、その `PageIndex` プロパティを `PageCount` プロパティより1小さい値に割り当てます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="fd6fd-311">ビューステートが無効になっている場合、ポストバック間で `PageCount` 値は失われ、`PageIndex` には、代わりに最大の整数値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="fd6fd-312">次に、GridView は、`PageSize` と `PageCount` プロパティを乗算することによって、開始行インデックスを決定しようとします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="fd6fd-313">この結果、製品が許容される最大整数サイズを超えているため、`OverflowException` が発生します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="fd6fd-314">カスタムページングと並べ替えの実装</span><span class="sxs-lookup"><span data-stu-id="fd6fd-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="fd6fd-315">現在のカスタムページング実装では、`GetProductsPaged` ストアドプロシージャを作成するときに、データをページングする順序を静的に指定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="fd6fd-316">ただし、[ページングを有効にする] オプションに加えて、GridView のスマートタグに [並べ替えを有効にする] チェックボックスが含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="fd6fd-317">残念ながら、現在のカスタムページング実装を使用して GridView に並べ替えサポートを追加すると、現在表示されているデータページのレコードのみが並べ替えられます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="fd6fd-318">たとえば、ページングもサポートするように GridView を構成した場合、データの最初のページを表示するときに、製品名で降順に並べ替えて、ページ1で製品の順序を逆にします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="fd6fd-319">図18に示すように、この例では、アルファベットの逆順で並べ替えを行う場合の最初の製品として Carnarvon 虎を示しています。 Carnarvon 虎の後に続く71の他の製品はアルファベット順に表示されます。並べ替えでは、最初のページのレコードだけが考慮されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="fd6fd-320">[現在のページに表示されているデータのみが並べ替えられている ![](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="fd6fd-321">**図 18**: 現在のページに表示されているデータのみが並べ替えられている ([クリックすると、フルサイズの画像が表示](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png)されます)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>

<span data-ttu-id="fd6fd-322">並べ替えは、データの現在のページにのみ適用されます。これは、データが BLL s `GetProductsPaged` メソッドから取得された後に並べ替えが行われ、このメソッドが特定のページのレコードのみを返すためです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="fd6fd-323">並べ替えを正しく実装するには、データの特定のページを返す前にデータが適切に順位付けされるように、並べ替え式を `GetProductsPaged` メソッドに渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="fd6fd-324">これを実現する方法については、次のチュートリアルで説明します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="fd6fd-325">カスタムページングの実装と削除</span><span class="sxs-lookup"><span data-stu-id="fd6fd-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="fd6fd-326">カスタムページング手法を使用してデータがページングされている GridView で機能の削除を有効にすると、最後のページから最後のレコードを削除するときに、gridview の `PageIndex`を適切にデクリメントするのではなく、GridView が消えることがわかります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="fd6fd-327">このバグを再現するには、先ほど作成したチュートリアルの削除を有効にします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="fd6fd-328">最後のページ (ページ 9) に移動します。ここでは、81製品、一度に10個の製品を使用してページングを行っているため、1つの製品が表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="fd6fd-329">この製品を削除します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-329">Delete this product.</span></span>

<span data-ttu-id="fd6fd-330">最後の製品を*削除すると、GridView が*自動的に8番目のページに移り、そのような機能が既定のページングで表示されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="fd6fd-331">ただし、カスタムページングを使用すると、最後のページでその最後の製品を削除した後、GridView が画面から完全に消えるだけです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="fd6fd-332">これが発生する正確*な理由は、このチュートリアル*の範囲を超えています。この問題の原因については、詳細については、「[カスタムページングを使用して GridView から最後のページの最後のレコードを削除](http://scottonwriting.net/sowblog/posts/7326.aspx)する」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="fd6fd-333">概要では、[削除] ボタンがクリックされたときに GridView によって実行される次の一連の手順が原因です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="fd6fd-334">レコードを削除する</span><span class="sxs-lookup"><span data-stu-id="fd6fd-334">Delete the record</span></span>
2. <span data-ttu-id="fd6fd-335">指定された `PageIndex` とに表示する適切なレコードを取得し `PageSize`</span><span class="sxs-lookup"><span data-stu-id="fd6fd-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="fd6fd-336">`PageIndex` がデータソース内のデータのページ数を超えていないことを確認します。存在する場合は、GridView の `PageIndex` プロパティを自動的にデクリメントします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="fd6fd-337">手順2で取得したレコードを使用して、データの適切なページを GridView にバインドします。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="fd6fd-338">問題の原因は、手順 2. で表示するレコードを取得するときに使用された `PageIndex` が、単に削除されたばかりのレコードを持つ最後のページの `PageIndex` であるということです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="fd6fd-339">したがって、手順 2. では、データの最後のページにレコードが含まれていないため、レコードは返され*ません*。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="fd6fd-340">次に、手順3では、GridView によって、`PageIndex` のプロパティがデータソース内のページの合計数 (最後のページの最後のレコードを削除したため) を超えていることが認識されます。そのため、`PageIndex` プロパティがデクリメントされます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="fd6fd-341">手順4では、GridView は、手順 2. で取得したデータにそれ自体をバインドしようとします。ただし、手順2ではレコードが返されませんでした。その結果、GridView が空になります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="fd6fd-342">既定のページングでは、手順 2. で*すべて*のレコードがデータソースから取得されるため、この問題は表面化しません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="fd6fd-343">この問題を解決するには、2つのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-343">To fix this we have two options.</span></span> <span data-ttu-id="fd6fd-344">1つ目は、削除されたばかりのページに表示されるレコードの数を決定する GridView s `RowDeleted` イベントハンドラーのイベントハンドラーを作成することです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="fd6fd-345">レコードが1つしかない場合は、削除したばかりのレコードが最後のレコードである必要があります。また、GridView の `PageIndex`を減らす必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="fd6fd-346">もちろん、削除操作が実際に成功した場合にのみ、`PageIndex` を更新する必要があります。これは、`e.Exception` プロパティが `null`されていることを確認することによって決定できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="fd6fd-347">この方法は、手順1の後、手順 2. の前に `PageIndex` を更新するため、機能します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="fd6fd-348">したがって、手順 2. では、適切なレコードセットが返されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="fd6fd-349">これを実現するには、次のようなコードを使用します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-349">To accomplish this, use code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="fd6fd-350">別の回避策として、ObjectDataSource s `RowDeleted` イベントのイベントハンドラーを作成し、`AffectedRows` プロパティを1の値に設定します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="fd6fd-351">手順 1. でレコードを削除した後 (ただし、手順2でデータを再取得する前)、その操作によって1つ以上の行が影響を受けた場合、GridView によって `PageIndex` プロパティが更新されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="fd6fd-352">ただし、`AffectedRows` プロパティは ObjectDataSource によって設定されないため、この手順は省略されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="fd6fd-353">このステップを実行する方法の1つとして、削除操作が正常に完了した場合に `AffectedRows` プロパティを手動で設定する方法があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="fd6fd-354">これは、次のようなコードを使用して実現できます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-354">This can be accomplished using code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="fd6fd-355">これらのイベントハンドラーの両方のコードは、`EfficientPaging.aspx` の例の分離コードクラスに記載されています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="fd6fd-356">既定のページングとカスタムページングのパフォーマンスの比較</span><span class="sxs-lookup"><span data-stu-id="fd6fd-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="fd6fd-357">カスタムページングは必要なレコードのみを取得するため、既定のページングでは、表示される各ページの*すべて*のレコードが返されるので、カスタムページングは既定のページングよりも効率的であることがわかります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="fd6fd-358">しかし、カスタムページングはどの程度効率的ですか。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="fd6fd-359">既定のページングからカスタムページングに移行すると、どのようなパフォーマンスの向上が見られますか。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="fd6fd-360">残念ながら、ここでは1つのサイズがすべての回答に適合しているわけではありません。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="fd6fd-361">パフォーマンスの向上は、多くの要因に依存しています。最も目立つのは、ページングされているレコードの数と、web サーバーとデータベースサーバー間の通信チャネルに対して行われた負荷です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="fd6fd-362">少数のレコードを含む小さいテーブルの場合、パフォーマンスの差はごくわずかです。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="fd6fd-363">ただし、大規模なテーブルでは、数千から数百の行がありますが、パフォーマンスの違いは鋭角です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="fd6fd-364">[SQL Server 2005 を使用した ASP.NET 2.0 でのカスタムページングに関する](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)記事では、5万レコードを含むデータベーステーブルを使用してページングするときに、これら2つのページング手法のパフォーマンスの違いを示すために実行したいくつかのパフォーマンステストが含まれています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="fd6fd-365">これらのテストでは、( [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)を使用して) SQL Server レベルでクエリを実行する時間と、 [ASP.NET s トレース機能](https://msdn.microsoft.com/library/y13fw6we.aspx)を使用して ASP.NET ページでクエリを実行する時間の両方を確認しました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="fd6fd-366">これらのテストは、1つのアクティブなユーザーを使用して開発用ボックスで実行されているため、科学的なものではなく、一般的な web サイトのロードパターンを模倣していないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="fd6fd-367">とは異なり、結果は、十分な量のデータを処理するときの既定のページングとカスタムページングの実行時間の相対的な違いを示しています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="fd6fd-368">**平均実行時間 (秒)**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="fd6fd-369">**Reads**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="fd6fd-370">**既定のページング SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="fd6fd-371">1.411</span><span class="sxs-lookup"><span data-stu-id="fd6fd-371">1.411</span></span> | <span data-ttu-id="fd6fd-372">383</span><span class="sxs-lookup"><span data-stu-id="fd6fd-372">383</span></span> |
| <span data-ttu-id="fd6fd-373">**カスタムページング SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="fd6fd-374">0.002</span><span class="sxs-lookup"><span data-stu-id="fd6fd-374">0.002</span></span> | <span data-ttu-id="fd6fd-375">29</span><span class="sxs-lookup"><span data-stu-id="fd6fd-375">29</span></span> |
| <span data-ttu-id="fd6fd-376">**既定のページング ASP.NET トレース**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="fd6fd-377">2.379</span><span class="sxs-lookup"><span data-stu-id="fd6fd-377">2.379</span></span> | <span data-ttu-id="fd6fd-378">*N/A*</span><span class="sxs-lookup"><span data-stu-id="fd6fd-378">*N/A*</span></span> |
| <span data-ttu-id="fd6fd-379">**カスタムページング ASP.NET トレース**</span><span class="sxs-lookup"><span data-stu-id="fd6fd-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="fd6fd-380">0.029</span><span class="sxs-lookup"><span data-stu-id="fd6fd-380">0.029</span></span> | <span data-ttu-id="fd6fd-381">*N/A*</span><span class="sxs-lookup"><span data-stu-id="fd6fd-381">*N/A*</span></span> |

<span data-ttu-id="fd6fd-382">ご覧のように、データの特定のページを取得するには、平均で354回の読み取りを必要とし、時間の経過と共に完了する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="fd6fd-383">ASP.NET ページでは、ページを既定のページングを使用したときに要した時間<sup>を1/100 に</sup>近づけることができました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="fd6fd-384">これらの結果の詳細については、「[マイ記事](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)」を参照してください。コードとデータベースをダウンロードして、独自の環境でこれらのテストを再現することができます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="fd6fd-385">まとめ</span><span class="sxs-lookup"><span data-stu-id="fd6fd-385">Summary</span></span>

<span data-ttu-id="fd6fd-386">既定のページングは、データ Web コントロールのスマートタグの [ページングを有効にする] チェックボックスをオンにするだけで実装するたいしたですが、このような単純さにはパフォーマンスのコストが伴います。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="fd6fd-387">既定のページングでは、ユーザーがデータの任意のページを要求したときに、すべてのレコードが表示される場合がありますが、*すべて*のレコードが返されます。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="fd6fd-388">このパフォーマンスのオーバーヘッドを回避するために、ObjectDataSource では、別のページングオプションのカスタムページングが提供されています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="fd6fd-389">カスタムページングでは、表示する必要があるレコードのみを取得することによって、既定のページングパフォーマンスの問題が改善されますが、カスタムページングの実装にも関係があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="fd6fd-390">最初に、要求されたレコードの特定のサブセットに適切にアクセスする (そして効率的に) クエリを記述する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="fd6fd-391">これはさまざまな方法で実現できます。このチュートリアルでは、SQL Server 2005 s new `ROW_NUMBER()` 関数を使用して結果に順位を付け、順位が指定された範囲内にある結果だけを返すようにする方法を説明しました。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="fd6fd-392">さらに、ページングされるレコードの合計数を決定する手段を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="fd6fd-393">これらの DAL メソッドと BLL メソッドを作成した後、ObjectDataSource を構成して、ページ全体の合計レコード数を確認し、開始行インデックスと最大行数の値を適切に BLL に渡すことができるようにする必要もあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="fd6fd-394">カスタムページングの実装には多くの手順が必要であり、既定のページングほど単純ではありませんが、十分な量のデータをページングする場合はカスタムページングが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="fd6fd-395">確認した結果が表示されると、カスタムページングによって ASP.NET ページのレンダリング時間が短縮され、データベースサーバーの負荷が1つ以上の大きな順序で軽減される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="fd6fd-396">プログラミングを楽しんでください。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="fd6fd-397">著者について</span><span class="sxs-lookup"><span data-stu-id="fd6fd-397">About the Author</span></span>

<span data-ttu-id="fd6fd-398">1998以来、 [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)は 7 asp/創設者 of [4GuysFromRolla.com](http://www.4guysfromrolla.com)の執筆者であり、Microsoft Web テクノロジを使用しています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="fd6fd-399">Scott は、独立したコンサルタント、トレーナー、およびライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="fd6fd-400">彼の最新の書籍は[ *、ASP.NET 2.0 を24時間以内に教え*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ています。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="fd6fd-401">mitchell@4GuysFromRolla.comでアクセスでき[ます。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="fd6fd-402">または彼のブログを参照してください。これは[http://ScottOnWriting.NET](http://ScottOnWriting.NET)にあります。</span><span class="sxs-lookup"><span data-stu-id="fd6fd-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="fd6fd-403">[前へ](paging-and-sorting-report-data-cs.md)
> [次へ](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="fd6fd-403">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
