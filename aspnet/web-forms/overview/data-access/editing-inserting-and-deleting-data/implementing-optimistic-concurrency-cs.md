---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: オプティミスティック同時実行制御C#() の実装Microsoft Docs
author: rick-anderson
description: 複数のユーザーがデータを編集できるようにする web アプリケーションの場合、2人のユーザーが同時に同じデータを編集するというリスクがあります。 この tutori では、
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 3cddb0efd28249ffc5708ece39c80581d078a5a2
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 11/28/2019
ms.locfileid: "74617484"
---
# <a name="implementing-optimistic-concurrency-c"></a><span data-ttu-id="68c00-104">オプティミスティック同時実行制御を実装する (C#)</span><span class="sxs-lookup"><span data-stu-id="68c00-104">Implementing Optimistic Concurrency (C#)</span></span>

<span data-ttu-id="68c00-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="68c00-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="68c00-106">[サンプルアプリのダウンロード](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe)または[PDF のダウンロード](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="68c00-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) or [Download PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span></span>

> <span data-ttu-id="68c00-107">複数のユーザーがデータを編集できるようにする web アプリケーションの場合、2人のユーザーが同時に同じデータを編集するというリスクがあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="68c00-108">このチュートリアルでは、オプティミスティック同時実行制御を実装して、このリスクを処理します。</span><span class="sxs-lookup"><span data-stu-id="68c00-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>

## <a name="introduction"></a><span data-ttu-id="68c00-109">はじめに</span><span class="sxs-lookup"><span data-stu-id="68c00-109">Introduction</span></span>

<span data-ttu-id="68c00-110">データの表示のみを許可する web アプリケーションの場合、またはデータを変更できる1人のユーザーのみを含む web アプリケーションの場合、2人のユーザーが別の変更を誤って上書きしても、脅威は発生しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="68c00-111">複数のユーザーがデータを更新または削除できるようにする web アプリケーションの場合、1人のユーザーが別の同時実行ユーザーと競合する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="68c00-112">同時実行ポリシーが設定されていない場合、2人のユーザーが同時に1つのレコードを編集すると、その変更をコミットしたユーザーは、最初に行った変更を上書きします。</span><span class="sxs-lookup"><span data-stu-id="68c00-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="68c00-113">たとえば、Jisun と Sam という2人のユーザーがアプリケーションのページにアクセスし、その後、ユーザーが GridView コントロールを使用して製品を更新および削除できるとします。</span><span class="sxs-lookup"><span data-stu-id="68c00-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="68c00-114">両方とも、GridView の [編集] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="68c00-115">Jisun は製品名を "Chai 紅茶" に変更し、[更新] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="68c00-116">結果として、データベースに送信される `UPDATE` ステートメントがあります。これにより、*すべて*の製品の更新可能フィールドが設定されます (Jisun によって1つのフィールドが更新された場合でも、`ProductName`)。</span><span class="sxs-lookup"><span data-stu-id="68c00-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="68c00-117">この時点で、この特定の製品について、データベースの値は "Chai 紅茶"、カテゴリ飲み物、業者の特別な液体などです。</span><span class="sxs-lookup"><span data-stu-id="68c00-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="68c00-118">ただし、Sam の画面の GridView でも、編集可能な GridView 行の製品名は "Chai" として表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="68c00-119">Jisun の変更がコミットされてから数秒後に、Sam はカテゴリを Condiments に更新し、[更新] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="68c00-120">これにより、製品名を "Chai" に設定する `UPDATE` ステートメントがデータベースに送信され、対応する飲料カテゴリ ID に `CategoryID` ます。</span><span class="sxs-lookup"><span data-stu-id="68c00-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="68c00-121">製品名に対する jisun の変更が上書きされました。</span><span class="sxs-lookup"><span data-stu-id="68c00-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="68c00-122">図1に、この一連のイベントをグラフィカルに示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-122">Figure 1 graphically depicts this series of events.</span></span>

<span data-ttu-id="68c00-123">[2人のユーザーが同時にレコードを更新するときに、1人のユーザーの変更によって他のが上書きされる可能性がある ![](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-123">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span></span>

<span data-ttu-id="68c00-124">**図 1**: 2 人のユーザーが同時にレコードを更新する場合、1人のユーザーの変更によって他のが上書きされる可能性があります ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image3.png)されます)。</span><span class="sxs-lookup"><span data-stu-id="68c00-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image3.png))</span></span>

<span data-ttu-id="68c00-125">同様に、2人のユーザーが1ページにアクセスしたときに、あるユーザーが別のユーザーによって削除されたレコードを更新しようとしている場合があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="68c00-126">または、ユーザーがページを読み込んだときに、[削除] ボタンをクリックしたときに、別のユーザーがそのレコードの内容を変更した可能性があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="68c00-127">次の3つの[同時実行制御](http://en.wikipedia.org/wiki/Concurrency_control)戦略を使用できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="68c00-128">**何もしない**-同時実行ユーザーが同じレコードを変更している場合は、最後のコミットを優先します (既定の動作)。</span><span class="sxs-lookup"><span data-stu-id="68c00-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="68c00-129">[**オプティミスティック同時実行制御**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control)-現時点で同時実行の競合が発生する可能性はありますが、そのような競合が発生することはほとんどありません。そのため、競合が発生した場合は、別のユーザーが同じデータを変更したため、変更を保存できないことをユーザーに通知するだけです。</span><span class="sxs-lookup"><span data-stu-id="68c00-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="68c00-130">**ペシミスティック同時実行制御**-同時実行の競合が一般的であり、ユーザーが別のユーザーの同時アクティビティによって変更が保存されていないということを許容できないことを想定しています。そのため、1人のユーザーがレコードの更新を開始したときに、そのレコードをロックして、ユーザーが変更をコミットするまで他のユーザーがそのレコードを編集または削除できないようにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="68c00-131">これまでに説明したすべてのチュートリアルでは、既定の同時実行の解決方法を使用していました。つまり、最後の書き込みを勝ちにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="68c00-132">このチュートリアルでは、オプティミスティック同時実行制御を実装する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="68c00-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="68c00-133">このチュートリアルシリーズでは、ペシミスティック同時実行の例については説明しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="68c00-134">ペシミスティック同時実行制御はほとんど使用されません。このようなロックが適切に放棄されていないと、他のユーザーがデータを更新できなくなる可能性があるためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="68c00-135">たとえば、ユーザーが編集のためにレコードをロックしてから、ロックを解除する前にその日のままにした場合、元のユーザーが戻って更新を完了するまで、他のユーザーはそのレコードを更新できません。</span><span class="sxs-lookup"><span data-stu-id="68c00-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="68c00-136">したがって、ペシミスティック同時実行制御が使用されている場合は、通常、タイムアウトが発生すると、ロックがキャンセルされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="68c00-137">チケット販売 web サイトでは、ユーザーが注文プロセスを完了している間に特定の座席をロックします。これは、ペシミスティック同時実行制御の一例です。</span><span class="sxs-lookup"><span data-stu-id="68c00-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>

## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="68c00-138">手順 1: オプティミスティック同時実行制御の実装方法を確認する</span><span class="sxs-lookup"><span data-stu-id="68c00-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="68c00-139">オプティミスティック同時実行制御は、更新または削除するレコードの値が、更新または削除処理の開始時と同じ値であることを保証することによって機能します。</span><span class="sxs-lookup"><span data-stu-id="68c00-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="68c00-140">たとえば、編集可能な GridView で [編集] ボタンをクリックすると、レコードの値がデータベースから読み取られ、テキストボックスやその他の Web コントロールに表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="68c00-141">これらの元の値は、GridView によって保存されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="68c00-142">その後、ユーザーが変更を行って [更新] ボタンをクリックすると、元の値と新しい値がビジネスロジック層に送信され、その後、データアクセス層に移動します。</span><span class="sxs-lookup"><span data-stu-id="68c00-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="68c00-143">データアクセス層は、ユーザーが編集を開始した元の値がデータベース内の値と同じである場合にのみレコードを更新する SQL ステートメントを発行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="68c00-144">図2は、この一連のイベントを示しています。</span><span class="sxs-lookup"><span data-stu-id="68c00-144">Figure 2 depicts this sequence of events.</span></span>

<span data-ttu-id="68c00-145">[更新または削除を成功させるには、元の値が現在のデータベースの値と同じである必要があり ![](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span></span>

<span data-ttu-id="68c00-146">**図 2**: 更新または削除を成功させるには、元の値が現在のデータベースの値と同じである必要があります ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image6.png)されます)。</span><span class="sxs-lookup"><span data-stu-id="68c00-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image6.png))</span></span>

<span data-ttu-id="68c00-147">オプティミスティック同時実行制御の実装にはさまざまな方法があります (いくつかのオプションについては、「 [Bromberg](http://peterbromberg.net/)の[オプティミスティック同時実行制御のロジック](http://www.eggheadcafe.com/articles/20050719.asp)」を参照してください)。</span><span class="sxs-lookup"><span data-stu-id="68c00-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="68c00-148">ADO.NET 型指定されたデータセットは、チェックボックスの目盛りだけを使用して構成できる1つの実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="68c00-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="68c00-149">型指定されたデータセット内の TableAdapter に対してオプティミスティック同時実行制御を有効にすると、TableAdapter の `UPDATE` と `DELETE` ステートメントが強化され、`WHERE` 句の元の値のすべての比較が含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="68c00-150">次の `UPDATE` ステートメントでは、現在のデータベース値が GridView のレコードを更新するときに最初に取得された値と等しい場合にのみ、製品の名前と価格を更新します。</span><span class="sxs-lookup"><span data-stu-id="68c00-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="68c00-151">`@ProductName` パラメーターと `@UnitPrice` パラメーターには、ユーザーが入力した新しい値が含まれます。一方、`@original_ProductName` と `@original_UnitPrice` には、[編集] ボタンをクリックしたときに GridView に最初に読み込まれた値が含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="68c00-152">この `UPDATE` ステートメントは、読みやすくするために簡略化されています。</span><span class="sxs-lookup"><span data-stu-id="68c00-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="68c00-153">実際には、`UnitPrice` に `NULL` を含めることができ、`NULL = NULL` が常に False を返すかどうかを確認するために、`WHERE` 句の `UnitPrice` チェックインがさらに複雑になります (代わりに `IS NULL`を使用する必要があります)。</span><span class="sxs-lookup"><span data-stu-id="68c00-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>

<span data-ttu-id="68c00-154">別の基になる `UPDATE` ステートメントを使用するだけでなく、オプティミスティック同時実行制御を使用するように TableAdapter を構成すると、その DB ダイレクトメソッドの署名も変更されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="68c00-155">最初のチュートリアル「[*データアクセス層の作成*](../introduction/creating-a-data-access-layer-cs.md)」では、DB ダイレクトメソッドは、厳密に型指定された DataRow または DataTable インスタンスではなく、入力パラメーターとしてスカラー値のリストを受け取るものでした。</span><span class="sxs-lookup"><span data-stu-id="68c00-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="68c00-156">オプティミスティック同時実行制御を使用する場合、DB direct `Update()` および `Delete()` メソッドには、元の値の入力パラメーターも含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="68c00-157">さらに、バッチ更新パターンを使用するための BLL 内のコード (スカラー値ではなく Datarow と Datatable を受け入れる `Update()` メソッドオーバーロード) も変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="68c00-158">既存の DAL の Tableadapter を拡張してオプティミスティック同時実行制御を使用するのではなく (このためには、BLL の変更が必要になります)、代わりに `NorthwindOptimisticConcurrency`という名前の新しい型のデータセットを作成します。ここで、オプティミスティック同時実行制御を使用する `Products` TableAdapter を追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="68c00-159">その後、オプティミスティック同時実行制御 DAL をサポートするための適切な変更を含む `ProductsOptimisticConcurrencyBLL` ビジネスロジック層クラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="68c00-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="68c00-160">この基礎を説明すると、ASP.NET ページを作成する準備が整います。</span><span class="sxs-lookup"><span data-stu-id="68c00-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="68c00-161">手順 2: オプティミスティック同時実行制御をサポートするデータアクセス層の作成</span><span class="sxs-lookup"><span data-stu-id="68c00-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="68c00-162">新しい型指定されたデータセットを作成するには、`App_Code` フォルダー内の `DAL` フォルダーを右クリックし、`NorthwindOptimisticConcurrency`という名前の新しいデータセットを追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="68c00-163">最初のチュートリアルで説明したように、これを行うと、新しい TableAdapter が型指定されたデータセットに追加され、TableAdapter 構成ウィザードが自動的に起動します。</span><span class="sxs-lookup"><span data-stu-id="68c00-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="68c00-164">最初の画面では、`Web.config`の `NORTHWNDConnectionString` 設定を使用して、同じ Northwind データベースに接続するためのデータベースを指定するように求められます。</span><span class="sxs-lookup"><span data-stu-id="68c00-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>

<span data-ttu-id="68c00-165">[同じ Northwind データベースに接続 ![には](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span></span>

<span data-ttu-id="68c00-166">**図 3**: 同じ Northwind データベースに接続する ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image9.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image9.png))</span></span>

<span data-ttu-id="68c00-167">次に、アドホック SQL ステートメント、新しいストアドプロシージャ、または既存のストアドプロシージャを使用して、データのクエリを実行する方法を確認するメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="68c00-168">元の DAL でアドホック SQL クエリを使用したため、ここでもこのオプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="68c00-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>

<span data-ttu-id="68c00-169">[アドホック SQL ステートメントを使用して取得するデータを指定 ![には](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span></span>

<span data-ttu-id="68c00-170">**図 4**: アドホック SQL ステートメントを使用して取得するデータを指定する ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image12.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image12.png))</span></span>

<span data-ttu-id="68c00-171">次の画面で、製品情報を取得するために使用する SQL クエリを入力します。</span><span class="sxs-lookup"><span data-stu-id="68c00-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="68c00-172">元の DAL の `Products` TableAdapter に使用したものとまったく同じ SQL クエリを使用します。これにより、製品の供給元とカテゴリ名と共にすべての `Product` 列が返されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]

<span data-ttu-id="68c00-173">[元の DAL の Products TableAdapter と同じ SQL クエリを使用 ![](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span></span>

<span data-ttu-id="68c00-174">**図 5**: 元の DAL の `Products` TableAdapter で同じ SQL クエリを使用する ([クリックしてフルサイズのイメージを表示する](implementing-optimistic-concurrency-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image15.png))</span></span>

<span data-ttu-id="68c00-175">次の画面に進む前に、[詳細オプション] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="68c00-176">この TableAdapter でオプティミスティック同時実行制御を使用するには、[オプティミスティック同時実行制御を使用する] チェックボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>

<span data-ttu-id="68c00-177">[オプティミスティック同時実行制御を有効にするには &quot;[オプティミスティック同時実行制御を使用する]&quot; チェックボックスをオンに ![](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span></span>

<span data-ttu-id="68c00-178">**図 6**: [オプティミスティック同時実行制御を使用する] チェックボックスをオンにしてオプティミスティック同時実行制御を有効にする ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image18.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image18.png))</span></span>

<span data-ttu-id="68c00-179">最後に、TableAdapter が DataTable にデータを格納し、DataTable を返すデータアクセスパターンを使用する必要があることを示します。また、DB ダイレクトメソッドを作成する必要があることを示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="68c00-180">元の DAL で使用した名前付け規則を反映するように、GetData から GetProducts に DataTable パターンを返すのメソッド名を変更します。</span><span class="sxs-lookup"><span data-stu-id="68c00-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>

<span data-ttu-id="68c00-181">[TableAdapter がすべてのデータアクセスパターンを利用 ![](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span></span>

<span data-ttu-id="68c00-182">**図 7**: TableAdapter ですべてのデータアクセスパターンを使用[する (クリックしてフルサイズのイメージを表示する](implementing-optimistic-concurrency-cs/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image21.png))</span></span>

<span data-ttu-id="68c00-183">ウィザードを完了すると、データセットデザイナーには、厳密に型指定された `Products` DataTable と TableAdapter が含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="68c00-184">DataTable の名前を `Products` から `ProductsOptimisticConcurrency`に変更します。これを行うには、DataTable のタイトルバーを右クリックし、コンテキストメニューから [名前の変更] を選択します。</span><span class="sxs-lookup"><span data-stu-id="68c00-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>

<span data-ttu-id="68c00-185">[DataTable と TableAdapter が型指定されたデータセットに追加された ![](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span></span>

<span data-ttu-id="68c00-186">**図 8**: DataTable と TableAdapter が型指定されたデータセットに追加された ([クリックすると、フルサイズのイメージが表示](implementing-optimistic-concurrency-cs/_static/image24.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image24.png))</span></span>

<span data-ttu-id="68c00-187">(オプティミスティック同時実行制御を使用する) `ProductsOptimisticConcurrency` TableAdapter と Products TableAdapter () の間の `UPDATE` と `DELETE` クエリの相違点を確認するには、TableAdapter をクリックし、プロパティウィンドウにアクセスします。</span><span class="sxs-lookup"><span data-stu-id="68c00-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="68c00-188">`DeleteCommand` プロパティと `UpdateCommand` プロパティの `CommandText` サブプロパティで、DAL の更新または削除に関連するメソッドが呼び出されたときにデータベースに送信される実際の SQL 構文を確認できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="68c00-189">`ProductsOptimisticConcurrency` TableAdapter の場合、使用される `DELETE` ステートメントは次のとおりです。</span><span class="sxs-lookup"><span data-stu-id="68c00-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

<span data-ttu-id="68c00-190">しかし、元の DAL の製品 TableAdapter の `DELETE` ステートメントははるかに簡単です。</span><span class="sxs-lookup"><span data-stu-id="68c00-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

<span data-ttu-id="68c00-191">ご覧のように、オプティミスティック同時実行制御を使用する TableAdapter の `DELETE` ステートメントの `WHERE` 句には、`Product` テーブルの既存の列値と、GridView (または DetailsView または FormView) が最後に設定された時点での元の値との比較が含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="68c00-192">`ProductID`、`ProductName`、および `Discontinued` 以外のすべてのフィールドは `NULL` 値を持つことができるため、`NULL` 句の `WHERE` 値を正しく比較するために、追加のパラメーターとチェックが含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="68c00-193">このチュートリアルでは、オプティミスティック同時実行制御が有効なデータセットに Datatable を追加することはありません。 ASP.NET ページでは、製品情報の更新と削除のみが提供されるためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="68c00-194">ただし、`ProductsOptimisticConcurrency` TableAdapter に `GetProductByProductID(productID)` メソッドを追加する必要もあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="68c00-195">これを行うには、TableAdapter のタイトルバー (`Fill` と `GetProducts` メソッド名の上の領域) を右クリックし、コンテキストメニューから [クエリの追加] を選択します。</span><span class="sxs-lookup"><span data-stu-id="68c00-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="68c00-196">これにより、TableAdapter クエリの構成ウィザードが起動します。</span><span class="sxs-lookup"><span data-stu-id="68c00-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="68c00-197">TableAdapter の初期構成と同様に、アドホック SQL ステートメントを使用して `GetProductByProductID(productID)` メソッドを作成することを選択します (図4を参照)。</span><span class="sxs-lookup"><span data-stu-id="68c00-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="68c00-198">`GetProductByProductID(productID)` メソッドは特定の製品に関する情報を返すため、このクエリは、行を返す `SELECT` のクエリ型であることを示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>

<span data-ttu-id="68c00-199">[![クエリの種類を &quot;としてマークすると、行が返され&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span></span>

<span data-ttu-id="68c00-200">**図 9**: クエリの種類を "行を返す`SELECT`" としてマーク[する (クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image27.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image27.png))</span></span>

<span data-ttu-id="68c00-201">次の画面で、TableAdapter の既定のクエリが事前に読み込まれている、使用する SQL クエリを入力するように求められます。</span><span class="sxs-lookup"><span data-stu-id="68c00-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="68c00-202">図10に示すように、`WHERE ProductID = @ProductID`句を含めるように既存のクエリを拡張します。</span><span class="sxs-lookup"><span data-stu-id="68c00-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>

<span data-ttu-id="68c00-203">[特定の製品レコードを返すために、事前に読み込まれたクエリに WHERE 句を追加 ![](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span></span>

<span data-ttu-id="68c00-204">**図 10**: 事前に読み込まれたクエリに `WHERE` 句を追加して特定の製品レコードを返す ([クリックしてフルサイズの画像を表示する](implementing-optimistic-concurrency-cs/_static/image30.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image30.png))</span></span>

<span data-ttu-id="68c00-205">最後に、生成されたメソッド名を `FillByProductID` に変更し、`GetProductByProductID`します。</span><span class="sxs-lookup"><span data-stu-id="68c00-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>

<span data-ttu-id="68c00-206">[メソッドの名前を FillByProductID および GetProductByProductID に変更 ![には](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span></span>

<span data-ttu-id="68c00-207">**図 11**: `FillByProductID` と `GetProductByProductID` にメソッドの名前を変更する ([クリックしてフルサイズのイメージを表示する](implementing-optimistic-concurrency-cs/_static/image33.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image33.png))</span></span>

<span data-ttu-id="68c00-208">このウィザードが完了すると、TableAdapter には、データを取得するための2つのメソッドが含まれるようになりました。 `GetProducts()`では、*すべて*の製品が返されます。および `GetProductByProductID(productID)`。指定した製品が返されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="68c00-209">手順 3: オプティミスティック同時実行対応 DAL のビジネスロジック層の作成</span><span class="sxs-lookup"><span data-stu-id="68c00-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="68c00-210">既存の `ProductsBLL` クラスには、batch update と DB direct の両方のパターンを使用する例が含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="68c00-211">`AddProduct` メソッドと `UpdateProduct` のオーバーロードでは、どちらもバッチ更新パターンを使用し、`ProductRow` インスタンスを TableAdapter の Update メソッドに渡します。</span><span class="sxs-lookup"><span data-stu-id="68c00-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="68c00-212">一方、`DeleteProduct` メソッドでは、TableAdapter の `Delete(productID)` メソッドを呼び出すことによって、DB direct パターンが使用されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="68c00-213">新しい `ProductsOptimisticConcurrency` TableAdapter では、DB ダイレクトメソッドで、元の値も渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="68c00-214">たとえば、`Delete` メソッドでは、10個の入力パラメーター (元の `ProductID`、`ProductName`、`SupplierID`、`CategoryID`、`QuantityPerUnit`、`UnitPrice`、`UnitsInStock`、`UnitsOnOrder`、`ReorderLevel`、`Discontinued`) が必要になります。</span><span class="sxs-lookup"><span data-stu-id="68c00-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="68c00-215">これらの追加の入力パラメーターの値は、データベースに送信される `DELETE` ステートメントの `WHERE` 句で使用されます。データベースの現在の値が元の値に対応している場合にのみ、指定したレコードが削除されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="68c00-216">バッチ更新パターンで使用される TableAdapter の `Update` メソッドのメソッドシグネチャは変更されていませんが、元の値と新しい値を記録するために必要なコードにはがあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="68c00-217">そのため、オプティミスティック同時実行対応の DAL を既存の `ProductsBLL` クラスと共に使用するのではなく、新しい DAL を操作するための新しいビジネスロジックレイヤークラスを作成してみましょう。</span><span class="sxs-lookup"><span data-stu-id="68c00-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="68c00-218">`ProductsOptimisticConcurrencyBLL` という名前のクラスを `App_Code` フォルダー内の `BLL` フォルダーに追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>

![ProductsOptimisticConcurrencyBLL クラスを [BLL] フォルダーに追加します。](implementing-optimistic-concurrency-cs/_static/image34.png)

<span data-ttu-id="68c00-220">**図 12**: [BLL] フォルダーに `ProductsOptimisticConcurrencyBLL` クラスを追加する</span><span class="sxs-lookup"><span data-stu-id="68c00-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>

<span data-ttu-id="68c00-221">次に、`ProductsOptimisticConcurrencyBLL` クラスに次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

<span data-ttu-id="68c00-222">Using `NorthwindOptimisticConcurrencyTableAdapters` ステートメントは、クラス宣言の先頭より上にあることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="68c00-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="68c00-223">`NorthwindOptimisticConcurrencyTableAdapters` 名前空間には、DAL のメソッドを提供する `ProductsOptimisticConcurrencyTableAdapter` クラスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="68c00-224">また、クラス宣言の前に、`System.ComponentModel.DataObject` 属性があります。これにより、Visual Studio は、ObjectDataSource ウィザードのドロップダウンリストにこのクラスを含めるように指示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="68c00-225">`ProductsOptimisticConcurrencyBLL`の `Adapter` プロパティを使用すると、`ProductsOptimisticConcurrencyTableAdapter` クラスのインスタンスにすばやくアクセスでき、元の BLL クラス (`ProductsBLL`、`CategoriesBLL`など) で使用されるパターンに従います。</span><span class="sxs-lookup"><span data-stu-id="68c00-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="68c00-226">最後に、`GetProducts()` メソッドは、DAL の `GetProducts()` メソッドに単にを呼び出し、データベース内の各製品レコードの `ProductsOptimisticConcurrencyRow` インスタンスが設定された `ProductsOptimisticConcurrencyDataTable` オブジェクトを返します。</span><span class="sxs-lookup"><span data-stu-id="68c00-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="68c00-227">オプティミスティック同時実行制御による DB Direct パターンを使用した製品の削除</span><span class="sxs-lookup"><span data-stu-id="68c00-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="68c00-228">オプティミスティック同時実行制御を使用する DAL に対して DB direct パターンを使用する場合は、メソッドに新しい値と元の値を渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="68c00-229">削除の場合、新しい値は存在しないため、元の値のみを渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="68c00-230">BLL では、元のすべてのパラメーターを入力パラメーターとして受け入れる必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="68c00-231">`ProductsOptimisticConcurrencyBLL` クラスの `DeleteProduct` メソッドで、DB ダイレクトメソッドを使用してみましょう。</span><span class="sxs-lookup"><span data-stu-id="68c00-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="68c00-232">つまり、次のコードに示すように、このメソッドは10個の製品データフィールドをすべて入力パラメーターとして取得し、それらを DAL に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

<span data-ttu-id="68c00-233">元の値-GridView (または DetailsView または FormView) に最後に読み込まれた値と、ユーザーが [削除] ボタンをクリックしたときにデータベースの値が異なる場合、`WHERE` 句はデータベースレコードと一致せず、影響を受けるレコードはありません。</span><span class="sxs-lookup"><span data-stu-id="68c00-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="68c00-234">したがって、TableAdapter の `Delete` メソッドは `0` を返し、BLL の `DeleteProduct` メソッドは `false`を返します。</span><span class="sxs-lookup"><span data-stu-id="68c00-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="68c00-235">オプティミスティック同時実行制御によるバッチ更新パターンを使用した製品の更新</span><span class="sxs-lookup"><span data-stu-id="68c00-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="68c00-236">前述のように、TableAdapter のバッチ更新パターンの `Update` メソッドは、オプティミスティック同時実行制御が使用されているかどうかに関係なく、同じメソッドシグネチャを持ちます。</span><span class="sxs-lookup"><span data-stu-id="68c00-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="68c00-237">つまり、`Update` メソッドには、DataRow、Datarow の配列、DataTable、または型指定されたデータセットが必要です。</span><span class="sxs-lookup"><span data-stu-id="68c00-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="68c00-238">元の値を指定するための追加の入力パラメーターはありません。</span><span class="sxs-lookup"><span data-stu-id="68c00-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="68c00-239">これが可能なのは、DataTable が DataRow の元の値および変更された値を追跡しているためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="68c00-240">DAL によって `UPDATE` ステートメントが発行されると、`@original_ColumnName` パラメーターに DataRow の元の値が設定されます。一方、`@ColumnName` のパラメーターには、DataRow の変更後の値が設定されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="68c00-241">(元の非オプティミスティック同時実行制御 DAL を使用する) `ProductsBLL` クラスでは、バッチ更新パターンを使用して製品情報を更新すると、コードで次の一連のイベントが実行されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="68c00-242">TableAdapter の `GetProductByProductID(productID)` 方法を使用して、現在のデータベースの製品情報を `ProductRow` インスタンスに読み取ります。</span><span class="sxs-lookup"><span data-stu-id="68c00-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="68c00-243">手順 1. の `ProductRow` インスタンスに新しい値を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="68c00-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="68c00-244">TableAdapter の `Update` メソッドを呼び出し、`ProductRow` インスタンスを渡します。</span><span class="sxs-lookup"><span data-stu-id="68c00-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="68c00-245">ただし、この一連の手順ではオプティミスティック同時実行制御が正しくサポートされません。これは、手順 1. で設定された `ProductRow` がデータベースから直接設定されることを意味します。つまり、DataRow によって使用される元の値は、データベースに現在存在する値であり、編集プロセスの開始時に GridView にバインドされた</span><span class="sxs-lookup"><span data-stu-id="68c00-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="68c00-246">代わりに、オプティミスティック同時実行制御を有効にした DAL を使用する場合は、次の手順を使用するように `UpdateProduct` メソッドのオーバーロードを変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="68c00-247">TableAdapter の `GetProductByProductID(productID)` 方法を使用して、現在のデータベースの製品情報を `ProductsOptimisticConcurrencyRow` インスタンスに読み取ります。</span><span class="sxs-lookup"><span data-stu-id="68c00-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="68c00-248">手順 1. の `ProductsOptimisticConcurrencyRow` インスタンスに*元*の値を割り当てます。</span><span class="sxs-lookup"><span data-stu-id="68c00-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="68c00-249">`ProductsOptimisticConcurrencyRow` インスタンスの `AcceptChanges()` メソッドを呼び出します。これにより、現在の値が "original" であることが DataRow に指示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="68c00-250">*新しい*値を `ProductsOptimisticConcurrencyRow` インスタンスに割り当てます。</span><span class="sxs-lookup"><span data-stu-id="68c00-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="68c00-251">TableAdapter の `Update` メソッドを呼び出し、`ProductsOptimisticConcurrencyRow` インスタンスを渡します。</span><span class="sxs-lookup"><span data-stu-id="68c00-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="68c00-252">手順1では、指定された製品レコードの現在のすべてのデータベース値を読み取ります。</span><span class="sxs-lookup"><span data-stu-id="68c00-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="68c00-253">この手順は、*すべて*の product 列を更新する `UpdateProduct` のオーバーロードには不要です (これらの値は手順2で上書きされます) が、列の値のサブセットのみが入力パラメーターとして渡されるオーバーロードには不可欠です。</span><span class="sxs-lookup"><span data-stu-id="68c00-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="68c00-254">元の値が `ProductsOptimisticConcurrencyRow` インスタンスに割り当てられると、`AcceptChanges()` メソッドが呼び出されます。これにより、現在の DataRow 値が `UPDATE` ステートメントの `@original_ColumnName` パラメーターで使用される元の値としてマークされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="68c00-255">次に、新しいパラメーター値が `ProductsOptimisticConcurrencyRow` に割り当てられ、最後に `Update` メソッドが呼び出され、DataRow に渡されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="68c00-256">次のコードは、すべての製品データフィールドを入力パラメーターとして受け入れる `UpdateProduct` オーバーロードを示しています。</span><span class="sxs-lookup"><span data-stu-id="68c00-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="68c00-257">ここには記載されていませんが、このチュートリアルのダウンロードに含まれている `ProductsOptimisticConcurrencyBLL` クラスには、入力パラメーターとして製品名と価格だけを受け入れる `UpdateProduct` のオーバーロードも含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="68c00-258">手順 4: 元の値と新しい値を ASP.NET ページから BLL メソッドに渡す</span><span class="sxs-lookup"><span data-stu-id="68c00-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="68c00-259">DAL と BLL が完成したら、システムに組み込まれたオプティミスティック同時実行制御ロジックを利用できる ASP.NET ページを作成します。</span><span class="sxs-lookup"><span data-stu-id="68c00-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="68c00-260">具体的には、データ Web コントロール (GridView、DetailsView、または FormView) は元の値を記憶する必要があり、ObjectDataSource は両方の値のセットをビジネスロジック層に渡す必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="68c00-261">さらに、同時実行違反を適切に処理するように、ASP.NET ページを構成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="68c00-262">まず、`EditInsertDelete` フォルダーの [`OptimisticConcurrency.aspx`] ページを開き、GridView をデザイナーに追加します。その `ID` プロパティを `ProductsGrid`に設定します。</span><span class="sxs-lookup"><span data-stu-id="68c00-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="68c00-263">GridView のスマートタグから、`ProductsOptimisticConcurrencyDataSource`という名前の新しい ObjectDataSource を作成することを選択します。</span><span class="sxs-lookup"><span data-stu-id="68c00-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="68c00-264">この ObjectDataSource はオプティミスティック同時実行制御をサポートする DAL を使用するようにするため、`ProductsOptimisticConcurrencyBLL` オブジェクトを使用するように構成します。</span><span class="sxs-lookup"><span data-stu-id="68c00-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>

<span data-ttu-id="68c00-265">[ObjectDataSource が ProductsOptimisticConcurrencyBLL オブジェクトを使用している ![](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span></span>

<span data-ttu-id="68c00-266">**図 13**: ObjectDataSource で `ProductsOptimisticConcurrencyBLL` オブジェクトを使用する ([クリックしてフルサイズの画像を表示する](implementing-optimistic-concurrency-cs/_static/image37.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image37.png))</span></span>

<span data-ttu-id="68c00-267">ウィザードのドロップダウンリストから `GetProducts`、`UpdateProduct`、および `DeleteProduct` メソッドを選択します。</span><span class="sxs-lookup"><span data-stu-id="68c00-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="68c00-268">UpdateProduct メソッドの場合は、すべての製品のデータフィールドを受け入れるオーバーロードを使用します。</span><span class="sxs-lookup"><span data-stu-id="68c00-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="68c00-269">ObjectDataSource コントロールのプロパティの構成</span><span class="sxs-lookup"><span data-stu-id="68c00-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="68c00-270">ウィザードを完了すると、ObjectDataSource の宣言型マークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="68c00-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

<span data-ttu-id="68c00-271">ご覧のように、`DeleteParameters` コレクションには、`ProductsOptimisticConcurrencyBLL` クラスの `DeleteProduct` メソッドに含まれる10個の入力パラメーターそれぞれの `Parameter` インスタンスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="68c00-272">同様に、`UpdateParameters` コレクションには `UpdateProduct`内の各入力パラメーターの `Parameter` インスタンスが含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="68c00-273">データ変更を伴う前のチュートリアルでは、この時点で ObjectDataSource の `OldValuesParameterFormatString` プロパティを削除しました。このプロパティは、BLL メソッドが、新しい値と共に古い (または元の) 値を渡すことを想定していることを示すためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="68c00-274">さらに、このプロパティ値は、元の値の入力パラメーター名を示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="68c00-275">元の値を BLL に渡すため、このプロパティ*は削除しないでください。*</span><span class="sxs-lookup"><span data-stu-id="68c00-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="68c00-276">`OldValuesParameterFormatString` プロパティの値は、元の値を期待する BLL 内の入力パラメーター名にマップされる必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="68c00-277">これらのパラメーターには `original_productName`、`original_supplierID`などの名前を付けたので、`OldValuesParameterFormatString` プロパティの値を `original_{0}`として残しておくことができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="68c00-278">ただし、BLL メソッドの入力パラメーターに `old_productName`、`old_supplierID`などの名前が付いている場合は、`OldValuesParameterFormatString` プロパティを `old_{0}`に更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>

<span data-ttu-id="68c00-279">ObjectDataSource が元の値を BLL メソッドに正しく渡すために必要な最後のプロパティ設定が1つあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="68c00-280">ObjectDataSource には、次[の2つの値のいずれか](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx)に割り当てることができる[ConflictDetection プロパティ](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx)があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="68c00-281">`OverwriteChanges`-既定値。は、元の値を BLL メソッドの元の入力パラメーターに送信しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="68c00-282">`CompareAllValues`-元の値を BLL メソッドに送信します。オプティミスティック同時実行制御を使用する場合にこのオプションを選択します</span><span class="sxs-lookup"><span data-stu-id="68c00-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="68c00-283">`ConflictDetection` プロパティを `CompareAllValues`に設定します。</span><span class="sxs-lookup"><span data-stu-id="68c00-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="68c00-284">GridView のプロパティとフィールドの構成</span><span class="sxs-lookup"><span data-stu-id="68c00-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="68c00-285">ObjectDataSource のプロパティが適切に構成されているので、GridView の設定に注目してみましょう。</span><span class="sxs-lookup"><span data-stu-id="68c00-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="68c00-286">まず、GridView で編集と削除がサポートされるようにするため、[編集を有効にする] チェックボックスをオンにして、GridView のスマートタグから [削除] チェックボックスをオンにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="68c00-287">これにより、`ShowEditButton` と `ShowDeleteButton` の両方が `true`に設定されている CommandField が追加されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="68c00-288">`ProductsOptimisticConcurrencyDataSource` ObjectDataSource にバインドされている場合、GridView には、各製品のデータフィールドのフィールドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="68c00-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="68c00-289">このような GridView は編集できますが、ユーザーエクスペリエンスは任意ですが、許容されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="68c00-290">`CategoryID` および `SupplierID` BoundFields がテキストボックスとして表示され、ユーザーは適切なカテゴリとサプライヤーを ID 番号として入力する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="68c00-291">数値フィールドの書式が設定されていないため、製品名が指定されていること、および単価、在庫数、在庫数、および並べ替えレベルの値が適切な数値であることを確認するための検証コントロールはありません。0にします。</span><span class="sxs-lookup"><span data-stu-id="68c00-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="68c00-292">「*編集および挿入インターフェイスへの検証コントロールの追加*」と「*データ変更インターフェイスのカスタマイズ*」で説明したように、ユーザーインターフェイスは、Boundfields を templatefields に置き換えることによってカスタマイズできます。</span><span class="sxs-lookup"><span data-stu-id="68c00-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="68c00-293">この GridView と編集インターフェイスは、次の方法で変更しました。</span><span class="sxs-lookup"><span data-stu-id="68c00-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="68c00-294">`ProductID`、`SupplierName`、および `CategoryName` BoundFields が削除されました。</span><span class="sxs-lookup"><span data-stu-id="68c00-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="68c00-295">`ProductName` BoundField を TemplateField に変換し、RequiredFieldValidation コントロールを追加しました。</span><span class="sxs-lookup"><span data-stu-id="68c00-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="68c00-296">`CategoryID` および `SupplierID` BoundFields を TemplateFields に変換し、テキストボックスではなく DropDownLists を使用するように編集インターフェイスを調整しました。</span><span class="sxs-lookup"><span data-stu-id="68c00-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="68c00-297">これらの TemplateFields ' `ItemTemplates`には、`CategoryName` と `SupplierName` のデータフィールドが表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="68c00-298">`UnitPrice`、`UnitsInStock`、`UnitsOnOrder`、および `ReorderLevel` BoundFields を TemplateFields に変換し、CompareValidator コントロールを追加しました。</span><span class="sxs-lookup"><span data-stu-id="68c00-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="68c00-299">前のチュートリアルでこれらのタスクを実行する方法については既に説明したので、ここでは最後の宣言型の構文を一覧表示し、実装を実際のままにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

<span data-ttu-id="68c00-300">ここでは、完全に動作する例を示しています。</span><span class="sxs-lookup"><span data-stu-id="68c00-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="68c00-301">ただし、いくつかの微妙な問題が発生します。</span><span class="sxs-lookup"><span data-stu-id="68c00-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="68c00-302">また、同時実行違反が発生した場合にユーザーに警告するインターフェイスも必要です。</span><span class="sxs-lookup"><span data-stu-id="68c00-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="68c00-303">データ Web コントロールが元の値を ObjectDataSource に正しく渡す (その後、BLL に渡される) ためには、GridView の `EnableViewState` プロパティが `true` (既定値) に設定されていることが重要です。</span><span class="sxs-lookup"><span data-stu-id="68c00-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="68c00-304">ビューステートを無効にすると、元の値がポストバック時に失われます。</span><span class="sxs-lookup"><span data-stu-id="68c00-304">If you disable view state, the original values are lost on postback.</span></span>

## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="68c00-305">正しい元の値を ObjectDataSource に渡す</span><span class="sxs-lookup"><span data-stu-id="68c00-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="68c00-306">GridView の構成方法にはいくつかの問題があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="68c00-307">Objectdatasource の `ConflictDetection` プロパティが `CompareAllValues` (そのまま) に設定されている場合、objectdatasource の `Update()` または `Delete()` メソッドが GridView (または DetailsView または FormView) によって呼び出されると、ObjectDataSource は GridView の元の値を適切な `Parameter` インスタンスにコピーしようとします。</span><span class="sxs-lookup"><span data-stu-id="68c00-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="68c00-308">このプロセスをグラフィカルに表示するには、図2を参照してください。</span><span class="sxs-lookup"><span data-stu-id="68c00-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="68c00-309">具体的には、gridview の元の値には、データが GridView にバインドされるたびに、双方向のデータバインドステートメントの値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="68c00-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="68c00-310">したがって、必要な元の値はすべて双方向のデータバインディングを使用してキャプチャされ、変換可能な形式で提供されることが不可欠です。</span><span class="sxs-lookup"><span data-stu-id="68c00-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="68c00-311">これが重要な理由を確認するには、ブラウザーでページにアクセスしてください。</span><span class="sxs-lookup"><span data-stu-id="68c00-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="68c00-312">必要に応じて、GridView は、左端の列の [編集] ボタンと [削除] ボタンを使用して各製品を一覧表示します。</span><span class="sxs-lookup"><span data-stu-id="68c00-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>

<span data-ttu-id="68c00-313">[GridView に製品が一覧表示さ ![](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span></span>

<span data-ttu-id="68c00-314">**図 14**: GridView に製品が表示されている ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image40.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image40.png))</span></span>

<span data-ttu-id="68c00-315">任意の製品の [削除] ボタンをクリックすると、`FormatException` がスローされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>

<span data-ttu-id="68c00-316">[FormatException で製品の結果を削除しようとして ![](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span></span>

<span data-ttu-id="68c00-317">**図 15**: `FormatException` で製品の結果を削除しようとしています ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image43.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image43.png))</span></span>

<span data-ttu-id="68c00-318">`FormatException` は、ObjectDataSource が元の `UnitPrice` 値を読み取ろうとしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="68c00-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="68c00-319">`ItemTemplate` の `UnitPrice` は通貨 (`<%# Bind("UnitPrice", "{0:C}") %>`) として書式設定されているため、$19.95 のような通貨記号が含まれています。</span><span class="sxs-lookup"><span data-stu-id="68c00-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="68c00-320">`FormatException` は、ObjectDataSource がこの文字列を `decimal`に変換しようとしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="68c00-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="68c00-321">この問題を回避するために、いくつかのオプションがあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="68c00-322">`ItemTemplate`から通貨の書式を削除します。</span><span class="sxs-lookup"><span data-stu-id="68c00-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="68c00-323">つまり、`<%# Bind("UnitPrice", "{0:C}") %>`を使用するのではなく、単に `<%# Bind("UnitPrice") %>`を使用します。</span><span class="sxs-lookup"><span data-stu-id="68c00-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="68c00-324">この欠点は、価格がフォーマットされていないことです。</span><span class="sxs-lookup"><span data-stu-id="68c00-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="68c00-325">`ItemTemplate`で通貨として書式設定された `UnitPrice` を表示しますが、`Eval` キーワードを使用してこれを行います。</span><span class="sxs-lookup"><span data-stu-id="68c00-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="68c00-326">`Eval` は一方向のデータバインディングを実行することを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="68c00-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="68c00-327">その場合でも、元の値に `UnitPrice` 値を指定する必要があるため、`ItemTemplate`では双方向の databinding ステートメントが必要になりますが、`Visible` プロパティが `false`に設定されている Label Web コントロールに配置できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="68c00-328">ItemTemplate では、次のマークアップを使用できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-328">We could use the following markup in the ItemTemplate:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- <span data-ttu-id="68c00-329">`<%# Bind("UnitPrice") %>`を使用して、`ItemTemplate`から通貨の書式を削除します。</span><span class="sxs-lookup"><span data-stu-id="68c00-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="68c00-330">GridView の `RowDataBound` イベントハンドラーで、`UnitPrice` 値が表示されている Label Web コントロールにプログラムによってアクセスし、その `Text` プロパティを書式設定されたバージョンに設定します。</span><span class="sxs-lookup"><span data-stu-id="68c00-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="68c00-331">`UnitPrice` は通貨形式のままにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="68c00-332">GridView の `RowDeleting` イベントハンドラーで、`Decimal.Parse`を使用して、既存の元の `UnitPrice` の値 ($19.95) を実際の10進値に置き換えます。</span><span class="sxs-lookup"><span data-stu-id="68c00-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="68c00-333">ASP.NET ページのチュートリアルでは、 [*BLL と DAL レベルの例外の処理*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md)に関する `RowUpdating` のイベントハンドラーに似たものを実現する方法を説明しました。</span><span class="sxs-lookup"><span data-stu-id="68c00-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="68c00-334">この例では、2番目の方法を使用して、`Text` プロパティが、書式設定されていない `UnitPrice` 値にバインドされた双方向データである非表示のラベル Web コントロールを追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="68c00-335">この問題を解決したら、任意の製品の [削除] ボタンをもう一度クリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="68c00-336">今回は、ObjectDataSource が BLL の `UpdateProduct` メソッドを呼び出そうとしたときに、`InvalidOperationException` を取得します。</span><span class="sxs-lookup"><span data-stu-id="68c00-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>

<span data-ttu-id="68c00-337">[![ObjectDataSource は、送信しようとしている入力パラメーターを持つメソッドを見つけることができません](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span></span>

<span data-ttu-id="68c00-338">**図 16**: ObjectDataSource は、送信する入力パラメーターを持つメソッドを見つけることができません ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image46.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image46.png))</span></span>

<span data-ttu-id="68c00-339">例外のメッセージを見ると、ObjectDataSource では、`original_CategoryName` と `original_SupplierName` 入力パラメーターを含む BLL `DeleteProduct` メソッドを呼び出す必要があることがわかります。</span><span class="sxs-lookup"><span data-stu-id="68c00-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="68c00-340">これは、`CategoryID` と `SupplierID` TemplateFields の `ItemTemplate` には、現在、`CategoryName` および `SupplierName` データフィールドを持つ双方向のバインドステートメントが含まれているためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="68c00-341">代わりに、`CategoryID` と `SupplierID` のデータフィールドを含む `Bind` ステートメントを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="68c00-342">これを行うには、既存の Bind ステートメントを `Eval` のステートメントに置き換え、次に示すように、双方向のデータバインディングを使用して、`Text` プロパティが `CategoryID` と `SupplierID` のデータフィールドにバインドされている非表示のラベルコントロールを追加します。</span><span class="sxs-lookup"><span data-stu-id="68c00-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

<span data-ttu-id="68c00-343">これらの変更により、製品情報を正常に削除および編集できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="68c00-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="68c00-344">手順 5. では、同時実行違反が検出されていることを確認する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="68c00-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="68c00-345">ここでは、いくつかのレコードを更新して削除し、1人のユーザーの更新と削除が想定どおりに動作することを確認するために数分かかります。</span><span class="sxs-lookup"><span data-stu-id="68c00-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="68c00-346">手順 5: オプティミスティック同時実行制御のテスト</span><span class="sxs-lookup"><span data-stu-id="68c00-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="68c00-347">(データが無条件に上書きされるのではなく) 同時実行違反が検出されていることを確認するには、このページで2つのブラウザーウィンドウを開く必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="68c00-348">両方のブラウザーインスタンスで、[Chai] の [編集] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="68c00-349">次に、いずれかのブラウザーで、名前を "Chai 紅茶" に変更し、[更新] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="68c00-350">更新は正常に完了し、GridView が新しい製品名として "Chai 紅茶" を使用して、編集前の状態に戻ります。</span><span class="sxs-lookup"><span data-stu-id="68c00-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="68c00-351">ただし、他のブラウザーウィンドウインスタンスでは、[製品名] テキストボックスには引き続き "Chai" と表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="68c00-352">この2番目のブラウザーウィンドウで、`UnitPrice` を `25.00`に更新します。</span><span class="sxs-lookup"><span data-stu-id="68c00-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="68c00-353">オプティミスティック同時実行制御がサポートされていない場合、2番目のブラウザーインスタンスで [更新] をクリックすると、製品名が "Chai" に変更され、最初のブラウザーインスタンスによって行われた変更が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="68c00-354">ただし、オプティミスティック同時実行制御を使用した場合、2番目のブラウザーインスタンスの [更新] ボタンをクリックすると、 [system.data.dbconcurrencyexception](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx)が発生します。</span><span class="sxs-lookup"><span data-stu-id="68c00-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>

<span data-ttu-id="68c00-355">[![同時実行違反が検出されると、System.data.dbconcurrencyexception がスローされます。](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span></span>

<span data-ttu-id="68c00-356">**図 17**: 同時実行違反が検出されると `DBConcurrencyException` がスローされます ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image49.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image49.png))</span></span>

<span data-ttu-id="68c00-357">`DBConcurrencyException` は、DAL のバッチ更新パターンが使用されている場合にのみスローされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="68c00-358">DB direct パターンでは、例外は発生しません。これは、影響を受けた行がないことを示しているだけです。</span><span class="sxs-lookup"><span data-stu-id="68c00-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="68c00-359">これを説明するために、両方のブラウザーインスタンスの GridView を編集前の状態に戻します。</span><span class="sxs-lookup"><span data-stu-id="68c00-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="68c00-360">次に、最初のブラウザーインスタンスで、[編集] ボタンをクリックし、製品名を "Chai 紅茶" から "Chai" に変更し、[更新] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="68c00-361">2番目のブラウザーウィンドウで、[Chai] の [削除] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="68c00-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="68c00-362">[削除] をクリックすると、ページがポストバックされ、GridView が ObjectDataSource の `Delete()` メソッドを呼び出し、ObjectDataSource が `ProductsOptimisticConcurrencyBLL` クラスの `DeleteProduct` メソッドに戻り、元の値が渡されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="68c00-363">2番目のブラウザーインスタンスの元の `ProductName` 値は "Chai 紅茶" で、データベース内の現在の `ProductName` 値と一致しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="68c00-364">したがって、データベースに対して発行された `DELETE` ステートメントは、`WHERE` 句が満たすレコードがないため、0行に影響します。</span><span class="sxs-lookup"><span data-stu-id="68c00-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="68c00-365">`DeleteProduct` メソッドは `false` を返し、ObjectDataSource のデータは GridView に再バインドされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="68c00-366">エンドユーザーの観点からは、2番目のブラウザーウィンドウで [Chai 茶] の [削除] ボタンをクリックすると、画面が点滅します。その後、製品はまだ存在しますが、"Chai" (最初のブラウザーによって行われた製品名の変更) として表示されます。インスタンス)。</span><span class="sxs-lookup"><span data-stu-id="68c00-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="68c00-367">ユーザーが [削除] ボタンをもう一度クリックした場合、GridView の元の `ProductName` 値 ("Chai") がデータベースの値と一致するため、削除は成功します。</span><span class="sxs-lookup"><span data-stu-id="68c00-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="68c00-368">どちらの場合も、ユーザーエクスペリエンスは理想的なものになります。</span><span class="sxs-lookup"><span data-stu-id="68c00-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="68c00-369">バッチ更新パターンを使用する場合、`DBConcurrencyException` 例外の詳細をユーザーに表示しないことは明らかです。</span><span class="sxs-lookup"><span data-stu-id="68c00-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="68c00-370">また、DB direct パターンを使用する場合の動作は、ユーザーコマンドが失敗したときに多少わかりにくいことがありますが、その理由について正確に示す情報はありませんでした。</span><span class="sxs-lookup"><span data-stu-id="68c00-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="68c00-371">この2つの問題を解決するには、ページにラベル Web コントロールを作成し、更新または削除が失敗した理由を説明します。</span><span class="sxs-lookup"><span data-stu-id="68c00-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="68c00-372">バッチ更新パターンでは、GridView のポストレベルイベントハンドラーで `DBConcurrencyException` 例外が発生したかどうかを判断し、必要に応じて警告ラベルを表示できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="68c00-373">DB ダイレクトメソッドでは、BLL メソッドの戻り値 (1 つの行が影響を受けた場合は `true`、それ以外の場合は `false`) を確認し、必要に応じて情報メッセージを表示できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="68c00-374">手順 6: 情報メッセージを追加し、同時実行違反の発生時に表示する</span><span class="sxs-lookup"><span data-stu-id="68c00-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="68c00-375">同時実行違反が発生した場合の動作は、DAL のバッチ更新または DB ダイレクトパターンが使用されたかどうかによって異なります。</span><span class="sxs-lookup"><span data-stu-id="68c00-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="68c00-376">このチュートリアルでは、両方のパターンを使用します。更新に使用するバッチ更新パターンと、削除に使用する DB direct パターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="68c00-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="68c00-377">まず、データを削除または更新しようとしたときに同時実行違反が発生したことを説明する2つのラベル Web コントロールをページに追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="68c00-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="68c00-378">ラベルコントロールの `Visible` と `EnableViewState` プロパティを `false`に設定します。これにより、各ページにアクセスしたときに、その `Visible` プロパティがプログラムによって `true`に設定されている場合を除いて、各ページのアクセスで非表示になります。</span><span class="sxs-lookup"><span data-stu-id="68c00-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

<span data-ttu-id="68c00-379">`Visible`、`EnabledViewState`、および `Text` プロパティの設定に加えて、`CssClass` プロパティも `Warning`に設定しました。これにより、ラベルが大きい、赤、斜体、太字のフォントで表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="68c00-380">この CSS `Warning` クラスは、*挿入、更新、および削除*の各チュートリアルに関連付けられているイベントを調べることで、定義され、スタイルに追加されました。</span><span class="sxs-lookup"><span data-stu-id="68c00-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="68c00-381">これらのラベルを追加すると、Visual Studio のデザイナーは図18のようになります。</span><span class="sxs-lookup"><span data-stu-id="68c00-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>

<span data-ttu-id="68c00-382">[2つのラベルコントロールがページに追加され ![](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span></span>

<span data-ttu-id="68c00-383">**図 18**: ページに2つのラベルコントロールが追加されました ([クリックすると、フルサイズの画像が表示](implementing-optimistic-concurrency-cs/_static/image52.png)されます)</span><span class="sxs-lookup"><span data-stu-id="68c00-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image52.png))</span></span>

<span data-ttu-id="68c00-384">これらのラベルの Web コントロールを使用して、同時実行違反が発生したことを判断する方法を調べる準備ができました。その時点で、適切なラベルの `Visible` プロパティを `true`に設定して、情報メッセージを表示することができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="68c00-385">更新時の同時実行違反の処理</span><span class="sxs-lookup"><span data-stu-id="68c00-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="68c00-386">まず、バッチ更新パターンを使用するときに、同時実行違反を処理する方法を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="68c00-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="68c00-387">バッチ更新パターンによるこのような違反によって `DBConcurrencyException` 例外がスローされるため、更新プロセス中に `DBConcurrencyException` 例外が発生したかどうかを確認するコードを ASP.NET ページに追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="68c00-388">その場合は、ユーザーがレコードの編集を開始してから [更新] ボタンをクリックしたときとの間で、他のユーザーが同じデータを変更したため、変更が保存されていないことを示すメッセージがユーザーに表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="68c00-389">ASP.NET ページのチュートリアルでは、 *BLL と DAL レベルの例外の処理*について説明しましたが、このような例外は、データ Web コントロールの post レベルのイベントハンドラーで検出および抑制することができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="68c00-390">そのため、`DBConcurrencyException` 例外がスローされたかどうかを確認する GridView の `RowUpdated` イベントのイベントハンドラーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="68c00-391">このイベントハンドラーには、次のイベントハンドラーコードに示すように、更新プロセス中に発生した例外への参照が渡されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

<span data-ttu-id="68c00-392">`DBConcurrencyException` 例外が発生すると、このイベントハンドラーによって `UpdateConflictMessage` Label コントロールが表示され、例外が処理されたことが示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="68c00-393">このコードを配置すると、レコードの更新時に同時実行違反が発生した場合、ユーザーの変更は失われます。これは、ユーザーが同時に別のユーザーの変更を上書きしたためです。</span><span class="sxs-lookup"><span data-stu-id="68c00-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="68c00-394">特に、GridView は編集前の状態に戻り、現在のデータベースデータにバインドされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="68c00-395">これにより、以前は表示されていなかった他のユーザーの変更で GridView 行が更新されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="68c00-396">さらに、`UpdateConflictMessage` ラベルコントロールは、発生したことをユーザーに説明します。</span><span class="sxs-lookup"><span data-stu-id="68c00-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="68c00-397">この一連のイベントについては、図19で詳しく説明します。</span><span class="sxs-lookup"><span data-stu-id="68c00-397">This sequence of events is detailed in Figure 19.</span></span>

<span data-ttu-id="68c00-398">[同時実行違反の発生時にユーザーの更新が失われる ![](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span></span>

<span data-ttu-id="68c00-399">**図 19**: 同時実行違反が発生したときにユーザーの更新が失われる ([クリックしてフルサイズの画像を表示する](implementing-optimistic-concurrency-cs/_static/image55.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image55.png))</span></span>

> [!NOTE]
> <span data-ttu-id="68c00-400">または、GridView を編集前の状態に戻すのではなく、渡された `GridViewUpdatedEventArgs` オブジェクトの `KeepInEditMode` プロパティを true に設定して、GridView を編集中の状態にしておくこともできます。</span><span class="sxs-lookup"><span data-stu-id="68c00-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="68c00-401">ただし、この方法を使用する場合は、(`DataBind()` メソッドを呼び出して) GridView にデータを再バインドし、他のユーザーの値が編集インターフェイスに読み込まれるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="68c00-402">このチュートリアルでダウンロードできるコードは、コメントアウトされた `RowUpdated` のイベントハンドラーに、次の2行のコードが含まれています。これらのコード行をコメント解除するだけで、同時実行違反の後に GridView を編集モードのままにすることができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>

## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="68c00-403">同時実行違反への応答 (削除時)</span><span class="sxs-lookup"><span data-stu-id="68c00-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="68c00-404">DB direct パターンでは、同時実行違反の発生時に例外は発生しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="68c00-405">代わりに、WHERE 句がどのレコードとも一致しないため、データベースステートメントは単にレコードに影響しません。</span><span class="sxs-lookup"><span data-stu-id="68c00-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="68c00-406">BLL で作成されたすべてのデータ変更メソッドは、正確に1つのレコードに影響を与えたかどうかを示すブール値を返すように設計されています。</span><span class="sxs-lookup"><span data-stu-id="68c00-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="68c00-407">そのため、レコードの削除時に同時実行違反が発生したかどうかを判断するには、BLL の `DeleteProduct` メソッドの戻り値を確認します。</span><span class="sxs-lookup"><span data-stu-id="68c00-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="68c00-408">BLL メソッドの戻り値は、ObjectDataSource のポストレベルのイベントハンドラーで、イベントハンドラーに渡された `ObjectDataSourceStatusEventArgs` オブジェクトの `ReturnValue` プロパティを使用して調べることができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="68c00-409">`DeleteProduct` メソッドから戻り値を決定することに関心があるため、ObjectDataSource の `Deleted` イベント用のイベントハンドラーを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="68c00-410">`ReturnValue` プロパティは `object` 型であり、例外が発生した場合に `null` できます。また、メソッドは、値を返す前に中断されています。</span><span class="sxs-lookup"><span data-stu-id="68c00-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="68c00-411">したがって、最初に `ReturnValue` プロパティが `null` ではなく、ブール値であることを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="68c00-412">このチェックに合格すると、`ReturnValue` が `false`場合は、`DeleteConflictMessage` Label コントロールが表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="68c00-413">これは、次のコードを使用して実現できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-413">This can be accomplished by using the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

<span data-ttu-id="68c00-414">同時実行違反が発生した場合、ユーザーの削除要求は取り消されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="68c00-415">GridView が更新され、ユーザーがページを読み込んだときと [削除] ボタンをクリックしたときの間で、そのレコードに対して発生した変更が表示されます。</span><span class="sxs-lookup"><span data-stu-id="68c00-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="68c00-416">このような違反が発生した場合は、`DeleteConflictMessage` ラベルが表示され、何が起こったかがわかります (図20を参照)。</span><span class="sxs-lookup"><span data-stu-id="68c00-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>

<span data-ttu-id="68c00-417">[同時実行違反の発生時にユーザーの削除が取り消さ ![](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="68c00-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span></span>

<span data-ttu-id="68c00-418">**図 20**: 同時実行違反が発生したときにユーザーの削除が取り消される ([クリックしてフルサイズのイメージを表示する](implementing-optimistic-concurrency-cs/_static/image58.png))</span><span class="sxs-lookup"><span data-stu-id="68c00-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image58.png))</span></span>

## <a name="summary"></a><span data-ttu-id="68c00-419">要約</span><span class="sxs-lookup"><span data-stu-id="68c00-419">Summary</span></span>

<span data-ttu-id="68c00-420">同時実行ユーザーが複数のデータを更新または削除できるようにするすべてのアプリケーションには、同時実行違反の可能性があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="68c00-421">このような違反が考慮されていない場合、2人のユーザーが前回の書き込みで取得した同じデータを同時に更新すると、他のユーザーの変更が上書きされます。</span><span class="sxs-lookup"><span data-stu-id="68c00-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="68c00-422">また、開発者はオプティミスティックまたはペシミスティック同時実行制御を実装できます。</span><span class="sxs-lookup"><span data-stu-id="68c00-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="68c00-423">オプティミスティック同時実行制御では、同時実行違反が頻繁に発生しないことを前提としています。また、単に、同時実行違反を構成する update または delete コマンドを禁止します</span><span class="sxs-lookup"><span data-stu-id="68c00-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="68c00-424">ペシミスティック同時実行制御は、同時実行違反が頻繁に発生することを前提としており、1人のユーザーの update コマンドまたは delete コマンドを拒否するだけでは許容できません。</span><span class="sxs-lookup"><span data-stu-id="68c00-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="68c00-425">ペシミスティック同時実行制御では、レコードを更新することによって、ロックされている間に他のユーザーがレコードを変更または削除できないようにします。</span><span class="sxs-lookup"><span data-stu-id="68c00-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="68c00-426">.NET の型指定されたデータセットは、オプティミスティック同時実行制御をサポートするための機能を提供します。</span><span class="sxs-lookup"><span data-stu-id="68c00-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="68c00-427">特に、データベースに対して発行された `UPDATE` および `DELETE` ステートメントには、テーブルのすべての列が含まれているので、レコードの現在のデータが、更新または削除の実行時にユーザーが持っていた元のデータと一致する場合にのみ、更新または削除が行われます。</span><span class="sxs-lookup"><span data-stu-id="68c00-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="68c00-428">DAL がオプティミスティック同時実行制御をサポートするように構成されたら、BLL メソッドを更新する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="68c00-429">また、BLL にコールダウンする ASP.NET ページを構成して、ObjectDataSource がデータ Web コントロールから元の値を取得し、BLL に渡すようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="68c00-430">このチュートリアルで説明したように、ASP.NET web アプリケーションにオプティミスティック同時実行制御を実装するには、DAL を更新して、ASP.NET ページにサポートを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="68c00-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="68c00-431">この追加の作業が時間と労力を費やすかどうかは、アプリケーションによって異なります。</span><span class="sxs-lookup"><span data-stu-id="68c00-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="68c00-432">同時実行ユーザーがデータを更新していない場合、または更新しようとしているデータが相互に異なる場合は、同時実行制御が重要な問題にはなりません。</span><span class="sxs-lookup"><span data-stu-id="68c00-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="68c00-433">ただし、サイトの複数のユーザーが同じデータを使用している場合、同時実行制御を使用すると、1人のユーザーの更新や削除によって他のが誤って上書きされるのを防ぐことができます。</span><span class="sxs-lookup"><span data-stu-id="68c00-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="68c00-434">プログラミングを楽しんでください。</span><span class="sxs-lookup"><span data-stu-id="68c00-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="68c00-435">作成者について</span><span class="sxs-lookup"><span data-stu-id="68c00-435">About the Author</span></span>

<span data-ttu-id="68c00-436">1998以来、 [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)は 7 asp/創設者 of [4GuysFromRolla.com](http://www.4guysfromrolla.com)の執筆者であり、Microsoft Web テクノロジを使用しています。</span><span class="sxs-lookup"><span data-stu-id="68c00-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="68c00-437">Scott は、独立したコンサルタント、トレーナー、およびライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="68c00-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="68c00-438">彼の最新の書籍は[ *、ASP.NET 2.0 を24時間以内に教え*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ています。</span><span class="sxs-lookup"><span data-stu-id="68c00-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="68c00-439">mitchell@4GuysFromRolla.comでアクセスでき[ます。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="68c00-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="68c00-440">または彼のブログを参照してください。これは[http://ScottOnWriting.NET](http://ScottOnWriting.NET)にあります。</span><span class="sxs-lookup"><span data-stu-id="68c00-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="68c00-441">[前へ](customizing-the-data-modification-interface-cs.md)
> [次へ](adding-client-side-confirmation-when-deleting-cs.md)</span><span class="sxs-lookup"><span data-stu-id="68c00-441">[Previous](customizing-the-data-modification-interface-cs.md)
[Next](adding-client-side-confirmation-when-deleting-cs.md)</span></span>
