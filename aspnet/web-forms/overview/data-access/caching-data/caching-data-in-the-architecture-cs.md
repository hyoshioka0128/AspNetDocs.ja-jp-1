---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: アーキテクチャでデータをキャッシュするC#() |Microsoft Docs
author: rick-anderson
description: 前のチュートリアルでは、プレゼンテーション層でキャッシュを適用する方法を学習しました。 このチュートリアルでは、階層型アーキテクチャを活用する方法について説明します。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 192cadb8e2f862ac2a97a36b375e247b281ece93
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78443728"
---
# <a name="caching-data-in-the-architecture-c"></a><span data-ttu-id="047e2-104">アーキテクチャでデータをキャッシュする (C#)</span><span class="sxs-lookup"><span data-stu-id="047e2-104">Caching Data in the Architecture (C#)</span></span>

<span data-ttu-id="047e2-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="047e2-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="047e2-106">[サンプルアプリのダウンロード](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe)または[PDF のダウンロード](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="047e2-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) or [Download PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span></span>

> <span data-ttu-id="047e2-107">前のチュートリアルでは、プレゼンテーション層でキャッシュを適用する方法を学習しました。</span><span class="sxs-lookup"><span data-stu-id="047e2-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="047e2-108">このチュートリアルでは、階層型アーキテクチャを利用してビジネスロジック層でデータをキャッシュする方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="047e2-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="047e2-109">これを行うには、アーキテクチャを拡張してキャッシュレイヤーを含めます。</span><span class="sxs-lookup"><span data-stu-id="047e2-109">We do this by extending the architecture to include a Caching Layer.</span></span>

## <a name="introduction"></a><span data-ttu-id="047e2-110">はじめに</span><span class="sxs-lookup"><span data-stu-id="047e2-110">Introduction</span></span>

<span data-ttu-id="047e2-111">前のチュートリアルで見たように、ObjectDataSource のデータのキャッシュは、いくつかのプロパティを設定するのと同じように簡単に行うことができます。</span><span class="sxs-lookup"><span data-stu-id="047e2-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="047e2-112">残念ながら、ObjectDataSource はプレゼンテーション層でキャッシュを適用し、キャッシュポリシーと ASP.NET ページを密に結合します。</span><span class="sxs-lookup"><span data-stu-id="047e2-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="047e2-113">階層型アーキテクチャを作成する理由の1つは、このような結合が壊れることを許可することです。</span><span class="sxs-lookup"><span data-stu-id="047e2-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="047e2-114">たとえば、ビジネスロジック層は、ASP.NET ページからビジネスロジックを分離し、データアクセス層はデータアクセスの詳細を分離します。</span><span class="sxs-lookup"><span data-stu-id="047e2-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="047e2-115">ビジネスロジックとデータアクセスの詳細の分離は、システムが読みやすく、保守が容易で、変更が柔軟な場合にも使用することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="047e2-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="047e2-116">また、ドメインの知識と労力の分担も可能です。プレゼンテーション層で作業する開発者は、自分の仕事を行うためにデータベースの詳細について理解している必要はありません。</span><span class="sxs-lookup"><span data-stu-id="047e2-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="047e2-117">プレゼンテーション層からキャッシュポリシーを分離すると、同様の利点が得られます。</span><span class="sxs-lookup"><span data-stu-id="047e2-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="047e2-118">このチュートリアルでは、キャッシュポリシーを使用する*キャッシュレイヤー* (短い場合は CL) を含めるようにアーキテクチャを拡張します。</span><span class="sxs-lookup"><span data-stu-id="047e2-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="047e2-119">キャッシュレイヤーには、`GetProducts()`、`GetProductsByCategoryID(categoryID)`などのメソッドを使用して製品情報へのアクセスを提供する `ProductsCL` クラスが含まれます。このクラスは、呼び出されると、最初にキャッシュからデータを取得しようとします。</span><span class="sxs-lookup"><span data-stu-id="047e2-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="047e2-120">キャッシュが空の場合、これらのメソッドは BLL の適切な `ProductsBLL` メソッドを呼び出します。これにより、DAL からデータが取得されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="047e2-121">`ProductsCL` メソッドは、BLL から取得したデータをキャッシュしてから返します。</span><span class="sxs-lookup"><span data-stu-id="047e2-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="047e2-122">図1に示すように、CL はプレゼンテーション層とビジネスロジック層の間に配置されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>

![キャッシュレイヤー (CL) は、アーキテクチャにおけるもう1つのレイヤーです。](caching-data-in-the-architecture-cs/_static/image1.png)

<span data-ttu-id="047e2-124">**図 1**: キャッシュレイヤー (CL) は、アーキテクチャにおけるもう1つのレイヤーです。</span><span class="sxs-lookup"><span data-stu-id="047e2-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>

## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="047e2-125">手順 1: キャッシュレイヤークラスの作成</span><span class="sxs-lookup"><span data-stu-id="047e2-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="047e2-126">このチュートリアルでは、少数のメソッドのみを持つ1つのクラス `ProductsCL` を持つ非常に単純な CL を作成します。</span><span class="sxs-lookup"><span data-stu-id="047e2-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="047e2-127">アプリケーション全体の完全なキャッシュレイヤーを構築するには、`CategoriesCL`、`EmployeesCL`、および `SuppliersCL` クラスを作成し、BLL の各データアクセスまたは変更メソッドに対して、これらのキャッシュ層クラスのメソッドを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="047e2-128">BLL と DAL と同様に、キャッシュレイヤーは、個別のクラスライブラリプロジェクトとして実装するのが理想的です。ただし、これは `App_Code` フォルダーのクラスとして実装します。</span><span class="sxs-lookup"><span data-stu-id="047e2-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="047e2-129">DAL クラスと BLL クラスの CL クラスをより明確に分離するには、`App_Code` フォルダーに新しいサブフォルダーを作成します。</span><span class="sxs-lookup"><span data-stu-id="047e2-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="047e2-130">ソリューションエクスプローラーで `App_Code` フォルダーを右クリックし、[新しいフォルダー] を選択して、新しいフォルダーに `CL`という名前を指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="047e2-131">このフォルダーを作成したら、`ProductsCL.cs`という名前の新しいクラスを追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-131">After creating this folder, add to it a new class named `ProductsCL.cs`.</span></span>

![CL という名前の新しいフォルダーと ProductsCL.cs という名前のクラスを追加します。](caching-data-in-the-architecture-cs/_static/image2.png)

<span data-ttu-id="047e2-133">**図 2**: `CL` という名前の新しいフォルダーとという名前のクラスを追加する `ProductsCL.cs`</span><span class="sxs-lookup"><span data-stu-id="047e2-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.cs`</span></span>

<span data-ttu-id="047e2-134">`ProductsCL` クラスには、対応するビジネスロジックレイヤークラス (`ProductsBLL`) にあるものと同じデータアクセスおよび変更メソッドのセットを含める必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="047e2-135">これらのメソッドをすべて作成するのではなく、ここでいくつかのコードを作成して、CL で使用されるパターンの感覚を得ます。</span><span class="sxs-lookup"><span data-stu-id="047e2-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="047e2-136">具体的には、手順 3. の `GetProducts()` と `GetProductsByCategoryID(categoryID)` のメソッドと、手順 4. の `UpdateProduct` オーバーロードを追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="047e2-137">残りの `ProductsCL` メソッド、`CategoriesCL`、`EmployeesCL`、および `SuppliersCL` クラスを、都合のよいときに追加できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="047e2-138">手順 2: データキャッシュの読み取りと書き込み</span><span class="sxs-lookup"><span data-stu-id="047e2-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="047e2-139">前のチュートリアルで説明した ObjectDataSource キャッシュ機能では、内部的に ASP.NET データキャッシュを使用して、BLL から取得したデータを格納します。</span><span class="sxs-lookup"><span data-stu-id="047e2-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="047e2-140">データキャッシュは、ASP.NET pages 分離コードクラスから、または web アプリケーションのアーキテクチャのクラスから、プログラムによってアクセスすることもできます。</span><span class="sxs-lookup"><span data-stu-id="047e2-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="047e2-141">ASP.NET ページの分離コードクラスからデータキャッシュの読み取りと書き込みを行うには、次のパターンを使用します。</span><span class="sxs-lookup"><span data-stu-id="047e2-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

<span data-ttu-id="047e2-142">[`Cache` クラス](https://msdn.microsoft.com/library/system.web.caching.cache.aspx)s [`Insert` メソッド](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)には、多くのオーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="047e2-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="047e2-143">`Cache["key"] = value` と `Cache.Insert(key, value)` は同義であり、有効期限が定義されていなくても、指定したキーを使用してキャッシュに項目を追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-143">`Cache["key"] = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="047e2-144">通常は、キャッシュに項目を追加するときに、依存関係、時間ベースの有効期限、またはその両方の有効期限を指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="047e2-145">他の `Insert` メソッドのオーバーロードのいずれかを使用して、依存関係または時間ベースの有効期限情報を指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="047e2-146">キャッシュレイヤーのメソッドは、要求されたデータがキャッシュ内にあるかどうかを最初に確認し、存在する場合はそこから返す必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="047e2-147">要求されたデータがキャッシュにない場合は、適切な BLL メソッドを呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="047e2-148">次のシーケンス図に示すように、戻り値はキャッシュしてから返される必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>

![キャッシュレイヤーのメソッドは、使用可能な場合は、キャッシュからデータを返します。](caching-data-in-the-architecture-cs/_static/image3.png)

<span data-ttu-id="047e2-150">**図 3**: キャッシュレイヤーのメソッドが、使用可能な場合はキャッシュからデータを返す</span><span class="sxs-lookup"><span data-stu-id="047e2-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>

<span data-ttu-id="047e2-151">図3に示されているシーケンスは、次のパターンを使用して、CL クラスで実行されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

<span data-ttu-id="047e2-152">ここで、 *type*はキャッシュ `Northwind.ProductsDataTable`に格納されているデータの種類です。たとえば、 *key*はキャッシュ項目を一意に識別するキーです。</span><span class="sxs-lookup"><span data-stu-id="047e2-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="047e2-153">指定した*キー*を持つ項目がキャッシュ内にない場合、*インスタンス*は `null` され、データは適切な BLL メソッドから取得され、キャッシュに追加されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-153">If the item with the specified *key* is not in the cache, then *instance* will be `null` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="047e2-154">*インスタンス*には `return instance` に達した時点で、キャッシュから、または BLL からプルしたデータへの参照が格納されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-154">By the time `return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="047e2-155">キャッシュからデータにアクセスするときは、必ず上記のパターンを使用してください。</span><span class="sxs-lookup"><span data-stu-id="047e2-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="047e2-156">次のパターンは、一見しても同じように見えますが、競合状態を示す微妙な違いがあります。</span><span class="sxs-lookup"><span data-stu-id="047e2-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="047e2-157">競合状態は散発的に見え、再現が困難なため、デバッグが困難です。</span><span class="sxs-lookup"><span data-stu-id="047e2-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

<span data-ttu-id="047e2-158">この2番目のコードスニペットの違いは、キャッシュされた項目への参照をローカル変数に格納するのではなく、条件付きステートメント*および*`return`でデータキャッシュに直接アクセスすることです。</span><span class="sxs-lookup"><span data-stu-id="047e2-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `return`.</span></span> <span data-ttu-id="047e2-159">このコードに達したときに、`Cache["key"]` が非`null`であり、`return` ステートメントに到達する前に、システムはキャッシュから*キー*を見つけしていると仮定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-159">Imagine that when this code is reached, `Cache["key"]` is non-`null`, but before the `return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="047e2-160">このまれなケースでは、コードは、予期された型のオブジェクトではなく `null` 値を返します。</span><span class="sxs-lookup"><span data-stu-id="047e2-160">In this rare case, the code will return a `null` value rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="047e2-161">データキャッシュはスレッドセーフであるため、単純な読み取りまたは書き込みのためにスレッドアクセスを同期する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="047e2-161">The data cache is thread-safe, so you don t need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="047e2-162">ただし、アトミックである必要があるキャッシュ内のデータに対して複数の操作を実行する必要がある場合は、ロックまたはその他のメカニズムを実装してスレッドセーフを確保する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="047e2-163">詳細について[は、「ASP.NET Cache へのアクセスの同期](http://www.ddj.com/184406369)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="047e2-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>

<span data-ttu-id="047e2-164">項目は、次のように[`Remove` メソッド](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)を使用して、プログラムによってデータキャッシュから削除できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="047e2-165">手順 3:`ProductsCL`クラスから製品情報を取得する</span><span class="sxs-lookup"><span data-stu-id="047e2-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="047e2-166">このチュートリアルでは、を使用して `ProductsCL` クラスから製品情報を返す2つのメソッドを実装します。 `GetProducts()` と `GetProductsByCategoryID(categoryID)`です。</span><span class="sxs-lookup"><span data-stu-id="047e2-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="047e2-167">ビジネスロジック層の `ProductsBL` クラスと同様に、CL の `GetProducts()` メソッドは、すべての製品に関する情報を `Northwind.ProductsDataTable` オブジェクトとして返します。一方、`GetProductsByCategoryID(categoryID)` は指定したカテゴリのすべての製品を返します。</span><span class="sxs-lookup"><span data-stu-id="047e2-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="047e2-168">次のコードは、`ProductsCL` クラスのメソッドの一部を示しています。</span><span class="sxs-lookup"><span data-stu-id="047e2-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

<span data-ttu-id="047e2-169">まず、クラスとメソッドに適用されている属性 `DataObject` と `DataObjectMethodAttribute` を確認します。</span><span class="sxs-lookup"><span data-stu-id="047e2-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="047e2-170">これらの属性は、ObjectDataSource s ウィザードに情報を提供し、ウィザードのステップでどのクラスとメソッドを表示するかを示します。</span><span class="sxs-lookup"><span data-stu-id="047e2-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="047e2-171">CL のクラスとメソッドは、プレゼンテーション層の ObjectDataSource からアクセスされるため、デザイン時のエクスペリエンスを向上させるためにこれらの属性を追加しました。</span><span class="sxs-lookup"><span data-stu-id="047e2-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="047e2-172">これらの属性とその効果の詳細については、「[ビジネスロジック層の作成](../introduction/creating-a-business-logic-layer-cs.md)」チュートリアルを参照してください。</span><span class="sxs-lookup"><span data-stu-id="047e2-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-cs.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="047e2-173">`GetProducts()` メソッドと `GetProductsByCategoryID(categoryID)` メソッドでは、`GetCacheItem(key)` メソッドから返されたデータがローカル変数に割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="047e2-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="047e2-174">`GetCacheItem(key)` メソッドは、後で確認します。指定された*キー*に基づいてキャッシュから特定の項目を返します。</span><span class="sxs-lookup"><span data-stu-id="047e2-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="047e2-175">このようなデータがキャッシュに見つからない場合は、対応する `ProductsBLL` クラスメソッドから取得され、`AddCacheItem(key, value)` メソッドを使用してキャッシュに追加されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="047e2-176">`GetCacheItem(key)` および `AddCacheItem(key, value)` メソッドは、データキャッシュを使用して、値の読み取りと書き込みをそれぞれ行います。</span><span class="sxs-lookup"><span data-stu-id="047e2-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="047e2-177">`GetCacheItem(key)` メソッドは、この2つの方法よりも単純です。</span><span class="sxs-lookup"><span data-stu-id="047e2-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="047e2-178">単に、渡された*キー*を使用して Cache クラスから値を返します。</span><span class="sxs-lookup"><span data-stu-id="047e2-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

<span data-ttu-id="047e2-179">`GetCacheItem(key)` は、指定されたとおりに*キー*値を使用しませんが、代わりに、ProductsCache-を付加した*キー*を返す `GetCacheKey(key)` メソッドを呼び出します。</span><span class="sxs-lookup"><span data-stu-id="047e2-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="047e2-180">文字列 ProductsCache を保持する `MasterCacheKeyArray`も `AddCacheItem(key, value)` メソッドによって使用されます。これは、後で説明するようになります。</span><span class="sxs-lookup"><span data-stu-id="047e2-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="047e2-181">ASP.NET page s 分離コードクラスからは、`Page` クラス s [`Cache` プロパティ](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)を使用してデータキャッシュにアクセスできます。手順 2. で説明したように、`Cache["key"] = value`のような構文を使用できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache["key"] = value`, as discussed in Step 2.</span></span> <span data-ttu-id="047e2-182">アーキテクチャ内のクラスから、`HttpRuntime.Cache` または `HttpContext.Current.Cache`を使用してデータキャッシュにアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="047e2-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="047e2-183">[Peter ジョンソン](https://weblogs.asp.net/pjohnson/default.aspx)のブログエントリ[HttpRuntime](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)と、キャッシュに関する記事では、`HttpContext.Current`ではなく `HttpRuntime` を使用する場合のわずかなパフォーマンス上の利点について説明しています。そのため、`ProductsCL` は `HttpRuntime`を使用します。</span><span class="sxs-lookup"><span data-stu-id="047e2-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="047e2-184">クラスライブラリプロジェクトを使用してアーキテクチャを実装する場合は、 [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)クラスと[HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)クラスを使用するために、`System.Web` アセンブリへの参照を追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>

<span data-ttu-id="047e2-185">項目がキャッシュ内で見つからない場合、`ProductsCL` クラスのメソッドは、BLL からデータを取得し、`AddCacheItem(key, value)` メソッドを使用してそのデータをキャッシュに追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="047e2-186">キャッシュに*値*を追加するには、60秒の有効期限を使用する次のコードを使用できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

<span data-ttu-id="047e2-187">`DateTime.Now.AddSeconds(CacheDuration)` は、時間ベースの有効期限60秒を指定し、 [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)はスライド式有効期限がないことを示します。</span><span class="sxs-lookup"><span data-stu-id="047e2-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="047e2-188">この `Insert` メソッドオーバーロードには、絶対有効期限とスライド式有効期限の両方の入力パラメーターがありますが、どちらか1つしか指定できません。</span><span class="sxs-lookup"><span data-stu-id="047e2-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="047e2-189">絶対時刻と時間範囲の両方を指定しようとすると、`Insert` メソッドによって `ArgumentException` 例外がスローされます。</span><span class="sxs-lookup"><span data-stu-id="047e2-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="047e2-190">現在、この `AddCacheItem(key, value)` メソッドの実装にはいくつかの欠点があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="047e2-191">これらの問題については、手順 4. で説明します。</span><span class="sxs-lookup"><span data-stu-id="047e2-191">We'll address and overcome these issues in Step 4.</span></span>

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="047e2-192">手順 4: アーキテクチャを使用してデータが変更されたときにキャッシュを無効にする</span><span class="sxs-lookup"><span data-stu-id="047e2-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="047e2-193">キャッシュレイヤーでは、データの取得方法と共に、データの挿入、更新、および削除のために、BLL と同じメソッドを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="047e2-194">CL s のデータ変更メソッドは、キャッシュされたデータを変更するのではなく、BLL の対応するデータ変更メソッドを呼び出してから、キャッシュを無効にします。</span><span class="sxs-lookup"><span data-stu-id="047e2-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="047e2-195">前のチュートリアルで説明したように、これは、キャッシュ機能が有効になっており、その `Insert`、`Update`、または `Delete` メソッドが呼び出されたときに ObjectDataSource が適用される動作と同じです。</span><span class="sxs-lookup"><span data-stu-id="047e2-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="047e2-196">次の `UpdateProduct` オーバーロードは、データ変更メソッドを CL で実装する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="047e2-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

<span data-ttu-id="047e2-197">適切なデータ変更ビジネスロジックレイヤーメソッドが呼び出されますが、応答が返される前に、キャッシュを無効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="047e2-198">残念ながら、`ProductsCL` クラス s `GetProducts()` と `GetProductsByCategoryID(categoryID)` メソッドがそれぞれ異なるキーを使用してキャッシュに項目を追加するため、キャッシュを無効にするのは簡単ではありません。また、`GetProductsByCategoryID(categoryID)` メソッドによって、一意の*categoryID*ごとに異なるキャッシュ項目が追加されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="047e2-199">キャッシュを無効にする場合は、`ProductsCL` クラスによって追加された可能性のある*すべて*の項目を削除する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="047e2-200">これは、`AddCacheItem(key, value)` メソッドでキャッシュに追加された各項目と*キャッシュの依存関係*を関連付けることによって実現できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="047e2-201">一般に、キャッシュの依存関係は、キャッシュ内の別の項目、ファイルシステム上のファイル、または Microsoft SQL Server データベースのデータにすることができます。</span><span class="sxs-lookup"><span data-stu-id="047e2-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="047e2-202">依存関係が変更されるか、キャッシュから削除されると、関連付けられているキャッシュ項目がキャッシュから自動的に削除されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="047e2-203">このチュートリアルでは、`ProductsCL` クラスによって追加されたすべての項目のキャッシュ依存関係として機能する追加の項目をキャッシュに作成します。</span><span class="sxs-lookup"><span data-stu-id="047e2-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="047e2-204">こうすることで、キャッシュの依存関係を削除するだけで、これらすべての項目をキャッシュから削除できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="047e2-205">では、このメソッドを使用してキャッシュに追加された各項目が1つのキャッシュ依存関係に関連付けられるように、`AddCacheItem(key, value)` メソッドを更新します。</span><span class="sxs-lookup"><span data-stu-id="047e2-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

<span data-ttu-id="047e2-206">`MasterCacheKeyArray` は、1つの値 ProductsCache を保持する文字列配列です。</span><span class="sxs-lookup"><span data-stu-id="047e2-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="047e2-207">まず、キャッシュ項目がキャッシュに追加され、現在の日付と時刻が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="047e2-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="047e2-208">キャッシュ項目が既に存在する場合は、更新されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="047e2-209">次に、キャッシュの依存関係が作成されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="047e2-210">[`CacheDependency` クラス](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)s コンストラクターには多くのオーバーロードがありますが、ここで使用されるコンストラクターには、2つの `string` 配列入力が必要です。</span><span class="sxs-lookup"><span data-stu-id="047e2-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `string` array inputs.</span></span> <span data-ttu-id="047e2-211">最初の1つは、依存関係として使用するファイルのセットを指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="047e2-212">ファイルベースの依存関係を使用しないため、最初の入力パラメーターには `null` の値が使用されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-212">Since we don t want to use any file-based dependencies, a value of `null` is used for the first input parameter.</span></span> <span data-ttu-id="047e2-213">2番目の入力パラメーターは、依存関係として使用するキャッシュキーのセットを指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="047e2-214">ここでは、1つの依存関係、`MasterCacheKeyArray`を指定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="047e2-215">その後、`CacheDependency` が `Insert` メソッドに渡されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="047e2-216">この変更を `AddCacheItem(key, value)`すると、invaliding は依存関係を削除するのと同じように簡単にキャッシュを解除できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="047e2-217">手順 5: プレゼンテーション層からキャッシュ層を呼び出す</span><span class="sxs-lookup"><span data-stu-id="047e2-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="047e2-218">キャッシュレイヤーのクラスとメソッドを使用して、これらのチュートリアル全体で調査した手法を使用してデータを操作できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="047e2-219">キャッシュされたデータを操作する方法を示すために、変更を `ProductsCL` クラスに保存し、`Caching` フォルダーの `FromTheArchitecture.aspx` ページを開き、GridView を追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="047e2-220">GridView s スマートタグから新しい ObjectDataSource を作成します。</span><span class="sxs-lookup"><span data-stu-id="047e2-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="047e2-221">ウィザードの最初のステップでは、`ProductsCL` クラスがドロップダウンリストのオプションの1つとして表示されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>

<span data-ttu-id="047e2-222">[ProductsCL クラスがビジネスオブジェクトのドロップダウンリストに含まれて ![](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="047e2-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span></span>

<span data-ttu-id="047e2-223">**図 4**: `ProductsCL` クラスはビジネスオブジェクトのドロップダウンリストに含まれています ([クリックすると、フルサイズの画像が表示](caching-data-in-the-architecture-cs/_static/image6.png)されます)</span><span class="sxs-lookup"><span data-stu-id="047e2-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image6.png))</span></span>

<span data-ttu-id="047e2-224">`ProductsCL`を選択したら、[次へ] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="047e2-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="047e2-225">[選択] タブのドロップダウンリストには、`GetProducts()` と `GetProductsByCategoryID(categoryID)` の2つの項目があり、[更新] タブには唯一の `UpdateProduct` オーバーロードがあります。</span><span class="sxs-lookup"><span data-stu-id="047e2-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="047e2-226">[選択] タブで `GetProducts()` メソッドを選択し、[更新] タブで `UpdateProducts` メソッドを選択し、[完了] をクリックします。</span><span class="sxs-lookup"><span data-stu-id="047e2-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>

<span data-ttu-id="047e2-227">[ProductsCL クラス s のメソッドがドロップダウンリストに表示され ![](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="047e2-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span></span>

<span data-ttu-id="047e2-228">**図 5**: `ProductsCL` クラス s のメソッドがドロップダウンリストに表示される ([クリックしてフルサイズのイメージを表示する](caching-data-in-the-architecture-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="047e2-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image9.png))</span></span>

<span data-ttu-id="047e2-229">ウィザードを完了すると、Visual Studio は ObjectDataSource s `OldValuesParameterFormatString` プロパティを `original_{0}` に設定し、適切なフィールドを GridView に追加します。</span><span class="sxs-lookup"><span data-stu-id="047e2-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="047e2-230">`OldValuesParameterFormatString` プロパティを既定値に戻して `{0}`を変更し、ページング、並べ替え、および編集をサポートするように GridView を構成します。</span><span class="sxs-lookup"><span data-stu-id="047e2-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="047e2-231">CL で使用される `UploadProducts` オーバーロードは、編集された製品名と価格のみを受け入れるため、これらのフィールドのみが編集可能になるように GridView を制限します。</span><span class="sxs-lookup"><span data-stu-id="047e2-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="047e2-232">前のチュートリアルでは、`ProductName`、`CategoryName`、および `UnitPrice` フィールドのフィールドを含む GridView を定義しています。</span><span class="sxs-lookup"><span data-stu-id="047e2-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="047e2-233">この書式設定と構造は自由にレプリケートできます。この場合、GridView および ObjectDataSource s 宣言マークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="047e2-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

<span data-ttu-id="047e2-234">この時点で、キャッシュレイヤーを使用するページがあります。</span><span class="sxs-lookup"><span data-stu-id="047e2-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="047e2-235">キャッシュの動作を確認するには、`ProductsCL` クラス s `GetProducts()` と `UpdateProduct` メソッドにブレークポイントを設定します。</span><span class="sxs-lookup"><span data-stu-id="047e2-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="047e2-236">ブラウザーでページにアクセスし、並べ替えとページングの際にコードをステップ実行して、キャッシュから取得されたデータを確認します。</span><span class="sxs-lookup"><span data-stu-id="047e2-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="047e2-237">次に、レコードを更新し、キャッシュが無効になっていることを確認します。これにより、データが GridView に再バインドされるときに、BLL から取得されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="047e2-238">この記事に付属するダウンロードで提供されているキャッシュレイヤーは完全ではありません。</span><span class="sxs-lookup"><span data-stu-id="047e2-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="047e2-239">このクラスには、1つのクラス (`ProductsCL`) のみが含まれています。これは、いくつかのメソッドにのみ使用できます。</span><span class="sxs-lookup"><span data-stu-id="047e2-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="047e2-240">さらに、CL (`~/Caching/FromTheArchitecture.aspx`) を使用するのは1つの ASP.NET ページのみですが、他のすべてのページは BLL を直接参照しています。</span><span class="sxs-lookup"><span data-stu-id="047e2-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="047e2-241">アプリケーションで CL の使用を計画している場合、プレゼンテーション層からのすべての呼び出しは CL に送られる必要があります。そのためには、CL のクラスとメソッドが、プレゼンテーション層で現在使用されている BLL のクラスとメソッドをカバーしている必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>

## <a name="summary"></a><span data-ttu-id="047e2-242">まとめ</span><span class="sxs-lookup"><span data-stu-id="047e2-242">Summary</span></span>

<span data-ttu-id="047e2-243">キャッシュは ASP.NET 2.0 s SqlDataSource および ObjectDataSource コントロールと共にプレゼンテーション層で適用できますが、理想的なキャッシュの役割はアーキテクチャの別の層に委任されます。</span><span class="sxs-lookup"><span data-stu-id="047e2-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="047e2-244">このチュートリアルでは、プレゼンテーション層とビジネスロジック層の間に存在するキャッシュレイヤーを作成しました。</span><span class="sxs-lookup"><span data-stu-id="047e2-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="047e2-245">キャッシュレイヤーは、BLL に存在し、プレゼンテーション層から呼び出されるクラスとメソッドの同じセットを提供する必要があります。</span><span class="sxs-lookup"><span data-stu-id="047e2-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="047e2-246">このチュートリアルで説明したキャッシュレイヤーの例と前のチュートリアルでは、*リアクティブな読み込み*が示されていました。</span><span class="sxs-lookup"><span data-stu-id="047e2-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="047e2-247">リアクティブ読み込みでは、データの要求が行われ、そのデータがキャッシュにない場合にのみ、データがキャッシュに読み込まれます。</span><span class="sxs-lookup"><span data-stu-id="047e2-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="047e2-248">データをキャッシュに*事前に読み込む*こともできます。これは、実際に必要になる前にデータをキャッシュに読み込む技法です。</span><span class="sxs-lookup"><span data-stu-id="047e2-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="047e2-249">次のチュートリアルでは、アプリケーションの起動時に静的値をキャッシュに格納する方法について、事前読み込みの例を示します。</span><span class="sxs-lookup"><span data-stu-id="047e2-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="047e2-250">プログラミングを楽しんでください。</span><span class="sxs-lookup"><span data-stu-id="047e2-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="047e2-251">著者について</span><span class="sxs-lookup"><span data-stu-id="047e2-251">About the Author</span></span>

<span data-ttu-id="047e2-252">1998以来、 [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)は 7 asp/創設者 of [4GuysFromRolla.com](http://www.4guysfromrolla.com)の執筆者であり、Microsoft Web テクノロジを使用しています。</span><span class="sxs-lookup"><span data-stu-id="047e2-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="047e2-253">Scott は、独立したコンサルタント、トレーナー、およびライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="047e2-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="047e2-254">彼の最新の書籍は[ *、ASP.NET 2.0 を24時間以内に教え*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ています。</span><span class="sxs-lookup"><span data-stu-id="047e2-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="047e2-255">mitchell@4GuysFromRolla.comでアクセスでき[ます。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="047e2-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="047e2-256">または彼のブログを参照してください。これは[http://ScottOnWriting.NET](http://ScottOnWriting.NET)にあります。</span><span class="sxs-lookup"><span data-stu-id="047e2-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="047e2-257">ありがとうございました。</span><span class="sxs-lookup"><span data-stu-id="047e2-257">Special Thanks To</span></span>

<span data-ttu-id="047e2-258">このチュートリアルシリーズは、役に立つ多くのレビュー担当者によってレビューされました。</span><span class="sxs-lookup"><span data-stu-id="047e2-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="047e2-259">このチュートリアルのリードレビュー担当者は、Teresa Murph でした。</span><span class="sxs-lookup"><span data-stu-id="047e2-259">Lead reviewer for this tutorial was Teresa Murph.</span></span> <span data-ttu-id="047e2-260">今後の MSDN 記事を確認することに興味がありますか?</span><span class="sxs-lookup"><span data-stu-id="047e2-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="047e2-261">その場合は、mitchell@4GuysFromRolla.comの行を削除[します。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="047e2-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="047e2-262">[前へ](caching-data-with-the-objectdatasource-cs.md)
> [次へ](caching-data-at-application-startup-cs.md)</span><span class="sxs-lookup"><span data-stu-id="047e2-262">[Previous](caching-data-with-the-objectdatasource-cs.md)
[Next](caching-data-at-application-startup-cs.md)</span></span>
