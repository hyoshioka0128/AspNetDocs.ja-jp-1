---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: アプリケーションの起動時にデータをC#キャッシュする () |Microsoft Docs
author: rick-anderson
description: どの Web アプリケーションでも、一部のデータは頻繁に使用され、一部のデータはあまり使用されません。 ASP.NET アプリケーション b のパフォーマンスを向上させることができます。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386552"
---
# <a name="caching-data-at-application-startup-c"></a><span data-ttu-id="af1b5-104">アプリケーションの起動時にデータをキャッシュする (C#)</span><span class="sxs-lookup"><span data-stu-id="af1b5-104">Caching Data at Application Startup (C#)</span></span>

<span data-ttu-id="af1b5-105">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="af1b5-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="af1b5-106">PDF のダウンロード</span><span class="sxs-lookup"><span data-stu-id="af1b5-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="af1b5-107">どの Web アプリケーションでも、一部のデータは頻繁に使用され、一部のデータはあまり使用されません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="af1b5-108">頻繁に使用されるデータ (キャッシュと呼ばれます) を事前に読み込むことで、ASP.NET アプリケーションのパフォーマンスを向上させることができます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as Caching.</span></span> <span data-ttu-id="af1b5-109">このチュートリアルでは、プロアクティブな読み込みの1つの方法を示します。この方法では、アプリケーションの起動時にデータをキャッシュに読み込みます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>

## <a name="introduction"></a><span data-ttu-id="af1b5-110">はじめに</span><span class="sxs-lookup"><span data-stu-id="af1b5-110">Introduction</span></span>

<span data-ttu-id="af1b5-111">前の2つのチュートリアルでは、プレゼンテーション層とキャッシュ層のデータのキャッシュについて説明しました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="af1b5-112">[Objectdatasource を使用したデータのキャッシュ](caching-data-with-the-objectdatasource-cs.md)では、objectdatasource のキャッシュ機能を使用して、プレゼンテーション層にデータをキャッシュする方法を検討しました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource's caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="af1b5-113">[アーキテクチャのデータをキャッシュ](caching-data-in-the-architecture-cs.md)することで、新しい個別のキャッシュレイヤーでキャッシュが検証されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="af1b5-114">これらのチュートリアルでは、どちらもデータキャッシュを使用した*リアクティブな読み込み*を使用していました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="af1b5-115">リアクティブ読み込みでは、データが要求されるたびに、システムはまずキャッシュ内にあるかどうかを確認します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-115">With reactive loading, each time the data is requested, the system first checks if it's in the cache.</span></span> <span data-ttu-id="af1b5-116">そうでない場合は、データベースなどの元のソースからデータを取得し、キャッシュに格納します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="af1b5-117">リアクティブ読み込みの主な利点は、実装が簡単になることです。</span><span class="sxs-lookup"><span data-stu-id="af1b5-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="af1b5-118">欠点の1つは、要求間での不均一なパフォーマンスです。</span><span class="sxs-lookup"><span data-stu-id="af1b5-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="af1b5-119">前のチュートリアルのキャッシュレイヤーを使用して製品情報を表示するページを想像してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="af1b5-120">このページに初めてアクセスしたとき、またはメモリの制約によってキャッシュデータが削除された後に初めてアクセスした場合、または指定した有効期限に達した場合は、データをデータベースから取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="af1b5-121">そのため、これらのユーザーの要求は、キャッシュによって処理されるユーザーの要求よりも長くかかります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="af1b5-122">*プロアクティブな読み込み*は、キャッシュされたデータを必要とする前に読み込むことによって、要求間でパフォーマンスを低下させる代替キャッシュ管理戦略を提供します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it's needed.</span></span> <span data-ttu-id="af1b5-123">通常、プロアクティブな読み込みでは、基になるデータが更新されたときに定期的にチェックされるか通知されるプロセスを使用します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="af1b5-124">その後、キャッシュを更新して最新の状態に保ちます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="af1b5-125">プロアクティブ読み込みは、基になるデータが低速データベース接続、Web サービス、またはその他の特に低速なデータソースから取得される場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="af1b5-126">ただし、このプロアクティブな読み込みには、変更を確認してキャッシュを更新するプロセスを作成、管理、および展開する必要があるため、実装がより困難になります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="af1b5-127">プロアクティブな読み込みの別のフレーバーと、このチュートリアルで調査する型は、アプリケーションの起動時にキャッシュにデータを読み込みます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="af1b5-128">この方法は、データベースルックアップテーブルのレコードなどの静的データをキャッシュする場合に特に便利です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="af1b5-129">プロアクティブとリアクティブの読み込みの違い、および長所、短所、実装に関する推奨事項の一覧については、「 [.NET Framework アプリケーションのキャッシュアーキテクチャガイド](https://msdn.microsoft.com/library/ms978498.aspx)」の[キャッシュの内容の管理](https://msdn.microsoft.com/library/ms978503.aspx)に関するセクションを参照してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="af1b5-130">手順 1: アプリケーションの起動時にキャッシュするデータを決定する</span><span class="sxs-lookup"><span data-stu-id="af1b5-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="af1b5-131">前の2つのチュートリアルで検証したリアクティブな読み込みを使用したキャッシュの例は、定期的に変更される可能性があり、生成に exorbitantly 時間がかかることのないデータでもうまく機能します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="af1b5-132">ただし、キャッシュされたデータが変更されない場合、リアクティブな読み込みで使用される有効期限は余分になります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="af1b5-133">同様に、キャッシュされているデータの生成に非常に長い時間がかかる場合、キャッシュが空であるという要求を持つユーザーは、基になるデータを取得する間に長時間待機する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="af1b5-134">アプリケーションの起動時に生成に非常に長い時間がかかる静的データとデータをキャッシュすることを検討してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="af1b5-135">データベースには動的で頻繁に変化する多くの値がありますが、ほとんどの場合、静的なデータが大量にあります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="af1b5-136">たとえば、ほぼすべてのデータモデルには、固定された一連の選択肢から特定の値を含む1つまたは複数の列があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="af1b5-137">`Patients` データベーステーブルには、`PrimaryLanguage` 列がある場合があります。この列の値のセットは、英語、スペイン語、フランス語、ロシア語、日本語などです。</span><span class="sxs-lookup"><span data-stu-id="af1b5-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="af1b5-138">多くの場合、これらの種類の列は*参照テーブル*を使用して実装されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="af1b5-139">文字列 English またはフランス語を `Patients` テーブルに格納するのではなく、一般的に2つの列 (一意の識別子と文字列の説明) を持つ2つのテーブルが作成されます。これには、可能な値ごとにレコードが含まれます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="af1b5-140">`Patients` テーブルの `PrimaryLanguage` 列には、対応する一意の識別子が参照テーブルに格納されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="af1b5-141">図1では、患者 John Doe の主要言語は英語ですが、Ed ジョンソンはロシア語です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-141">In Figure 1, patient John Doe's primary language is English, while Ed Johnson's is Russian.</span></span>

![言語テーブルは、患者テーブルによって使用されるルックアップテーブルです。](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="af1b5-143">**図 1**: `Languages` テーブルは `Patients` テーブルによって使用されるルックアップテーブルです。</span><span class="sxs-lookup"><span data-stu-id="af1b5-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>

<span data-ttu-id="af1b5-144">新しい患者を編集したり作成したりするためのユーザーインターフェイスには、`Languages` テーブルのレコードによって設定される使用可能な言語のドロップダウンリストが含まれます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="af1b5-145">キャッシュを使用しない場合、このインターフェイスにアクセスするたびに、システムによって `Languages` テーブルに対してクエリを実行する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="af1b5-146">これは、参照テーブルの値が非常に頻繁に変更されるため、無駄が不要であり、不要です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="af1b5-147">前のチュートリアルで検証したのと同じリアクティブ読み込み手法を使用して、`Languages` データをキャッシュできます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="af1b5-148">ただし、リアクティブな読み込みでは、時間ベースの有効期限が使用されますが、これは静的なルックアップテーブルデータには必要ありません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="af1b5-149">事後対応型の読み込みを使用したキャッシュは、キャッシュがまったくないことよりも優れていますが、アプリケーションの起動時に参照テーブルのデータをキャッシュに事前に読み込むことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="af1b5-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="af1b5-150">このチュートリアルでは、参照テーブルのデータとその他の静的な情報をキャッシュする方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="af1b5-151">手順 2: データをキャッシュするさまざまな方法を調べる</span><span class="sxs-lookup"><span data-stu-id="af1b5-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="af1b5-152">さまざまな方法を使用して、ASP.NET アプリケーションで情報をプログラムでキャッシュすることができます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="af1b5-153">前のチュートリアルでデータキャッシュを使用する方法については既に説明しました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="af1b5-154">また、*静的メンバー*または*アプリケーションの状態*を使用して、オブジェクトをプログラムでキャッシュすることもできます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="af1b5-155">クラスを使用する場合は、通常、クラスをインスタンス化してから、そのメンバーにアクセスできるようにする必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="af1b5-156">たとえば、ビジネスロジック層のクラスの1つからメソッドを呼び出すためには、まずクラスのインスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="af1b5-157">*Somemethod*を呼び出したり、何かの*プロパティ*を使用したりする前に、まず、`new` キーワードを使用してクラスのインスタンスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="af1b5-158">*Somemethod*とその他の*プロパティ*は、特定のインスタンスに関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="af1b5-159">これらのメンバーの有効期間は、関連付けられているオブジェクトの有効期間に関連付けられています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="af1b5-160">一方、*静的メンバー*は、クラスの*すべて*のインスタンス間で共有される変数、プロパティ、およびメソッドであり、その結果、クラスの有効期間が設定されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="af1b5-161">静的メンバーは、キーワード `static`によって示されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="af1b5-162">静的メンバーに加えて、アプリケーションの状態を使用してデータをキャッシュすることもできます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="af1b5-163">各 ASP.NET アプリケーションは、アプリケーションのすべてのユーザーとページで共有される名前と値のコレクションを保持します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-163">Each ASP.NET application maintains a name/value collection that's shared across all users and pages of the application.</span></span> <span data-ttu-id="af1b5-164">このコレクションには、 [`HttpContext` クラス](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)の[`Application` プロパティ](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)を使用してアクセスし、次のように ASP.NET ページの分離コードクラスから使用できます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)'s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page's code-behind class like so:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="af1b5-165">データキャッシュには、データをキャッシュするための豊富な API が用意されています。これにより、時間と依存関係ベースの expiries、キャッシュ項目の優先度などのメカニズムが提供されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="af1b5-166">静的メンバーとアプリケーションの状態を使用する場合、このような機能は、ページの開発者が手動で追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="af1b5-167">ただし、アプリケーションの有効期間中、アプリケーションの起動時にデータをキャッシュする場合、データキャッシュの利点は議論です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-167">When caching data at application startup for the lifetime of the application, however, the data cache's advantages are moot.</span></span> <span data-ttu-id="af1b5-168">このチュートリアルでは、静的なデータをキャッシュする3つの手法をすべて使用するコードを見ていきます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="af1b5-169">手順 3:`Suppliers`テーブルデータをキャッシュする</span><span class="sxs-lookup"><span data-stu-id="af1b5-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="af1b5-170">日付に実装した Northwind データベーステーブルには、従来のルックアップテーブルは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="af1b5-171">この4つの Datatable は、値が非静的であるすべてのモデルテーブルに対して実装されています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="af1b5-172">このチュートリアルでは、新しい DataTable を DAL に追加してから、新しいクラスとメソッドを BLL に追加するのに時間を費やすのではなく、`Suppliers` テーブルのデータが静的であると考えてみましょう。</span><span class="sxs-lookup"><span data-stu-id="af1b5-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let's just pretend that the `Suppliers` table's data is static.</span></span> <span data-ttu-id="af1b5-173">このため、アプリケーションの起動時にこのデータをキャッシュすることができます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="af1b5-174">開始するには、`CL` フォルダーに `StaticCache.cs` という名前の新しいクラスを作成します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>

![CL フォルダーに StaticCache.cs クラスを作成する](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="af1b5-176">**図 2**: `CL` フォルダーに `StaticCache.cs` クラスを作成する</span><span class="sxs-lookup"><span data-stu-id="af1b5-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>

<span data-ttu-id="af1b5-177">このキャッシュからデータを返すメソッドだけでなく、スタートアップ時にデータを読み込むメソッドを追加する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="af1b5-178">上記のコードでは、静的メンバー変数 `suppliers`を使用して、`SuppliersBLL` クラスの `GetSuppliers()` メソッドの結果を保持します。これは、`LoadStaticCache()` メソッドから呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class's `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="af1b5-179">`LoadStaticCache()` メソッドは、アプリケーションの開始時に呼び出されることを意図しています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-179">The `LoadStaticCache()` method is meant to be called during the application's start.</span></span> <span data-ttu-id="af1b5-180">このデータがアプリケーションの起動時に読み込まれると、supplier データを操作する必要があるすべてのページで、`StaticCache` クラスの `GetSuppliers()` メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class's `GetSuppliers()` method.</span></span> <span data-ttu-id="af1b5-181">そのため、サプライヤーを取得するためのデータベースへの呼び出しは、アプリケーションの起動時に1回だけ行われます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="af1b5-182">静的メンバー変数をキャッシュストアとして使用するのではなく、アプリケーションの状態またはデータキャッシュを使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="af1b5-183">次のコードは、アプリケーションの状態を使用するクラスを示しています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-183">The following code shows the class retooled to use application state:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="af1b5-184">`LoadStaticCache()`では、supplier 情報はアプリケーション変数*キー*に格納されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="af1b5-185">これは、`GetSuppliers()`から適切な型 (`Northwind.SuppliersDataTable`) として返されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-185">It's returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="af1b5-186">`Application["key"]`を使用して ASP.NET pages の分離コードクラスでアプリケーションの状態にアクセスできますが、アーキテクチャでは、現在の `HttpContext`を取得するために `HttpContext.Current.Application["key"]` を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="af1b5-187">同様に、次のコードに示すように、データキャッシュをキャッシュストアとして使用することもできます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="af1b5-188">時間ベースの有効期限なしでデータキャッシュに項目を追加するには、`System.Web.Caching.Cache.NoAbsoluteExpiration` と `System.Web.Caching.Cache.NoSlidingExpiration` の値を入力パラメーターとして使用します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="af1b5-189">データキャッシュの `Insert` メソッドのこの特定のオーバーロードが選択され、キャッシュ項目の*優先順位*を指定できるようになりました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-189">This particular overload of the data cache's `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="af1b5-190">優先順位は、使用可能なメモリが不足しているときにキャッシュからどの項目を清掃するかを決定するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="af1b5-191">ここでは、優先順位 `NotRemovable`を使用します。これにより、このキャッシュ項目は清掃されません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-191">Here we use the priority `NotRemovable`, which ensures that this cache item won't be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="af1b5-192">このチュートリアルのダウンロードでは、静的メンバー変数の方法を使用して `StaticCache` クラスを実装します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-192">This tutorial's download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="af1b5-193">アプリケーションの状態とデータキャッシュの手法のコードについては、クラスファイルのコメントを参照してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>

## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="af1b5-194">手順 4: アプリケーションの起動時にコードを実行する</span><span class="sxs-lookup"><span data-stu-id="af1b5-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="af1b5-195">Web アプリケーションが初めて起動したときにコードを実行するには、`Global.asax`という名前の特別なファイルを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="af1b5-196">このファイルには、アプリケーション、セッション、および要求レベルのイベントのイベントハンドラーを含めることができます。ここでは、アプリケーションが起動するたびに実行されるコードを追加できます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="af1b5-197">Web アプリケーションのルートディレクトリに `Global.asax` ファイルを追加します。そのためには、Visual Studio のソリューションエクスプローラーで web サイトプロジェクト名を右クリックし、[新しい項目の追加] を選択します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-197">Add the `Global.asax` file to your web application's root directory by right-clicking on the website project name in Visual Studio's Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="af1b5-198">[新しい項目の追加] ダイアログボックスで、グローバルアプリケーションクラスの項目の種類を選択し、[追加] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="af1b5-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="af1b5-199">プロジェクトに既に `Global.asax` ファイルがある場合、[新しい項目の追加] ダイアログボックスにはグローバルアプリケーションクラスの項目の種類は表示されません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>

<span data-ttu-id="af1b5-200">[Web アプリケーションのルートディレクトリに global.asax ファイルを追加 ![には](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="af1b5-200">[![Add the Global.asax File to Your Web Application's Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="af1b5-201">**図 3**: Web アプリケーションのルートディレクトリに `Global.asax` ファイルを追加する ([クリックすると、フルサイズの画像が表示](caching-data-at-application-startup-cs/_static/image5.png)されます)</span><span class="sxs-lookup"><span data-stu-id="af1b5-201">**Figure 3**: Add the `Global.asax` File to Your Web Application's Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>

<span data-ttu-id="af1b5-202">既定の `Global.asax` ファイルテンプレートには、サーバー側の `<script>` タグ内の5つのメソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="af1b5-203">**`Application_Start`** は、web アプリケーションが最初に起動したときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="af1b5-204">アプリケーションのシャットダウン時に **`Application_End`** が実行される</span><span class="sxs-lookup"><span data-stu-id="af1b5-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="af1b5-205">未処理の例外がアプリケーションに到達するたびに、 **`Application_Error`** が実行されます</span><span class="sxs-lookup"><span data-stu-id="af1b5-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="af1b5-206">**`Session_Start`** は、新しいセッションが作成されたときに実行されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="af1b5-207">セッションの有効期限が切れたとき、または破棄されたときに **`Session_End`** 実行する</span><span class="sxs-lookup"><span data-stu-id="af1b5-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="af1b5-208">`Application_Start` イベントハンドラーは、アプリケーションのライフサイクル中に1回だけ呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-208">The `Application_Start` event handler is called only once during an application's life cycle.</span></span> <span data-ttu-id="af1b5-209">アプリケーションから ASP.NET リソースが最初に要求されたときにアプリケーションが起動し、アプリケーションが再起動されるまで実行が継続されます。そのためには、`/Bin` フォルダーの内容の変更、`Global.asax`の変更、`App_Code` フォルダー内の内容の変更、または `Web.config` ファイルの変更などが考えられます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="af1b5-210">アプリケーションのライフサイクルの詳細については、 [「ASP.NET アプリケーションのライフサイクルの概要」](https://msdn.microsoft.com/library/ms178473.aspx)を参照してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="af1b5-211">これらのチュートリアルでは、`Application_Start` メソッドにコードを追加するだけで済むため、他のユーザーを自由に削除できます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="af1b5-212">`Application_Start`では、`StaticCache` クラスの `LoadStaticCache()` メソッドを呼び出します。これにより、仕入先の情報が読み込まれ、キャッシュされます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-212">In `Application_Start`, simply call the `StaticCache` class's `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="af1b5-213">必要な作業は以上です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-213">That's all there is to it!</span></span> <span data-ttu-id="af1b5-214">アプリケーションの起動時には、`LoadStaticCache()` メソッドによって、BLL から供給業者の情報が取得され、静的メンバー変数 (または、`StaticCache` クラスのを使用して終了した任意のキャッシュストア) に格納されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="af1b5-215">この動作を確認するには、`Application_Start` メソッドにブレークポイントを設定し、アプリケーションを実行します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="af1b5-216">アプリケーションの開始時にブレークポイントがヒットすることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="af1b5-217">ただし、後続の要求では、`Application_Start` メソッドは実行されません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>

<span data-ttu-id="af1b5-218">[ブレークポイントを使用して Application_Start イベントハンドラーが実行されていることを確認 ![](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="af1b5-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="af1b5-219">**図 4**: ブレークポイントを使用して `Application_Start` イベントハンドラーが実行されていることを確認する ([クリックすると、フルサイズの画像が表示](caching-data-at-application-startup-cs/_static/image8.png)されます)</span><span class="sxs-lookup"><span data-stu-id="af1b5-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>

> [!NOTE]
> <span data-ttu-id="af1b5-220">最初にデバッグを開始したときに `Application_Start` ブレークポイントにヒットしない場合は、アプリケーションが既に起動していることが原因です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="af1b5-221">`Global.asax` または `Web.config` ファイルを変更してアプリケーションを強制的に再起動してから、操作をやり直してください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="af1b5-222">これらのファイルのいずれかの末尾に空白行を追加 (または削除) するだけで、アプリケーションをすばやく再起動できます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>

## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="af1b5-223">手順 5: キャッシュされたデータを表示する</span><span class="sxs-lookup"><span data-stu-id="af1b5-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="af1b5-224">この時点で、`StaticCache` クラスには、アプリケーションの起動時にキャッシュされ、`GetSuppliers()` メソッドを使用してアクセスできる supplier データのバージョンが含まれています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="af1b5-225">プレゼンテーション層からこのデータを操作するには、ObjectDataSource を使用するか、ASP.NET ページの分離コードクラスから `StaticCache` クラスの `GetSuppliers()` メソッドをプログラムによって呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class's `GetSuppliers()` method from an ASP.NET page's code-behind class.</span></span> <span data-ttu-id="af1b5-226">ObjectDataSource コントロールと GridView コントロールを使用して、キャッシュされた業者情報を表示する方法を見てみましょう。</span><span class="sxs-lookup"><span data-stu-id="af1b5-226">Let's look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="af1b5-227">まず、`Caching` フォルダーの [`AtApplicationStartup.aspx`] ページを開きます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="af1b5-228">GridView をツールボックスからデザイナーにドラッグし、その `ID` プロパティを `Suppliers`に設定します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="af1b5-229">次に、GridView のスマートタグから、`SuppliersCachedDataSource`という名前の新しい ObjectDataSource を作成します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-229">Next, from the GridView's smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="af1b5-230">`StaticCache` クラスの `GetSuppliers()` メソッドを使用するように ObjectDataSource を構成します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-230">Configure the ObjectDataSource to use the `StaticCache` class's `GetSuppliers()` method.</span></span>

<span data-ttu-id="af1b5-231">[StaticCache クラスを使用するように ObjectDataSource を構成 ![には](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="af1b5-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="af1b5-232">**図 5**: `StaticCache` クラスを使用するように ObjectDataSource を構成する ([クリックしてフルサイズのイメージを表示する](caching-data-at-application-startup-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="af1b5-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>

<span data-ttu-id="af1b5-233">[GetSuppliers () メソッドを使用して、キャッシュされた仕入先データを取得 ![](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="af1b5-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="af1b5-234">**図 6**: `GetSuppliers()` メソッドを使用してキャッシュされた Supplier データを取得する ([クリックしてフルサイズの画像を表示する](caching-data-at-application-startup-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="af1b5-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>

<span data-ttu-id="af1b5-235">ウィザードを完了すると、Visual Studio によって `SuppliersDataTable`の各データフィールドに対して BoundFields が自動的に追加されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="af1b5-236">GridView および ObjectDataSource の宣言型マークアップは、次のようになります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-236">Your GridView and ObjectDataSource's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="af1b5-237">図7は、ブラウザーを使用して表示するときのページを示しています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="af1b5-238">出力は、BLL の `SuppliersBLL` クラスからデータを取得したのと同じですが、`StaticCache` クラスを使用すると、アプリケーションの起動時にキャッシュされた仕入先データが返されます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-238">The output is the same had we pulled the data from the BLL's `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="af1b5-239">`StaticCache` クラスの `GetSuppliers()` メソッドにブレークポイントを設定して、この動作を確認できます。</span><span class="sxs-lookup"><span data-stu-id="af1b5-239">You can set breakpoints in the `StaticCache` class's `GetSuppliers()` method to verify this behavior.</span></span>

<span data-ttu-id="af1b5-240">[キャッシュされた仕入先データが GridView に表示される ![](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="af1b5-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="af1b5-241">**図 7**: キャッシュされた仕入先データが GridView に表示される ([クリックしてフルサイズのイメージを表示する](caching-data-at-application-startup-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="af1b5-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>

## <a name="summary"></a><span data-ttu-id="af1b5-242">要約</span><span class="sxs-lookup"><span data-stu-id="af1b5-242">Summary</span></span>

<span data-ttu-id="af1b5-243">ほとんどのデータモデルには、通常、参照テーブルの形式で実装される、静的なデータが大量に含まれています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="af1b5-244">この情報は静的であるため、この情報を表示する必要があるたびにデータベースに継続的にアクセスする理由はありません。</span><span class="sxs-lookup"><span data-stu-id="af1b5-244">Since this information is static, there's no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="af1b5-245">さらに、静的な性質上、データをキャッシュする場合、有効期限は不要です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-245">Furthermore, due to its static nature, when caching the data there's no need for an expiry.</span></span> <span data-ttu-id="af1b5-246">このチュートリアルでは、このようなデータを取得し、データキャッシュ、アプリケーションの状態、および静的メンバー変数にキャッシュする方法を説明しました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="af1b5-247">この情報はアプリケーションの起動時にキャッシュされ、アプリケーションの有効期間中はキャッシュに残ります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-247">This information is cached at application startup and remains in the cache throughout the application's lifetime.</span></span>

<span data-ttu-id="af1b5-248">このチュートリアルと過去2つでは、時間ベースの expiries を使用するだけでなく、アプリケーションの有効期間中のデータのキャッシュについても説明しました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application's lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="af1b5-249">ただし、データベースデータをキャッシュする場合は、時間ベースの有効期限が理想的な値よりも小さくなることがあります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="af1b5-250">キャッシュを定期的にフラッシュするのではなく、基になるデータベースデータが変更された場合にのみ、キャッシュされた項目を削除することをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="af1b5-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="af1b5-251">これは、次のチュートリアルで説明する SQL キャッシュ依存関係を使用することによって可能です。</span><span class="sxs-lookup"><span data-stu-id="af1b5-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="af1b5-252">プログラミングを楽しんでください。</span><span class="sxs-lookup"><span data-stu-id="af1b5-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="af1b5-253">作成者について</span><span class="sxs-lookup"><span data-stu-id="af1b5-253">About the Author</span></span>

<span data-ttu-id="af1b5-254">1998以来、 [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)は 7 asp/創設者 of [4GuysFromRolla.com](http://www.4guysfromrolla.com)の執筆者であり、Microsoft Web テクノロジを使用しています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="af1b5-255">Scott は、独立したコンサルタント、トレーナー、およびライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="af1b5-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="af1b5-256">彼の最新の書籍は[ *、ASP.NET 2.0 を24時間以内に教え*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ています。</span><span class="sxs-lookup"><span data-stu-id="af1b5-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="af1b5-257">mitchell@4GuysFromRolla.comでアクセスでき[ます。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="af1b5-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="af1b5-258">または彼のブログを参照してください。これは[http://ScottOnWriting.NET](http://ScottOnWriting.NET)にあります。</span><span class="sxs-lookup"><span data-stu-id="af1b5-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="af1b5-259">ありがとうございました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-259">Special Thanks To</span></span>

<span data-ttu-id="af1b5-260">このチュートリアルシリーズは、役に立つ多くのレビュー担当者によってレビューされました。</span><span class="sxs-lookup"><span data-stu-id="af1b5-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="af1b5-261">このチュートリアルのリードレビュー担当者は、Teresa Murphy と Zack Jones でした。</span><span class="sxs-lookup"><span data-stu-id="af1b5-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="af1b5-262">今後の MSDN 記事を確認することに興味がありますか?</span><span class="sxs-lookup"><span data-stu-id="af1b5-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="af1b5-263">その場合は、mitchell@4GuysFromRolla.comの行を削除[します。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="af1b5-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="af1b5-264">[前へ](caching-data-in-the-architecture-cs.md)
> [次へ](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="af1b5-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>
