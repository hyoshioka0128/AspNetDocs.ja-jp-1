---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
title: コンテンツページのコントロール ID の名前C#付け () |Microsoft Docs
author: rick-anderson
description: ContentPlaceHolder コントロールが名前付けコンテナーとして機能するしくみを示します。したがって、プログラムでコントロールを操作する際には、(FindControl を使用した) 作業が困難になります。
ms.author: riande
ms.date: 06/10/2008
ms.assetid: 1c7d0916-0988-4b4f-9a03-935e4b5af6af
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
msc.type: authoredcontent
ms.openlocfilehash: e849e5860dc988e112cc3a65d976c16ecdf77416
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78520186"
---
# <a name="control-id-naming-in-content-pages-c"></a><span data-ttu-id="deeae-103">コンテンツ ページのコントロール ID の名前付け (C#)</span><span class="sxs-lookup"><span data-stu-id="deeae-103">Control ID Naming in Content Pages (C#)</span></span>

<span data-ttu-id="deeae-104">[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="deeae-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="deeae-105">[コードのダウンロード](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip)または[PDF のダウンロード](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="deeae-105">[Download Code](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip) or [Download PDF](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span></span>

> <span data-ttu-id="deeae-106">ContentPlaceHolder コントロールが名前付けコンテナーとして機能するしくみを説明します。そのため、コントロールをプログラムで操作することが困難になります (FindControl を介して)。</span><span class="sxs-lookup"><span data-stu-id="deeae-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindControl).</span></span> <span data-ttu-id="deeae-107">この問題と回避策について見ていきます。</span><span class="sxs-lookup"><span data-stu-id="deeae-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="deeae-108">また、結果として得られる ClientID 値にプログラムでアクセスする方法についても説明します。</span><span class="sxs-lookup"><span data-stu-id="deeae-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>

## <a name="introduction"></a><span data-ttu-id="deeae-109">はじめに</span><span class="sxs-lookup"><span data-stu-id="deeae-109">Introduction</span></span>

<span data-ttu-id="deeae-110">すべての ASP.NET サーバーコントロールには、コントロールを一意に識別する `ID` のプロパティが含まれています。このプロパティは、コントロールが分離コードクラスでプログラムによってアクセスされる手段です。</span><span class="sxs-lookup"><span data-stu-id="deeae-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="deeae-111">同様に、HTML ドキュメント内の要素には、要素を一意に識別する `id` 属性を含めることができます。これらの `id` 値は、クライアント側スクリプトで、プログラムによって特定の HTML 要素を参照するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="deeae-112">これにより、ASP.NET サーバーコントロールが HTML にレンダリングされるときに、その `ID` 値が、レンダリングされた HTML 要素の `id` 値として使用されると想定できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="deeae-113">特定の状況では、1つの `ID` 値を持つ1つのコントロールが、レンダリングされたマークアップで複数回出現する可能性があるため、必ずしもそうであるとは限りません。</span><span class="sxs-lookup"><span data-stu-id="deeae-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="deeae-114">`ID` 値が ProductName の Label Web コントロールを含む GridView コントロールについて考えてみます。</span><span class="sxs-lookup"><span data-stu-id="deeae-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of ProductName.</span></span> <span data-ttu-id="deeae-115">実行時に GridView がそのデータソースにバインドされている場合、このラベルは GridView 行ごとに1回繰り返されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="deeae-116">表示される各ラベルには、一意の `id` 値が必要です。</span><span class="sxs-lookup"><span data-stu-id="deeae-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="deeae-117">このようなシナリオを処理するために、ASP.NET では、特定のコントロールを名前付けコンテナーとして示すことができます。</span><span class="sxs-lookup"><span data-stu-id="deeae-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="deeae-118">名前付けコンテナーは、新しい `ID` 名前空間として機能します。</span><span class="sxs-lookup"><span data-stu-id="deeae-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="deeae-119">名前付けコンテナー内に表示されるすべてのサーバーコントロールには、名前付けコンテナーコントロールの `ID` の先頭に `id` 値が付加されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="deeae-120">たとえば、`GridView` クラスと `GridViewRow` クラスは両方ともコンテナーに名前を付けます。</span><span class="sxs-lookup"><span data-stu-id="deeae-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="deeae-121">その結果、GridView の TemplateField で定義され `ID` ProductName に定義されている Label コントロールには、`GridViewID_GridViewRowID_ProductName`の `id` 値が表示されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-121">Consequently, a Label control defined in a GridView TemplateField with `ID` ProductName is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="deeae-122">*GridViewRowID*は各 GridView 行に対して一意であるため、結果として得られる `id` 値は一意になります。</span><span class="sxs-lookup"><span data-stu-id="deeae-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="deeae-123">[`INamingContainer` インターフェイス](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx)は、特定の ASP.NET サーバーコントロールが名前付けコンテナーとして機能する必要があることを示すために使用されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="deeae-124">`INamingContainer` インターフェイスは、サーバーコントロールが実装する必要のあるメソッドをスペルチェックしません。代わりに、マーカーとして使用されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="deeae-125">レンダリングされたマークアップを生成するときに、コントロールがこのインターフェイスを実装する場合、ASP.NET エンジンは、その `ID` 値の前に、その子孫の `id` 属性値を自動的にプレフィックスします。</span><span class="sxs-lookup"><span data-stu-id="deeae-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="deeae-126">このプロセスの詳細については、手順 2. で説明します。</span><span class="sxs-lookup"><span data-stu-id="deeae-126">This process is discussed in more detail in Step 2.</span></span>

<span data-ttu-id="deeae-127">コンテナーに名前を付けると、レンダリングされた `id` 属性値が変更されるだけでなく、ASP.NET ページの分離コードクラスからコントロールをプログラムで参照する方法にも影響します。</span><span class="sxs-lookup"><span data-stu-id="deeae-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="deeae-128">`FindControl("controlID")` メソッドは、通常、プログラムによって Web コントロールを参照するために使用されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="deeae-129">ただし、`FindControl` は、名前付けコンテナーには浸透しません。</span><span class="sxs-lookup"><span data-stu-id="deeae-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="deeae-130">その結果、GridView または他の名前付けコンテナー内のコントロールを参照するために、`Page.FindControl` メソッドを直接使用することはできません。</span><span class="sxs-lookup"><span data-stu-id="deeae-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="deeae-131">Surmised があるかもしれませんが、マスターページと ContentPlaceHolders はどちらも名前付けコンテナーとして実装されています。</span><span class="sxs-lookup"><span data-stu-id="deeae-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="deeae-132">このチュートリアルでは、マスターページが HTML 要素 `id` 値に与える影響と、`FindControl`を使用してコンテンツページ内の Web コントロールをプログラムで参照する方法について説明します。</span><span class="sxs-lookup"><span data-stu-id="deeae-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="deeae-133">手順 1: 新しい ASP.NET ページを追加する</span><span class="sxs-lookup"><span data-stu-id="deeae-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="deeae-134">このチュートリアルで説明されている概念を示すために、web サイトに新しい ASP.NET ページを追加してみましょう。</span><span class="sxs-lookup"><span data-stu-id="deeae-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="deeae-135">ルートフォルダーに `IDIssues.aspx` という名前の新しいコンテンツページを作成し、`Site.master` マスターページにバインドします。</span><span class="sxs-lookup"><span data-stu-id="deeae-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>

![コンテンツページ IDIssues をルートフォルダーに追加します。](control-id-naming-in-content-pages-cs/_static/image1.png)

<span data-ttu-id="deeae-137">**図 01**: ルートフォルダーに `IDIssues.aspx` コンテンツページを追加する</span><span class="sxs-lookup"><span data-stu-id="deeae-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>

<span data-ttu-id="deeae-138">Visual Studio では、マスターページの4つの ContentPlaceHolders のそれぞれに対して、コンテンツコントロールが自動的に作成されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="deeae-139">[*複数の contentplaceholders と既定のコンテンツ*](multiple-contentplaceholders-and-default-content-cs.md)のチュートリアルで説明したように、コンテンツコントロールが存在しない場合は、代わりにマスターページの既定の ContentPlaceHolder コンテンツが生成されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-cs.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="deeae-140">`QuickLoginUI` および `LeftColumnContent` ContentPlaceHolders には、このページに適切な既定のマークアップが含まれているため、`IDIssues.aspx`から対応するコンテンツコントロールを削除します。</span><span class="sxs-lookup"><span data-stu-id="deeae-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="deeae-141">この時点では、コンテンツページの宣言型マークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-141">At this point, the content page's declarative markup should look like the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample1.aspx)]

<span data-ttu-id="deeae-142">[ *「マスターページでタイトル、メタタグ、およびその他の HTML ヘッダーを指定*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md)する」チュートリアルでは、明示的に設定されていない場合にページのタイトルを自動的に構成するカスタム基本ページクラス (`BasePage`) を作成しました。</span><span class="sxs-lookup"><span data-stu-id="deeae-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="deeae-143">`IDIssues.aspx` ページでこの機能を使用するには、ページの分離コードクラスが `BasePage` クラス (`System.Web.UI.Page`ではなく) から派生している必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="deeae-144">次のように、分離コードクラスの定義を変更します。</span><span class="sxs-lookup"><span data-stu-id="deeae-144">Modify the code-behind class's definition so that it looks like the following:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample2.cs)]

<span data-ttu-id="deeae-145">最後に、この新しいレッスンのエントリを含めるように `Web.sitemap` ファイルを更新します。</span><span class="sxs-lookup"><span data-stu-id="deeae-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="deeae-146">`<siteMapNode>` 要素を追加し、その `title` と `url` 属性をそれぞれ "Control ID 名前付け問題" と `~/IDIssues.aspx`に設定します。</span><span class="sxs-lookup"><span data-stu-id="deeae-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="deeae-147">この追加を行った後、`Web.sitemap` ファイルのマークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>

[!code-xml[Main](control-id-naming-in-content-pages-cs/samples/sample3.xml)]

<span data-ttu-id="deeae-148">図2に示すように、`Web.sitemap` の新しいサイトマップエントリは、左側の列のレッスンセクションにすぐに反映されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>

![レッスンのセクションには、&quot;コントロール ID の名前付けの問題へのリンクが含まれるようになりました&quot;](control-id-naming-in-content-pages-cs/_static/image2.png)

<span data-ttu-id="deeae-150">**図 02**: レッスンのセクションに、"コントロール ID の名前付けに関する問題" へのリンクが含まれるようになりました。</span><span class="sxs-lookup"><span data-stu-id="deeae-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>

## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="deeae-151">手順 2: レンダリングされた`ID`の変更を調べる</span><span class="sxs-lookup"><span data-stu-id="deeae-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="deeae-152">ASP.NET エンジンによってサーバーコントロールの表示 `id` 値に対して行われる変更について理解を深めるために、`IDIssues.aspx` ページにいくつかの Web コントロールを追加し、ブラウザーに送信される表示マークアップを表示してみましょう。</span><span class="sxs-lookup"><span data-stu-id="deeae-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="deeae-153">具体的には、"age:" というテキストを入力し、その後にテキストボックス Web コントロールを入力します。</span><span class="sxs-lookup"><span data-stu-id="deeae-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="deeae-154">ページの下に、ボタン Web コントロールとラベル Web コントロールが追加されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="deeae-155">TextBox の `ID` と `Columns` プロパティをそれぞれ `Age` と3に設定します。</span><span class="sxs-lookup"><span data-stu-id="deeae-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="deeae-156">ボタンの `Text` と `ID` プロパティを "Submit" に設定し、`SubmitButton`します。</span><span class="sxs-lookup"><span data-stu-id="deeae-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="deeae-157">ラベルの `Text` プロパティをクリアし、その `ID` を `Results`に設定します。</span><span class="sxs-lookup"><span data-stu-id="deeae-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="deeae-158">この時点で、コンテンツコントロールの宣言型マークアップは次のようになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-158">At this point your Content control's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample4.aspx)]

<span data-ttu-id="deeae-159">図3は、Visual Studio のデザイナーを使用して表示するときのページを示しています。</span><span class="sxs-lookup"><span data-stu-id="deeae-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>

<span data-ttu-id="deeae-160">[ページには、テキストボックス、ボタン、およびラベルという3つの Web コントロールが含まれて ![ます。](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="deeae-160">[![The Page Includes Three Web Controls: a TextBox, Button, and Label](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span></span>

<span data-ttu-id="deeae-161">**図 03**: ページには、テキストボックス、ボタン、およびラベルという3つの Web コントロールが含まれています ([クリックすると、フルサイズの画像が表示](control-id-naming-in-content-pages-cs/_static/image5.png)されます)</span><span class="sxs-lookup"><span data-stu-id="deeae-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image5.png))</span></span>

<span data-ttu-id="deeae-162">ブラウザーを使用してページにアクセスし、HTML ソースを表示します。</span><span class="sxs-lookup"><span data-stu-id="deeae-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="deeae-163">次のマークアップに示されているように、テキストボックス、ボタン、およびラベル Web コントロールの HTML 要素の `id` 値は、Web コントロールの `ID` 値と、ページ内の名前付けコンテナーの `ID` 値の組み合わせです。</span><span class="sxs-lookup"><span data-stu-id="deeae-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample5.html)]

<span data-ttu-id="deeae-164">このチュートリアルで既に説明したように、マスターページとその ContentPlaceHolders は両方とも名前付けコンテナーとして機能します。</span><span class="sxs-lookup"><span data-stu-id="deeae-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="deeae-165">そのため、どちらも、入れ子になったコントロールの表示された `ID` 値に寄与します。</span><span class="sxs-lookup"><span data-stu-id="deeae-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="deeae-166">TextBox の `id` 属性を取得します。例: `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="deeae-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="deeae-167">TextBox コントロールの `ID` 値が `Age`たことを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="deeae-168">これには、ContentPlaceHolder コントロールの `ID` 値 `MainContent`がプレフィックスとして付けられます。</span><span class="sxs-lookup"><span data-stu-id="deeae-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="deeae-169">さらに、この値には、マスターページの `ID` 値 `ctl00`がプレフィックスとして付けられます。</span><span class="sxs-lookup"><span data-stu-id="deeae-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="deeae-170">純効果は、マスターページ、ContentPlaceHolder コントロール、およびテキストボックス自体の `ID` 値で構成される `id` 属性値です。</span><span class="sxs-lookup"><span data-stu-id="deeae-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="deeae-171">図4に、この動作を示します。</span><span class="sxs-lookup"><span data-stu-id="deeae-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="deeae-172">`Age` テキストボックスの表示されている `id` を確認するには、テキストボックスコントロールの `ID` の値を使用して `Age`を開始します。</span><span class="sxs-lookup"><span data-stu-id="deeae-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="deeae-173">次に、制御階層を操作します。</span><span class="sxs-lookup"><span data-stu-id="deeae-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="deeae-174">各名前付けコンテナー (ピーチ色のノード) で、現在表示されている `id` に名前付けコンテナーの `id`というプレフィックスを付けます。</span><span class="sxs-lookup"><span data-stu-id="deeae-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>

![レンダリングされた id 属性は、名前付けコンテナーの ID 値に基づいています。](control-id-naming-in-content-pages-cs/_static/image6.png)

<span data-ttu-id="deeae-176">**図 04**: 表示される `id` 属性は、名前付けコンテナーの `ID` 値に基づいています。</span><span class="sxs-lookup"><span data-stu-id="deeae-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>

> [!NOTE]
> <span data-ttu-id="deeae-177">既に説明したように、表示される `id` 属性の `ctl00` 部分はマスターページの `ID` 値を構成しますが、この `ID` の値について疑問に思うかもしれません。</span><span class="sxs-lookup"><span data-stu-id="deeae-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="deeae-178">ここでは、マスターページまたはコンテンツページのどこにも指定しませんでした。</span><span class="sxs-lookup"><span data-stu-id="deeae-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="deeae-179">ASP.NET ページのほとんどのサーバーコントロールは、ページの宣言型マークアップによって明示的に追加されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="deeae-180">`MainContent` ContentPlaceHolder コントロールが `Site.master`のマークアップで明示的に指定されました。`Age` TextBox は `IDIssues.aspx`のマークアップで定義されています。</span><span class="sxs-lookup"><span data-stu-id="deeae-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="deeae-181">これらのコントロールの `ID` 値は、プロパティウィンドウまたは宣言型の構文から指定できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="deeae-182">マスターページ自体のような他のコントロールは、宣言型マークアップで定義されていません。</span><span class="sxs-lookup"><span data-stu-id="deeae-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="deeae-183">そのため、`ID` 値は自動的に生成される必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="deeae-184">ASP.NET エンジンは、Id が明示的に設定されていないコントロールに対して、実行時に `ID` 値を設定します。</span><span class="sxs-lookup"><span data-stu-id="deeae-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="deeae-185">この例では、`ctlXX`という名前付けパターンを使用します。ここで、 *XX*は整数値を順番に増加させます。</span><span class="sxs-lookup"><span data-stu-id="deeae-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>

<span data-ttu-id="deeae-186">マスターページ自体は名前付けコンテナーとして機能するため、マスターページで定義されている Web コントロールにも、表示される `id` 属性値が変更されています。</span><span class="sxs-lookup"><span data-stu-id="deeae-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="deeae-187">たとえば、「[*マスターページを使用したサイト全体のレイアウトの作成*](creating-a-site-wide-layout-using-master-pages-cs.md)」チュートリアルのマスターページに追加した `DisplayDate` ラベルには、次のように表示されるマークアップがあります。</span><span class="sxs-lookup"><span data-stu-id="deeae-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md) tutorial has the following rendered markup:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample6.html)]

<span data-ttu-id="deeae-188">`id` 属性には、マスターページの `ID` 値 (`ctl00`) と、ラベル Web コントロール (`DateDisplay`) の `ID` 値の両方が含まれていることに注意してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="deeae-189">手順 3: プログラムを使用して`FindControl` によって Web コントロールを参照する</span><span class="sxs-lookup"><span data-stu-id="deeae-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="deeae-190">すべての ASP.NET サーバーコントロールには、コントロールの子孫が*controlID*という名前のコントロールを検索する `FindControl("controlID")` メソッドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="deeae-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="deeae-191">このようなコントロールが見つかった場合は、が返されます。一致するコントロールが見つからない場合、`FindControl` は `null`を返します。</span><span class="sxs-lookup"><span data-stu-id="deeae-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `null`.</span></span>

<span data-ttu-id="deeae-192">`FindControl` は、コントロールにアクセスする必要があるが、直接参照がない場合に便利です。</span><span class="sxs-lookup"><span data-stu-id="deeae-192">`FindControl` is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="deeae-193">たとえば、gridview のようなデータ Web コントロールを使用する場合、GridView のフィールド内のコントロールは宣言構文で1回定義されますが、実行時には、各 GridView 行に対してコントロールのインスタンスが作成されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="deeae-194">その結果、実行時に生成されるコントロールは存在しますが、分離コードクラスから直接参照することはできません。</span><span class="sxs-lookup"><span data-stu-id="deeae-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="deeae-195">そのため、GridView のフィールド内の特定のコントロールをプログラムで操作するには、`FindControl` を使用する必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="deeae-196">(`FindControl` を使用してデータ Web コントロールのテンプレート内のコントロールにアクセスする方法の詳細については、「[データに基づくカスタム書式](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md)設定」を参照してください)。この同じシナリオは、web コントロールを Web フォームに動的に追加する場合にも発生します。これは、「[動的データエントリのユーザーインターフェイスの作成](https://msdn.microsoft.com/library/aa479330.aspx)」で説明されているトピックです。</span><span class="sxs-lookup"><span data-stu-id="deeae-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="deeae-197">`FindControl` メソッドを使用してコンテンツページ内のコントロールを検索する方法を示すために、`SubmitButton`の `Click` イベントのイベントハンドラーを作成します。</span><span class="sxs-lookup"><span data-stu-id="deeae-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="deeae-198">イベントハンドラーに次のコードを追加します。このコードは、`FindControl` メソッドを使用して `Age` TextBox と `Results` ラベルをプログラムによって参照し、ユーザーの入力に基づいて `Results` にメッセージを表示します。</span><span class="sxs-lookup"><span data-stu-id="deeae-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="deeae-199">もちろん、この例のラベルコントロールとテキストボックスコントロールを参照するために `FindControl` を使用する必要はありません。</span><span class="sxs-lookup"><span data-stu-id="deeae-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="deeae-200">`ID` のプロパティ値を使用して直接参照できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="deeae-201">ここでは `FindControl` を使用して、コンテンツページから `FindControl` を使用した場合の動作を説明します。</span><span class="sxs-lookup"><span data-stu-id="deeae-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample7.cs)]

<span data-ttu-id="deeae-202">`FindControl` メソッドの呼び出しに使用される構文は、`SubmitButton_Click`の最初の2行で若干異なりますが、意味は同じです。</span><span class="sxs-lookup"><span data-stu-id="deeae-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="deeae-203">ASP.NET のすべてのサーバーコントロールに `FindControl` メソッドが含まれていることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="deeae-204">これには `Page` クラスが含まれます。このクラスから、すべての ASP.NET 分離コードクラスを派生させる必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="deeae-205">したがって、`FindControl("controlID")` を呼び出すことは、分離コードクラスまたはカスタム基本クラスで `FindControl` メソッドをオーバーライドしていないという前提で `Page.FindControl("controlID")`を呼び出すことと同じです。</span><span class="sxs-lookup"><span data-stu-id="deeae-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="deeae-206">このコードを入力したら、ブラウザーを使用して `IDIssues.aspx` のページにアクセスし、年齢を入力して、[送信] ボタンをクリックします。</span><span class="sxs-lookup"><span data-stu-id="deeae-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="deeae-207">[送信] ボタンをクリックすると `NullReferenceException` が発生します (図5を参照)。</span><span class="sxs-lookup"><span data-stu-id="deeae-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>

<span data-ttu-id="deeae-208">[NullReferenceException が発生した ![](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="deeae-208">[![A NullReferenceException is Raised](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span></span>

<span data-ttu-id="deeae-209">**図 05**: `NullReferenceException` が発生します ([クリックすると、フルサイズの画像が表示](control-id-naming-in-content-pages-cs/_static/image9.png)されます)</span><span class="sxs-lookup"><span data-stu-id="deeae-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image9.png))</span></span>

<span data-ttu-id="deeae-210">`SubmitButton_Click` イベントハンドラーにブレークポイントを設定すると、`FindControl` への両方の呼び出しが `null` 値を返すことがわかります。</span><span class="sxs-lookup"><span data-stu-id="deeae-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return a `null` value.</span></span> <span data-ttu-id="deeae-211">`NullReferenceException` は、`Age` TextBox の `Text` プロパティにアクセスしようとしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="deeae-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="deeae-212">問題は、`Control.FindControl` は、*同じ名前付けコンテナー内に*ある*コントロール*の子孫のみを検索することです。</span><span class="sxs-lookup"><span data-stu-id="deeae-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are *in the same naming container*.</span></span> <span data-ttu-id="deeae-213">マスターページは新しい名前付けコンテナーを構成するので、`Page.FindControl("controlID")` を呼び出すと、マスターページオブジェクトの `ctl00`が permeates されることはありません。</span><span class="sxs-lookup"><span data-stu-id="deeae-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="deeae-214">(図4を参照してコントロール階層を表示します。これにより、`Page` オブジェクトがマスターページ `ctl00`オブジェクトの親として表示されます)。したがって、`Results` ラベルと `Age` テキストボックスは見つかりません。 `ResultsLabel` および `AgeTextBox` には `null`の値が割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="deeae-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `null`.</span></span>

<span data-ttu-id="deeae-215">この課題には2つの回避策があります。一度に1つの名前付けコンテナーを適切なコントロールにドリルダウンできます。または、コンテナーの名前を permeates する独自の `FindControl` メソッドを作成することもできます。</span><span class="sxs-lookup"><span data-stu-id="deeae-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="deeae-216">これらの各オプションについて説明します。</span><span class="sxs-lookup"><span data-stu-id="deeae-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="deeae-217">適切な名前付けコンテナーへのドリルダウン</span><span class="sxs-lookup"><span data-stu-id="deeae-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="deeae-218">`FindControl` を使用して `Results` ラベルまたは `Age` TextBox を参照するには、同じ名前付けコンテナー内の先祖コントロールから `FindControl` を呼び出す必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="deeae-219">図4に示すように、`MainContent` ContentPlaceHolder コントロールは、同じ名前付けコンテナー内にある `Results` または `Age` の唯一の先祖です。</span><span class="sxs-lookup"><span data-stu-id="deeae-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="deeae-220">言い換えると、次のコードスニペットに示すように、`MainContent` コントロールから `FindControl` メソッドを呼び出すと、`Results` または `Age` のコントロールへの参照が正しく返されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample8.cs)]

<span data-ttu-id="deeae-221">ただし、ContentPlaceHolder がマスターページで定義されているため、上記の構文を使用して、コンテンツページの分離コードクラスから `MainContent` ContentPlaceHolder を操作することはできません。</span><span class="sxs-lookup"><span data-stu-id="deeae-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="deeae-222">代わりに、`FindControl` を使用して `MainContent`への参照を取得する必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="deeae-223">`SubmitButton_Click` イベントハンドラーのコードを次のように変更します。</span><span class="sxs-lookup"><span data-stu-id="deeae-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample9.cs)]

<span data-ttu-id="deeae-224">ブラウザーでページにアクセスする場合は、年齢を入力し、[Submit] \ (送信 \) ボタンをクリックすると `NullReferenceException` が発生します。</span><span class="sxs-lookup"><span data-stu-id="deeae-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="deeae-225">`SubmitButton_Click` イベントハンドラーにブレークポイントを設定すると、`MainContent` オブジェクトの `FindControl` メソッドを呼び出そうとしたときに、この例外が発生することがわかります。</span><span class="sxs-lookup"><span data-stu-id="deeae-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="deeae-226">`FindControl` メソッドが "MainContent" という名前のオブジェクトを見つけることができないため、`MainContent` オブジェクトが `null`。</span><span class="sxs-lookup"><span data-stu-id="deeae-226">The `MainContent` object is `null` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="deeae-227">基になる理由は、`Results` Label および `Age` TextBox コントロールと同じです。 `FindControl` は、コントロール階層の最上位から検索を開始し、名前付けコンテナーには対応しませんが、`MainContent` ContentPlaceHolder は、名前付けコンテナーであるマスターページ内にあります。</span><span class="sxs-lookup"><span data-stu-id="deeae-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="deeae-228">`FindControl` を使用して `MainContent`への参照を取得できるようにするには、まずマスターページコントロールへの参照が必要です。</span><span class="sxs-lookup"><span data-stu-id="deeae-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="deeae-229">マスターページへの参照を取得したら、`FindControl` を介して `MainContent` ContentPlaceHolder への参照を取得し、そこから `Results` ラベルと `Age` TextBox への参照 (`FindControl`を使用して) を取得できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="deeae-230">では、マスターページへの参照を取得するにはどうすればよいでしょうか。</span><span class="sxs-lookup"><span data-stu-id="deeae-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="deeae-231">レンダリングされたマークアップ内の `id` 属性を調べることで、マスターページの `ID` 値が `ctl00`ことが明らかになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="deeae-232">したがって、`Page.FindControl("ctl00")` を使用してマスターページへの参照を取得し、そのオブジェクトを使用して `MainContent`への参照を取得することもできます。</span><span class="sxs-lookup"><span data-stu-id="deeae-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="deeae-233">次のスニペットは、このロジックを示しています。</span><span class="sxs-lookup"><span data-stu-id="deeae-233">The following snippet illustrates this logic:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample10.cs)]

<span data-ttu-id="deeae-234">このコードは確実に動作しますが、マスターページの自動生成された `ID` が常に `ctl00`であると想定しています。</span><span class="sxs-lookup"><span data-stu-id="deeae-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="deeae-235">自動生成された値についての仮定を作成することはお勧めできません。</span><span class="sxs-lookup"><span data-stu-id="deeae-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="deeae-236">幸いなことに、マスターページへの参照には、`Page` クラスの `Master` プロパティを使用してアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="deeae-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="deeae-237">したがって、`MainContent` ContentPlaceHolder にアクセスするためにマスターページの参照を取得するために `FindControl("ctl00")` を使用するのではなく、代わりに `Page.Master.FindControl("MainContent")`を使用できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="deeae-238">次のコードを使用して、`SubmitButton_Click` イベントハンドラーを更新します。</span><span class="sxs-lookup"><span data-stu-id="deeae-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample11.cs)]

<span data-ttu-id="deeae-239">今度は、ブラウザーを使用してページにアクセスし、年齢を入力して、[Submit] \ (送信 \) ボタンをクリックすると、`Results` ラベルにメッセージが表示されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>

<span data-ttu-id="deeae-240">[ユーザーの年齢がラベルに表示される ![](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="deeae-240">[![The User's Age is Displayed in the Label](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span></span>

<span data-ttu-id="deeae-241">**図 06**: ユーザーの年齢がラベルに表示される ([クリックすると、フルサイズの画像が表示](control-id-naming-in-content-pages-cs/_static/image12.png)されます)</span><span class="sxs-lookup"><span data-stu-id="deeae-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image12.png))</span></span>

### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="deeae-242">名前付けコンテナーを再帰的に検索する</span><span class="sxs-lookup"><span data-stu-id="deeae-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="deeae-243">前のコード例では、マスターページから `MainContent` ContentPlaceHolder コントロールを参照し、次に `MainContent`からの `Results` Label および `Age` TextBox コントロールを参照する理由は、`Control.FindControl` メソッドが*コントロール*の名前付けコンテナー内を検索するためです。</span><span class="sxs-lookup"><span data-stu-id="deeae-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="deeae-244">2つの異なる名前付けコンテナー内の2つのコントロールが同じ `ID` 値を持つ可能性があるので、ほとんどのシナリオでは、名前付けコンテナー内の `FindControl` を維持することは理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="deeae-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="deeae-245">`ProductName` という名前のラベル Web コントロールを TemplateFields の1つ内に定義する GridView の場合を考えてみます。</span><span class="sxs-lookup"><span data-stu-id="deeae-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="deeae-246">実行時にデータが GridView にバインドされると、GridView 行ごとに `ProductName` ラベルが作成されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="deeae-247">すべての名前付けコンテナーを検索 `FindControl`、`Page.FindControl("ProductName")`を呼び出した場合、`FindControl` が返すラベルのインスタンスはどのようなものでしょうか。</span><span class="sxs-lookup"><span data-stu-id="deeae-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="deeae-248">最初の GridView 行の `ProductName` ラベル</span><span class="sxs-lookup"><span data-stu-id="deeae-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="deeae-249">最後の行の1つ。</span><span class="sxs-lookup"><span data-stu-id="deeae-249">The one in the last row?</span></span>

<span data-ttu-id="deeae-250">そのため、ほとんどの場合、*コントロール*の名前付けコンテナーだけを `Control.FindControl` 検索することが理にかなっています。</span><span class="sxs-lookup"><span data-stu-id="deeae-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="deeae-251">ただし、他のケースもあります。たとえば、すべての名前付けコンテナーに一意の `ID` があり、コントロール階層内の各名前付けコンテナーを参照してコントロールにアクセスする必要がないようにする場合などです。</span><span class="sxs-lookup"><span data-stu-id="deeae-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="deeae-252">すべての名前付けコンテナーを再帰的に検索する `FindControl` バリアントを使用することも意味があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="deeae-253">残念ながら、.NET Framework にはこのようなメソッドは含まれていません。</span><span class="sxs-lookup"><span data-stu-id="deeae-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="deeae-254">優れたニュースとして、すべての名前付けコンテナーを再帰的に検索する独自の `FindControl` メソッドを作成できるということです。</span><span class="sxs-lookup"><span data-stu-id="deeae-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="deeae-255">実際には、*拡張メソッド*を使用して、既存の `FindControl` メソッドに付随する `FindControlRecursive` メソッドを `Control` クラスに付加することができます。</span><span class="sxs-lookup"><span data-stu-id="deeae-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="deeae-256">拡張メソッドは、 C# 3.0 および Visual Basic 9 の新機能であり、.NET Framework バージョン3.5 および Visual Studio 2008 に付属している言語です。</span><span class="sxs-lookup"><span data-stu-id="deeae-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="deeae-257">簡単に言えば、拡張メソッドを使用すると、開発者は特殊な構文を使用して既存のクラス型の新しいメソッドを作成できます。</span><span class="sxs-lookup"><span data-stu-id="deeae-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="deeae-258">この便利な機能の詳細については、「my article」 ([拡張メソッドを使用した基本型の機能の拡張](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)) を参照してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>

<span data-ttu-id="deeae-259">拡張メソッドを作成するには、`PageExtensionMethods.cs`という名前の `App_Code` フォルダーに新しいファイルを追加します。</span><span class="sxs-lookup"><span data-stu-id="deeae-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.cs`.</span></span> <span data-ttu-id="deeae-260">`controlID`という名前の `string` パラメーターを入力として受け取る `FindControlRecursive` という名前の拡張メソッドを追加します。</span><span class="sxs-lookup"><span data-stu-id="deeae-260">Add an extension method named `FindControlRecursive` that takes as an input a `string` parameter named `controlID`.</span></span> <span data-ttu-id="deeae-261">拡張メソッドが適切に機能するためには、クラス自体とその拡張メソッドが `static`としてマークされていることが重要です。</span><span class="sxs-lookup"><span data-stu-id="deeae-261">For extension methods to work properly, it is vital that the class itself and its extension methods be marked `static`.</span></span> <span data-ttu-id="deeae-262">さらに、すべての拡張メソッドは、拡張メソッドが適用される型のオブジェクトを最初のパラメーターとして受け取る必要があります。また、この入力パラメーターの前に `this`キーワードを付ける必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies, and this input parameter must be preceded with the keyword `this`.</span></span>

<span data-ttu-id="deeae-263">次のコードを `PageExtensionMethods.cs` クラスファイルに追加して、このクラスと `FindControlRecursive` 拡張メソッドを定義します。</span><span class="sxs-lookup"><span data-stu-id="deeae-263">Add the following code to the `PageExtensionMethods.cs` class file to define this class and the `FindControlRecursive` extension method:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample12.cs)]

<span data-ttu-id="deeae-264">このコードを配置したら、`IDIssues.aspx` ページの分離コードクラスに戻り、現在の `FindControl` メソッドの呼び出しをコメントアウトします。</span><span class="sxs-lookup"><span data-stu-id="deeae-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="deeae-265">これらを `Page.FindControlRecursive("controlID")`の呼び出しに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="deeae-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="deeae-266">拡張メソッドは、IntelliSense のドロップダウンリスト内に直接表示されるという点で便利です。</span><span class="sxs-lookup"><span data-stu-id="deeae-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="deeae-267">図7に示すように、「Page」と入力し、[period] をクリックすると、`FindControlRecursive` メソッドが、他の `Control` クラスのメソッドと共に IntelliSense のドロップダウンに含まれます。</span><span class="sxs-lookup"><span data-stu-id="deeae-267">As Figure 7 shows, when you type Page and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>

<span data-ttu-id="deeae-268">[IntelliSense のドロップダウンには ![拡張メソッドが含まれています](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="deeae-268">[![Extension Methods are Included in the IntelliSense Drop-Downs](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span></span>

<span data-ttu-id="deeae-269">**図 07**: 拡張メソッドが IntelliSense のドロップダウンに含まれる ([クリックしてフルサイズのイメージを表示する](control-id-naming-in-content-pages-cs/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="deeae-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image15.png))</span></span>

<span data-ttu-id="deeae-270">`SubmitButton_Click` イベントハンドラーに次のコードを入力し、ページにアクセスして年齢を入力し、[Submit] \ (送信 \) ボタンをクリックしてテストします。</span><span class="sxs-lookup"><span data-stu-id="deeae-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="deeae-271">図6に示すように、結果として得られる出力は "年齢は歳です" というメッセージになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample13.cs)]

> [!NOTE]
> <span data-ttu-id="deeae-272">拡張メソッドはC# 3.0 および Visual Basic 9 の新機能であるため、Visual Studio 2005 を使用している場合は、拡張メソッドを使用できません。</span><span class="sxs-lookup"><span data-stu-id="deeae-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="deeae-273">代わりに、ヘルパークラスに `FindControlRecursive` メソッドを実装する必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="deeae-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx)には、このような例が含まれています。この例は、ブログ投稿、 [ASP.NET メーザページ、および `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)です。</span><span class="sxs-lookup"><span data-stu-id="deeae-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>

## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="deeae-275">手順 4: クライアント側スクリプトで正しい`id`属性値を使用する</span><span class="sxs-lookup"><span data-stu-id="deeae-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="deeae-276">このチュートリアルの概要で説明したように、Web コントロールの表示される `id` 属性は、プログラムによって特定の HTML 要素を参照するために、クライアント側スクリプトでよく使用されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="deeae-277">たとえば、次の JavaScript は、`id` によって HTML 要素を参照し、その値をモーダルメッセージボックスに表示します。</span><span class="sxs-lookup"><span data-stu-id="deeae-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample14.cs)]

<span data-ttu-id="deeae-278">名前付けコンテナーを含まない ASP.NET ページでは、レンダリングされた HTML 要素の `id` 属性は、Web コントロールの `ID` プロパティ値と同じであることを思い出してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="deeae-279">このため、`id` 属性値を JavaScript コードにハードコーディングすることが魅力的です。</span><span class="sxs-lookup"><span data-stu-id="deeae-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="deeae-280">つまり、クライアント側スクリプトを使用して `Age` TextBox Web コントロールにアクセスすることがわかっている場合は、`document.getElementById("Age")`の呼び出しを使用します。</span><span class="sxs-lookup"><span data-stu-id="deeae-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="deeae-281">この方法の問題は、マスターページ (またはその他の名前付けコンテナーコントロール) を使用する場合、レンダリングされる HTML `id` が Web コントロールの `ID` プロパティと同義ではないことです。</span><span class="sxs-lookup"><span data-stu-id="deeae-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="deeae-282">最初の傾斜として、ブラウザーを使用してページにアクセスし、ソースを表示して実際の `id` 属性を確認することができます。</span><span class="sxs-lookup"><span data-stu-id="deeae-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="deeae-283">レンダリングされた `id` 値がわかれば、`getElementById` の呼び出しに貼り付けることで、クライアント側のスクリプトを使用して作業するために必要な HTML 要素にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="deeae-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="deeae-284">この方法は、ページのコントロール階層に対する特定の変更、または名前付けコントロールの `ID` プロパティの変更によって、結果の `id` 属性が変更され、その結果、JavaScript コードが破損するため、理想的な方法よりも小さくなります。</span><span class="sxs-lookup"><span data-stu-id="deeae-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="deeae-285">さいわいにも、表示される `id` 属性値は、Web コントロールの[`ClientID` プロパティ](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx)を通じてサーバー側のコードでアクセスできるということです。</span><span class="sxs-lookup"><span data-stu-id="deeae-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="deeae-286">このプロパティを使用して、クライアント側スクリプトで使用する `id` 属性値を決定する必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="deeae-287">たとえば、ページに JavaScript 関数を追加して、呼び出されたときに、モーダルメッセージボックスに `Age` TextBox の値を表示するには、`Page_Load` イベントハンドラーに次のコードを追加します。</span><span class="sxs-lookup"><span data-stu-id="deeae-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>

[!code-javascript[Main](control-id-naming-in-content-pages-cs/samples/sample15.js)]

<span data-ttu-id="deeae-288">上のコードでは、`getElementById`への JavaScript 呼び出しに `Age` TextBox の ClientID プロパティの値を挿入します。</span><span class="sxs-lookup"><span data-stu-id="deeae-288">The above code injects the value of the `Age` TextBox's ClientID property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="deeae-289">ブラウザーを使用してこのページにアクセスし、HTML ソースを表示すると、次の JavaScript コードが表示されます。</span><span class="sxs-lookup"><span data-stu-id="deeae-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample16.html)]

<span data-ttu-id="deeae-290">`getElementById`の呼び出し内で、正しい `id` 属性値 `ctl00_MainContent_Age`がどのように表示されるかに注目してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="deeae-291">この値は実行時に計算されるので、後でページコントロール階層に加えられた変更に関係なく動作します。</span><span class="sxs-lookup"><span data-stu-id="deeae-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="deeae-292">この JavaScript の例では、サーバーコントロールによってレンダリングされる HTML 要素を正しく参照する JavaScript 関数を追加する方法を示しています。</span><span class="sxs-lookup"><span data-stu-id="deeae-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="deeae-293">この関数を使用するには、ドキュメントの読み込み時または特定のユーザーアクションの発生時に関数を呼び出すために、追加の JavaScript を作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="deeae-294">これらのトピックと関連トピックの詳細については、「[クライアント側スクリプトの使用](https://msdn.microsoft.com/library/aa479302.aspx)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="deeae-295">まとめ</span><span class="sxs-lookup"><span data-stu-id="deeae-295">Summary</span></span>

<span data-ttu-id="deeae-296">特定の ASP.NET サーバーコントロールは、名前付けコンテナーとして機能します。これは、子孫コントロールの表示される `id` 属性値と、`FindControl` メソッドによって canvassed されるコントロールのスコープに影響します。</span><span class="sxs-lookup"><span data-stu-id="deeae-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="deeae-297">マスターページに関しては、マスターページ自体とその ContentPlaceHolder コントロールの両方がコンテナーに名前を付けています。</span><span class="sxs-lookup"><span data-stu-id="deeae-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="deeae-298">そのため、`FindControl`を使用してコンテンツページ内のコントロールをプログラムで参照するには、もう少し作業を行う必要があります。</span><span class="sxs-lookup"><span data-stu-id="deeae-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="deeae-299">このチュートリアルでは、ContentPlaceHolder コントロールへのドリルダウンと `FindControl` メソッドの呼び出しという2つの手法について説明します。また、すべての名前付けコンテナーを再帰的に検索する、独自の `FindControl` 実装をロールします。</span><span class="sxs-lookup"><span data-stu-id="deeae-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="deeae-300">参照先の Web コントロールに関して、コンテナーに名前を付けるサーバー側の問題に加えて、クライアント側の問題もあります。</span><span class="sxs-lookup"><span data-stu-id="deeae-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="deeae-301">名前付けコンテナーが存在しない場合、Web コントロールの `ID` プロパティ値と表示される `id` 属性値は同じになります。</span><span class="sxs-lookup"><span data-stu-id="deeae-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="deeae-302">ただし、名前付けコンテナーを追加すると、表示される `id` 属性には、Web コントロールの `ID` 値と、コントロール階層の先祖にある名前付けコンテナーの両方が含まれます。</span><span class="sxs-lookup"><span data-stu-id="deeae-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="deeae-303">これらの名前付けの問題は、Web コントロールの `ClientID` プロパティを使用して、クライアント側スクリプトで表示される `id` 属性値を決定する限り、問題にはなりません。</span><span class="sxs-lookup"><span data-stu-id="deeae-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="deeae-304">プログラミングを楽しんでください。</span><span class="sxs-lookup"><span data-stu-id="deeae-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="deeae-305">参考資料</span><span class="sxs-lookup"><span data-stu-id="deeae-305">Further Reading</span></span>

<span data-ttu-id="deeae-306">このチュートリアルで説明しているトピックの詳細については、次のリソースを参照してください。</span><span class="sxs-lookup"><span data-stu-id="deeae-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="deeae-307">ASP.NET マスターページと `FindControl`</span><span class="sxs-lookup"><span data-stu-id="deeae-307">ASP.NET Master Pages and `FindControl`</span></span>](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="deeae-308">動的データエントリのユーザーインターフェイスの作成</span><span class="sxs-lookup"><span data-stu-id="deeae-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="deeae-309">拡張メソッドを使用した基本型の機能の拡張</span><span class="sxs-lookup"><span data-stu-id="deeae-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="deeae-310">方法: ASP.NET マスターページコンテンツを参照する</span><span class="sxs-lookup"><span data-stu-id="deeae-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="deeae-311">マスターページ: ヒント、テクニック、およびトラップ</span><span class="sxs-lookup"><span data-stu-id="deeae-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="deeae-312">クライアント側スクリプトの操作</span><span class="sxs-lookup"><span data-stu-id="deeae-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="deeae-313">著者について</span><span class="sxs-lookup"><span data-stu-id="deeae-313">About the Author</span></span>

<span data-ttu-id="deeae-314">1998以降、Microsoft の Web テクノロジを使用して、 [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)(複数の asp/創設者4GuysFromRolla.com の執筆者) が Microsoft の Web テクノロジを使用しています。</span><span class="sxs-lookup"><span data-stu-id="deeae-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="deeae-315">Scott は、独立したコンサルタント、トレーナー、およびライターとして機能します。</span><span class="sxs-lookup"><span data-stu-id="deeae-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="deeae-316">彼の最新の書籍は[ *、ASP.NET 3.5 を24時間以内に教え*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ています。</span><span class="sxs-lookup"><span data-stu-id="deeae-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="deeae-317">Scott は、 [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)またはブログで[http://ScottOnWriting.NET](http://scottonwriting.net/)にアクセスできます。</span><span class="sxs-lookup"><span data-stu-id="deeae-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="deeae-318">ありがとうございました。</span><span class="sxs-lookup"><span data-stu-id="deeae-318">Special Thanks To</span></span>

<span data-ttu-id="deeae-319">このチュートリアルシリーズは、役に立つ多くのレビュー担当者によってレビューされました。</span><span class="sxs-lookup"><span data-stu-id="deeae-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="deeae-320">このチュートリアルのリーダーレビュー担当者は、Zack Jones と Suchi Barnerjee でした。</span><span class="sxs-lookup"><span data-stu-id="deeae-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="deeae-321">今後の MSDN 記事を確認することに興味がありますか?</span><span class="sxs-lookup"><span data-stu-id="deeae-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="deeae-322">その場合は、 [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)の行を削除します。</span><span class="sxs-lookup"><span data-stu-id="deeae-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="deeae-323">[前へ](urls-in-master-pages-cs.md)
> [次へ](interacting-with-the-master-page-from-the-content-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="deeae-323">[Previous](urls-in-master-pages-cs.md)
[Next](interacting-with-the-master-page-from-the-content-page-cs.md)</span></span>
