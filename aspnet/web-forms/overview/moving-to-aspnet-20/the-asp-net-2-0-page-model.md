---
uid: web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
title: ASP.NET 2.0 ページモデル |マイクロソフトドキュメント
author: rick-anderson
description: ASP.NET 1.x では、開発者はインライン コード モデルと分離コード モデルのどちらかを選択しました。 分離コードは、Src attr..のいずれかを使用して実装できます。
ms.author: riande
ms.date: 02/20/2005
ms.assetid: af4575a3-0ae3-4638-ba4d-218fad7a1642
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/the-asp-net-2-0-page-model
msc.type: authoredcontent
ms.openlocfilehash: 6c2435a06d04209db21fb8e075f68ff0b7a9ef7e
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542860"
---
# <a name="the-aspnet-20-page-model"></a>ASP.NET 2.0 ページ モデル

[マイクロソフト](https://github.com/microsoft)

> ASP.NET 1.x では、開発者はインライン コード モデルと分離コード モデルのどちらかを選択しました。 分離コードは、@Pageディレクティブの Src 属性または分離コード属性を使用して実装できます。 ASP.NET 2.0 では、開発者はインライン コードと分離コードのどちらかを選択できますが、分離コード モデルが大幅に強化されています。

ASP.NET 1.x では、開発者はインライン コード モデルと分離コード モデルのどちらかを選択しました。 分離コードは、@Pageディレクティブの Src 属性または分離コード属性を使用して実装できます。 ASP.NET 2.0 では、開発者はインライン コードと分離コードのどちらかを選択できますが、分離コード モデルが大幅に強化されています。

## <a name="improvements-in-the-code-behind-model"></a>分離コード モデルの改善点

ASP.NET 2.0 の分離コード モデルの変更点を完全に理解するために、モデルを 1.x に存在する場合は、そのモデルASP.NET迅速に確認することをお勧めします。

## <a name="the-code-behind-model-in-aspnet-1x"></a>ASP.NET 1.x の分離コード モデル

ASP.NET 1.x では、コード ビハインド モデルは ASPX ファイル (Web フォーム) と、プログラミング コードを含む分離コード ファイルで構成されていました。 2 つのファイルは、ASPX@Pageファイル内のディレクティブを使用して接続されています。 ASPX ページの各コントロールには、コード ビハインド ファイル内の対応する宣言がインスタンス変数として含まれています。 分離コード ファイルには、イベント バインディング用のコードと、Visual Studio デザイナーに必要な生成コードも含まれています。 このモデルはかなりうまく機能しましたが、ASPX ページ内のすべてのASP.NET要素は、分離コード ファイル内の対応するコードを必要とするため、コードとコンテンツの実際の分離はありませんでした。 たとえば、デザイナーが Visual Studio IDE の外部の ASPX ファイルに新しいサーバー コントロールを追加した場合、分離コード ファイルにそのコントロールの宣言がないため、アプリケーションが中断します。

## <a name="the-code-behind-model-in-aspnet-20"></a>ASP.NET 2.0 の分離コード モデル

ASP.NET 2.0 はこのモデルを大幅に改善します。 ASP.NET 2.0 では、ASP.NET 2.0 で提供される新しい*部分クラス*を使用して分離コードが実装されます。 ASP.NET 2.0 の分離コード クラスは、部分クラスとして定義されています。 クラス定義の残りの部分は、実行時または Web サイトがプリコンパイルされるときに ASPX ページを使用して ASP.NET 2.0 によって動的に生成されます。 コード ビハインド ファイルと ASPX ページ間のリンクは、 @ Page ディレクティブを使用して確立されます。 ただし、分離コード属性または Src 属性の代わりに、ASP.NET 2.0 では CodeFile 属性が使用されるようになりました。 継承属性は、ページのクラス名を指定するためにも使用されます。

一般的な @ Page ディレクティブは次のようになります。

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample1.aspx)]

ASP.NET 2.0 の分離コード ファイルの一般的なクラス定義は、次のようになります。

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample2.cs)]

> [!NOTE]
> C# と Visual Basic は、現在部分クラスをサポートしている唯一のマネージ言語です。 したがって、J# を使用する開発者は、ASP.NET 2.0 で分離コード モデルを使用することはできません。

開発者は、作成したコードのみを含むコード ファイルを作成するため、新しいモデルは分離コード モデルを強化します。 また、分離コード ファイルにはインスタンス変数の宣言がないため、コードとコンテンツを実際に分離できます。

> [!NOTE]
> ASPX ページの部分クラスはイベント バインディングが行われる場所であるため、Visual Basic の開発者は、分離コード内の Handles キーワードを使用してイベントをバインドすることで、パフォーマンスのわずかな向上を実現できます。 C# には、同等のキーワードはありません。

## <a name="new--page-directive-attributes"></a>新しい @ ページ ディレクティブ属性

ASP.NET 2.0 は、 @ Page ディレクティブに多くの新しい属性を追加します。 次の属性は、ASP.NET 2.0 で新しく追加されています。

## <a name="async"></a>Async

Async 属性を使用すると、非同期で実行されるページを構成できます。 このモジュールの後半で非同期ページを説明します。

## <a name="asynctimeout"></a>非同期タイムアウト

非同期ページのタイムアウトを指定しました。 デフォルトは 45 秒です。

## <a name="codefile"></a>Codefile

コード ファイル属性は、Visual Studio 2002/2003 の分離コード属性の代わりです。

### <a name="codefilebaseclass"></a>クラス

CodeFileBaseClass 属性は、複数のページを 1 つの基本クラスから派生させる場合に使用されます。 この属性を指定せずにASP.NET部分クラスを実装しているため、共有の共通フィールドを使用して ASPX ページで宣言されたコントロールを参照する基本クラスは、ASP.NETs コンパイル エンジンがページ内のコントロールに基づいて新しいメンバーを自動的に作成するため、正しく動作しません。 したがって、ASP.NETで 2 つ以上のページに共通の基本クラスを作成する場合は、CodeFileBaseClass 属性で基本クラスを定義し、その基本クラスから各ページ クラスを派生させる必要があります。 この属性を使用する場合は、CodeFile 属性も必要です。

## <a name="compilationmode"></a>コンパイルモード

この属性を使用すると、ASPX ページのコンパイル モード プロパティを設定できます。 プロパティは、**値を含**む列挙体常に、**自動**、および**Never**です。 デフォルトは **[常に]** です。 **自動**設定を使用すると、可能な場合ASP.NETページが動的にコンパイルされるのを防ぐことができます。 動的コンパイルからページを除外すると、パフォーマンスが向上します。 ただし、除外されるページにコンパイルする必要のあるコードが含まれている場合は、ページを参照するときにエラーがスローされます。

## <a name="enableeventvalidation"></a>イベントの検証を有効にする

この属性は、ポストバック イベントとコールバック イベントを検証するかどうかを指定します。 これが有効な場合、ポストバックイベントまたはコールバックイベントの引数がチェックされ、イベントを最初にレンダリングしたサーバー コントロールから発生していることを確認します。

## <a name="enabletheming"></a>テーマを有効にする

この属性は、ASP.NETテーマをページで使用するかどうかを指定します。 デフォルトは**false**です。 ASP.NETテーマについては[、モジュール 10](profiles-themes-and-web-parts.md)で説明します。

## <a name="linepragmas"></a>ラインプラグマ

この属性は、コンパイル時に行プラグマを追加するかどうかを指定します。 行プラグマは、デバッガーがコードの特定のセクションをマークするために使用するオプションです。

## <a name="maintainscrollpositiononpostback"></a>ポストバックのメンテナンススクロール位置

この属性は、ポストバック間のスクロール位置を維持するために、ページに JavaScript を挿入するかどうかを指定します。 この属性は、デフォルトでは**false**です。

この属性が**true の**場合、ASP.NET&lt;は&gt;次のようなスクリプト ブロックをポストバックに追加します。

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample3.html)]

このスクリプト ブロックの src は WebResource.axd であることに注意してください。 このリソースは物理パスではありません。 このスクリプトが要求されると、ASP.NET動的にスクリプトが作成されます。

### <a name="masterpagefile"></a>マスターページファイル

この属性は、現在のページのマスター ページ ファイルを指定します。 相対パスと絶対パスのどちらでも構いません。 マスター ページについては、[モジュール 4](master-pages.md)で説明します。

## <a name="stylesheettheme"></a>スタイルシートテーマ

この属性を使用すると、ASP.NET 2.0 テーマで定義されたユーザー インターフェイスの外観プロパティをオーバーライドできます。 テーマについては[、モジュール 10](profiles-themes-and-web-parts.md)で説明します。

## <a name="theme"></a>テーマ

ページのテーマを指定します。 StyleSheetTheme 属性に値が指定されていない場合、テーマ属性はページ上のコントロールに適用されているすべてのスタイルをオーバーライドします。

## <a name="title"></a>タイトル

ページのタイトルを設定します。 ここで指定した値は、レンダリングされた&lt;ページ&gt;の title 要素に表示されます。

### <a name="viewstateencryptionmode"></a>を使用します。

列挙体の値を設定します。 使用できる値は **、[常時]、[****自動**]、[**しない**] です。 既定値は **[自動] です**。この属性が**Auto**の値に設定されている場合、ビューステートは暗号化され、コントロールは**RegisterRequiresViewStateEncryption**メソッドを呼び出して要求します。

## <a name="setting-public-property-values-via-the--page-directive"></a>@ Page ディレクティブを使用したパブリック プロパティ値の設定

ASP.NET 2.0 の @ Page ディレクティブのもう 1 つの新機能は、基本クラスのパブリック プロパティの初期値を設定する機能です。 たとえば、基本クラスに**SomeText**というパブリック プロパティがあり、ページが読み込まれたときに**Hello**に初期化するとします。 これを実現するには、@ Page ディレクティブの値を次のように設定するだけです。

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample4.aspx)]

@ Page ディレクティブの**SomeText**属性は、基本クラスの SomeText プロパティの初期値を*Hello!* に設定します。 次のビデオでは、 @ Page ディレクティブを使用して、基本クラスでパブリック プロパティの初期値を設定するチュートリアルです。

![](the-asp-net-2-0-page-model/_static/image1.png)

[フルスクリーンビデオを開く](the-asp-net-2-0-page-model/_static/setprop1.wmv)

## <a name="new-public-properties-of-the-page-class"></a>ページ クラスの新しいパブリック プロパティ

次のパブリック プロパティは、ASP.NET 2.0 で新しく追加されました。

## <a name="apprelativetemplatesourcedirectory"></a>ディレクトリ

ページまたはコントロールへのアプリケーション相対パスを返します。 たとえば、 にあるhttp://app/folder/page.aspxページの場合、プロパティは ~/folder/ を返します。

## <a name="apprelativevirtualpath"></a>仮想パス

ページまたはコントロールへの相対仮想ディレクトリ パスを返します。 たとえば、 にあるhttp://app/folder/page.aspxページの場合、プロパティは ~/フォルダー/page.aspx を返します。

## <a name="asynctimeout"></a>非同期タイムアウト

非同期ページ処理に使用されるタイムアウトを取得または設定します。 (非同期ページについては、このモジュールの後半で説明します)。

## <a name="clientquerystring"></a>クライアント文字列

要求された URL のクエリ文字列部分を返す読み取り専用プロパティ。 この値は URL エンコードされます。 クラスの UrlDecode メソッドを使用して、それをデコードできます。

## <a name="clientscript"></a>クライアントスクリプト

このプロパティは、クライアント側スクリプトの ASP.NETs の発行を管理するために使用できる ClientScriptManager オブジェクトを返します。 (このモジュールでは、後でクラスについて説明します)。

## <a name="enableeventvalidation"></a>イベントの検証を有効にする

このプロパティは、イベントの検証がポストバック イベントとコールバック イベントに対して有効かどうかを制御します。 有効にすると、ポストバックイベントまたはコールバックイベントの引数が検証され、イベントを最初にレンダリングしたサーバー コントロールから発生していることを確認します。

## <a name="enabletheming"></a>テーマを有効にする

このプロパティは、2.0 のテーマ ASP.NETをページに適用するかどうかを指定するブール値を取得または設定します。

## <a name="form"></a>Form

このプロパティは、ASPX ページの HTML フォームを HtmlForm オブジェクトとして返します。

## <a name="header"></a>ヘッダー

このプロパティは、ページ ヘッダーを含む HtmlHead オブジェクトへの参照を返します。 返された HtmlHead オブジェクトを使用して、スタイル シートやメタ タグなどを取得/設定できます。

## <a name="idseparator"></a>イドセパレータ

この読み取り専用プロパティは、ASP.NETがページ上のコントロールの一意の ID を構築するときに、コントロール識別子を区切るために使用される文字を取得します。 コードから直接使用するためのものではありません。

## <a name="isasync"></a>IsAsync

このプロパティは、非同期ページを使用できます。 非同期ページについては、このモジュールで後述します。

## <a name="iscallback"></a>IsCallback

この読み取り専用プロパティは、ページがコールバックの結果である場合に**true**を返します。 コールバックについては、このモジュールで後述します。

## <a name="iscrosspagepostback"></a>ページポストバック

この読み取り専用プロパティは、ページがページ間ポストバックの一部である場合は**true**を返します。 ページ間のポストバックについては、このモジュールの後半で説明します。

## <a name="items"></a>アイテム

ページ コンテキストに格納されているすべてのオブジェクトを含む IDictionary インスタンスへの参照を返します。 この IDictionary オブジェクトに項目を追加すると、コンテキストの有効期間を通じて使用できます。

## <a name="maintainscrollpositiononpostback"></a>ポストバックを維持します。

このプロパティは、ポストバックASP.NET発生した後に、ブラウザーでページのスクロール位置を維持する JavaScript を出力するかどうかを制御します。 (このプロパティの詳細については、このモジュールで前述しました)。

## <a name="master"></a>Master

この読み取り専用プロパティは、マスター ページが適用されているページの MasterPage インスタンスへの参照を返します。

## <a name="masterpagefile"></a>マスターページファイル

ページのマスター ページのファイル名を取得または設定します。 このプロパティは、PreInit メソッドでのみ設定できます。

## <a name="maxpagestatefieldlength"></a>フィールドの長さを変更します。

このプロパティは、ページの状態の最大長をバイト単位で取得または設定します。 プロパティに正の数を設定すると、ページのビューステートは複数の隠しフィールドに分割され、指定したバイト数を超えないようにします。 プロパティが負の数の場合、ビュー ステートはチャンクに分割されません。

## <a name="pageadapter"></a>ページアダプター

要求元のブラウザーのページを変更する PageAdapter オブジェクトへの参照を返します。

## <a name="previouspage"></a>Previouspage

Server.Transfer またはページ間ポストバックの場合は、前のページへの参照を返します。

## <a name="skinid"></a>Skinid

ページに適用するASP.NET 2.0 スキンを指定します。

## <a name="stylesheettheme"></a>スタイルシートテーマ

このプロパティは、ページに適用されるスタイル シートを取得または設定します。

## <a name="templatecontrol"></a>テンプレートコントロール

ページのコントロールを含むコントロールへの参照を返します。

## <a name="theme"></a>テーマ

ページに適用されるASP.NET 2.0 テーマの名前を取得または設定します。 この値は PreInit メソッドの前に設定する必要があります。

## <a name="title"></a>タイトル

このプロパティは、ページ ヘッダーから取得されたページのタイトルを取得または設定します。

## <a name="viewstateencryptionmode"></a>を使用します。

ページのビューステート暗号化モードを取得または設定します。 このモジュールの前のこのプロパティの詳細な説明を参照してください。

## <a name="new-protected-properties-of-the-page-class"></a>ページ クラスの新しい保護されたプロパティ

次に示す新しい保護された Page クラスの ASP.NET 2.0.

## <a name="adapter"></a>アダプター

要求したデバイス上でページを表示する ControlAdapter への参照を返します。

## <a name="asyncmode"></a>非同期モード

このプロパティは、ページが非同期で処理されるかどうかを示します。 これは、コード内で直接使用するものではなく、ランタイムで使用することを目的としています。

## <a name="clientidseparator"></a>クライアント ID 区切り記号

このプロパティは、コントロールの一意のクライアント ID を作成するときに区切り文字として使用される文字を返します。 これは、コード内で直接使用するものではなく、ランタイムで使用することを目的としています。

## <a name="pagestatepersister"></a>ページステートパーシスター

このプロパティは、ページの PageStatePersister オブジェクトを返します。 このプロパティは、主にASP.NETコントロール開発者によって使用されます。

## <a name="uniquefilepathsuffix"></a>一意のファイルパスサフィックス

このプロパティは、ブラウザをキャッシュするためのファイル パスに付加される一意のサフィックスを返します。 デフォルト値は\_\_ufps= と 6 桁の数字です。

## <a name="new-public-methods-for-the-page-class"></a>ページ クラスの新しいパブリック メソッド

次のパブリック メソッドは、ASP.NET 2.0 の Page クラスの新機能です。

## <a name="addonprerendercompleteasync"></a>コンプリーレンダリングコンプリートアシンク

このメソッドは、非同期ページ実行のイベント ハンドラー デリゲートを登録します。 非同期ページについては、このモジュールで後述します。

## <a name="applystylesheetskin"></a>スタイルシートスキンを適用する

ページ スタイル シートのプロパティをページに適用します。

## <a name="executeregisteredasynctasks"></a>登録された非同期タスクを実行します。

このメソッドは非同期タスクを使用します。

### <a name="getvalidators"></a>検証ツールを取得する

指定した検証グループの検証コントロールのコレクションを返します。

## <a name="registerasynctask"></a>同期タスクを登録します。

このメソッドは、新しい非同期タスクを登録します。 非同期ページについては、このモジュールの後半で説明します。

## <a name="registerrequirescontrolstate"></a>コントロール状態を登録する

このメソッドは、ASP.NETページ コントロールの状態を永続化する必要があることを通知します。

## <a name="registerrequiresviewstateencryption"></a>を要求します。

このメソッドは、ページの viewstate に暗号化が必要であることをASP.NETに通知します。

## <a name="resolveclienturl"></a>クライアント Url を解決します。

イメージなどのクライアント要求に使用できる相対 URL を返します。

## <a name="setfocus"></a>SetFocus

このメソッドは、ページが最初に読み込まれるときに指定されたコントロールにフォーカスを設定します。

## <a name="unregisterrequirescontrolstate"></a>登録を解除するコントロール状態を確認します。

このメソッドは、コントロール状態の永続化を必要としないために渡されたコントロールの登録を解除します。

## <a name="changes-to-the-page-lifecycle"></a>ページのライフサイクルの変更

ASP.NET 2.0 のページライフサイクルは劇的に変化していませんが、注意すべき新しい方法がいくつかあります。 ASP.NET 2.0 ページのライフサイクルについて、以下に概説します。

## <a name="preinit-new-in-aspnet-20"></a>プレイニト(ASP.NET 2.0で新しい)

PreInit イベントは、開発者がアクセスできるライフサイクルの最も初期のステージです。 このイベントを追加すると、プログラムによって、2.0 のテーマ、マスター ページ、ASP.NET 2.0 プロファイルのプロパティへのアクセスなどをプログラムで ASP.NET変更できます。ポストバック状態にある場合は、ライフサイクルのこの時点で Viewstate がまだコントロールに適用されていないということを理解することが重要です。 したがって、開発者がこの段階でコントロールのプロパティを変更すると、ページのライフサイクルの後半で上書きされる可能性があります。

## <a name="init"></a>Init

Init イベントは、ASP.NET 1.x から変更されていません。 ページ上のコントロールのプロパティを読み取りまたは初期化する場所です。 この段階では、マスターページ、テーマなどが既にページに適用されています。

## <a name="initcomplete-new-in-20"></a>イニトコンプリート(2.0で新しい)

初期化ステージの最後に InitComplete イベントが呼び出されます。 ライフサイクルのこの時点で、ページ上のコントロールにアクセスできますが、その状態はまだ設定されていません。

## <a name="preload-new-in-20"></a>プリロード (2.0 での新機能)

このイベントは、すべてのポストバック データが適用された後、ページ\_読み込みの直前に呼び出されます。

## <a name="load"></a>[読み込み]

Load イベントは、ASP.NET 1.x から変更されていません。

## <a name="loadcomplete-new-in-20"></a>ロード完了(2.0 での新機能)

LoadComplete イベントは、ページ読み込みステージの最後のイベントです。 この段階では、すべてのポストバックデータとビューステートデータがページに適用されています。

## <a name="prerender"></a>Prerender

動的にページに追加されるコントロールに対してビューステートを適切に維持する場合は、PreRender イベントが最後に追加されます。

## <a name="prerendercomplete-new-in-20"></a>プレレンダリングコンプリート(2.0で新しい)

PreRenderComplete ステージで、すべてのコントロールがページに追加され、ページをレンダリングする準備が整いました。 PreRenderComplete イベントは、ページのビューステートが保存される前に発生する最後のイベントです。

## <a name="savestatecomplete-new-in-20"></a>セーブステートコンプリート(2.0で新規)

SaveStateComplete イベントは、すべてのページのビューステートとコントロールの状態が保存された直後に呼び出されます。 これは、ページが実際にブラウザーにレンダリングされる前の最後のイベントです。

## <a name="render"></a>レンダー

1.x 以降、Render メソッドは変更ASP.NET。 ここで、HtmlTextWriter が初期化され、ページがブラウザーにレンダリングされます。

## <a name="cross-page-postback-in-aspnet-20"></a>ASP.NET 2.0 でのページ間のポストバック

ASP.NET 1.x では、ポストバックが同じページにポストする必要がありました。 ページ間のポストバックは許可されませんでした。 ASP.NET 2.0 は、IButtonControl インターフェイスを介して別のページにポストバックする機能を追加します。 新しい IButtonControl インターフェイス (ボタン、リンク ボタン、およびサード パーティのカスタム コントロールに加えて、イメージ ボタン) を実装するすべてのコントロールは、PostBackUrl 属性を使用して、この新しい機能を利用できます。 次のコードは、2 番目のページにポストバックする Button コントロールを示しています。

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample5.aspx)]

ページがポストバックされると、ポストバックを開始する Page には、2 ページ目の PreviousPage プロパティを使用してアクセスできます。 この機能は、コントロールが別のページに\_ポストバックしたときに 2.0 ASP.NETページにレンダリングされる新しい WebForm DoPostBackWithOptions クライアント側の関数を介して実装されます。 この JavaScript 関数は、クライアントにスクリプトを出力する新しい WebResource.axd ハンドラーによって提供されます。

以下のビデオは、ページ間のポストバックのチュートリアルです。

![](the-asp-net-2-0-page-model/_static/image2.png)

[フルスクリーンビデオを開く](the-asp-net-2-0-page-model/_static/xpage1.wmv)

## <a name="more-details-on-cross-page-postbacks"></a>ページ間ポストバックの詳細

### <a name="viewstate"></a>Viewstate

ページ間ポストバック シナリオの最初のページから viewstate に何が起こるかについて、既に自問している可能性があります。 結局のところ、IPostBackDataHandler を実装しないコントロールはビューステートを介してその状態を保持するため、ページ間ポストバックの 2 ページ目でそのコントロールのプロパティにアクセスするには、ページのビューステートにアクセスする必要があります。 ASP.NET 2.0 は PREVIOUSPAGE という 2\_\_番目のページの新しい隠しフィールドを使用して、このシナリオを処理します。 PREVIOUSPAGE\_\_フォーム フィールドには、最初のページのビューステートが含まれているため、2 番目のページのすべてのコントロールのプロパティにアクセスできます。

### <a name="circumventing-findcontrol"></a>検索コントロールの回避

クロスページ ポストバックのビデオ チュートリアルでは、最初のページの TextBox コントロールへの参照を取得するのには FindControl メソッドを使用しました。 このメソッドは、この目的のためにうまく機能しますが、FindControl は高価であり、追加のコードを記述する必要があります。 幸いにも、ASP.NET 2.0 では、この目的のために FindControl の代わりとなるものが用意されています。 PreviousPageType ディレクティブを使用すると、TypeName 属性または VirtualPath 属性を使用して、前のページへの厳密に型指定された参照を持つことができます。 TypeName 属性では、前のページの種類を指定することができますが、VirtualPath 属性を使用すると、仮想パスを使用して前のページを参照できます。 PreviousPageType ディレクティブを設定した後、パブリック プロパティを使用してアクセスを許可するコントロールなどを公開する必要があります。

## <a name="lab-1-cross-page-postback"></a>ラボ 1 クロスページ ポストバック

このラボでは、ASP.NET 2.0 の新しいページ間ポストバック機能を使用するアプリケーションを作成します。

1. Visual Studio 2005 を開き、新しいASP.NET Web サイトを作成します。
2. page2.aspx という名前の新しい Web フォームを追加します。
3. デザイン ビューで Default.aspx を開き、ボタン コントロールと TextBox コントロールを追加します。 

    1. ボタン コントロールに**送信ボタン**の ID を与え、テキスト ボックス コントロールに**ユーザー名**の ID を与えます。
    2. ボタンの PostBackUrl プロパティを page2.aspx に設定します。
4. ソース ビューで page2.aspx を開きます。
5. 次に示すように、 @ PreviousPageType ディレクティブを追加します。
6. page2.aspx の分離\_コードのページ読み込みに次のコードを追加します。 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample6.cs)]
7. [ビルド] メニューの [ビルド] をクリックして、プロジェクトをビルドします。
8. Default.aspx の分離コードに次のコードを追加します。 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample7.cs)]
9. page2.aspx のページ\_読み込みを次のように変更します。 

    [!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample8.cs)]
10. プロジェクトをビルドします。
11. プロジェクトを実行します。
12. テキスト ボックスに自分の名前を入力し、ボタンをクリックします。
13. 結果は何ですか?

## <a name="asynchronous-pages-in-aspnet-20"></a>ASP.NET 2.0 の非同期ページ

ASP.NETの競合の問題の多くは、外部呼び出し (Web サービスやデータベース呼び出しなど) の遅延、ファイル IO の待ち時間などによって発生します。ASP.NETアプリケーションに対して要求が行われると、ASP.NETはその要求を処理するためにワーカー スレッドの 1 つを使用します。 要求が完了し、応答が送信されるまで、その要求はそのスレッドを所有します。 ASP.NET 2.0 では、ページを非同期に実行する機能を追加することで、このような種類の問題に関する待ち時間の問題を解決します。 つまり、ワーカー スレッドは要求を開始し、別のスレッドに追加の実行を渡すことができるので、使用可能なスレッド プールにすばやく戻ります。 ファイル IO、データベース呼び出しなどが完了すると、スレッド プールから新しいスレッドを取得して要求を完了します。

ページを非同期に実行する最初の手順は、次のように page ディレクティブの**Async**属性を設定することです。

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample9.aspx)]

この属性は、ページの IHttpAsyncHandler を実装するASP.NETを指示します。

次の手順では、ページのライフサイクル内の 1 つの時点で、PreRender の前に AddOnPreRenderCompleteAsync メソッドを呼び出します。 (このメソッドは通常、ページの\_読み込みで呼び出されます)。メソッドは 2 つのパラメーターを受け取ります。を開始イベント ハンドラーとエンドイベント ハンドラー。 メソッドを返す、 IAsyncResult をパラメーターとして渡します。

以下のビデオは、非同期ページ要求のチュートリアルです。

![](the-asp-net-2-0-page-model/_static/image3.png)

[フルスクリーンビデオを開く](the-asp-net-2-0-page-model/_static/async1.wmv)

> [!NOTE]
> 非同期ページは、EndEventHandler が完了するまでブラウザーにレンダリングされません。 間違いなく、一部の開発者は非同期要求を非同期コールバックに似ていると考えます。 彼らがそうではないことを認識することが重要です。 非同期要求の利点は、最初のワーカー スレッドをスレッド プールに返して新しい要求を処理できるため、IO バインドによる競合が軽減されることです。

## <a name="script-callbacks-in-aspnet-20"></a>ASP.NET 2.0 のスクリプト コールバック

Web 開発者は、コールバックに関連付けられたちらつきを防ぐ方法を常に探してきました。 ASP.NET 1.x では、SmartNavigation はちらつきを避ける最も一般的な方法でしたが、クライアントでの実装が複雑なため、SmartNavigation が一部の開発者に問題を引き起こしました。 ASP.NET 2.0 は、スクリプト コールバックでこの問題を解決します。 スクリプト コールバックは、XmlHttp を使用して、JavaScript を介して Web サーバーに対して要求を行います。 XMLHttp 要求は、ブラウザーの DOM を介して操作できる XML データを返します。 新しい WebResource.axd ハンドラーによって、ユーザーから XMLHttp コードが非表示になります。

スクリプト コールバックを ASP.NET 2.0 で設定するには、いくつかの手順が必要です。

## <a name="step-1--implement-the-icallbackeventhandler-interface"></a>ステップ 1 : インターフェイスを実装します。

ASP.NETがページをスクリプト コールバックに参加していると認識するには、ICallbackEventHandler インターフェイスを実装する必要があります。 これをコードビハインド ファイルで次のように行うことができます。

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample10.cs)]

@ Implements ディレクティブを使用して、次のようにすることもできます。

[!code-aspx[Main](the-asp-net-2-0-page-model/samples/sample11.aspx)]

通常、インラインASP.NETコードを使用する場合は、 @ Implements ディレクティブを使用します。

## <a name="step-2--call-getcallbackeventreference"></a>ステップ 2 : 呼び出しを呼び出します。

前述のように、XMLHttp 呼び出しは WebResource.axd ハンドラーにカプセル化されます。 ページがレンダリングされると、ASP.NETは WebResource.axd\_によって提供されるクライアント スクリプトである WebForm DoCallback への呼び出しを追加します。 \_関数は、コールバックの doPostBack\_\_関数を置き換えます。 doPostBack は\_\_、プログラムによってページ上のフォームを送信します。 コールバック シナリオでは、ポストバックを防ぐ必要があるため\_\_、doPostBack では十分ではありません。

> [!NOTE]
> \_\_doPostBack は、クライアント スクリプト コールバック シナリオでページにレンダリングされます。 ただし、コールバックには使用されません。

Web フォーム\_の DoCallback クライアント側関数の引数は、通常ページ\_の読み込みで呼び出されるサーバー側関数 GetCallbackEventReference を介して提供されます。 一般的な呼び出しは次のようになります。

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample12.cs)]

> [!NOTE]
> この場合、cm はクライアントスクリプト マネージャーのインスタンスです。 このモジュールでは、後ほどクラスについて説明します。

いくつかのオーバーロードされたバージョンがあります。 この場合、引数は次のようになります。

`this`

呼び出されているコントロールへの参照。 この場合、ページ自体です。

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample13.js)]

クライアント側のコードからサーバー側のイベントに渡される文字列引数。 この場合、DdlCompany と呼ばれるドロップダウンの値を渡します。

`ShowCompanyName`

サーバー側のコールバック イベントから戻り値 (文字列) を受け取るクライアント側関数の名前。 この関数は、サーバー側のコールバックが成功した場合にのみ呼び出されます。 したがって、堅牢性のために、通常は、エラーが発生した場合に実行するクライアント側関数の名前を指定する追加の文字列引数を受け取る、オーバーロードされたバージョンの GetCallbackEventReference を使用することをお勧めします。

`null`

サーバーへのコールバックの前に開始したクライアント側の関数を表す文字列。 この場合、そのようなスクリプトは存在しませんので、引数は null です。

`true`

コールバックを非同期に実行するかどうかを指定するブール値。

クライアント上の Web\_フォーム DoCallback の呼び出しは、これらの引数を渡します。 したがって、このページがクライアントで表示されるとき、そのコードは次のようになります。

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample14.js)]

クライアント上の関数のシグネチャが少し異なっていることに注意してください。 クライアント側の関数は、5 つの文字列とブール値を渡します。 追加の文字列 (上記の例では null) には、サーバー側のコールバックからのエラーを処理するクライアント側関数が含まれています。

## <a name="step-3--hook-the-client-side-control-event"></a>手順 3 : クライアント側コントロール イベントをフックする

上記の GetCallbackEventReference の戻り値が文字列変数に割り当てられていることに注意してください。 この文字列は、コールバックを開始するコントロールのクライアント側イベントをフックするために使用されます。 この例では、コールバックはページのドロップダウンによって開始されるため *、OnChange*イベントをフックしたいと思います。

クライアント側のイベントをフックするには、次のように、クライアント側のマークアップにハンドラーを追加します。

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample15.cs)]

*cbRef*は呼び出しからの戻り値であることを思い出してください。 このファイルには、上記の\_Web フォーム DoCallback への呼び出しが含まれています。

## <a name="step-4--register-the-client-side-script"></a>手順 4 : クライアント側スクリプトを登録する

呼び出しは、サーバー側のコールバックが成功したときに**ShowCompanyName**という名前のクライアント側スクリプトが実行されることを指定したことを思い出してください。 このスクリプトは、ClientScriptManager インスタンスを使用してページに追加する必要があります。 (このモジュールでは、後でクラスについて説明します)。あなたはそうします:

[!code-javascript[Main](the-asp-net-2-0-page-model/samples/sample16.js)]

## <a name="step-5--call-the-methods-of-the-icallbackeventhandler-interface"></a>ステップ 5 : インターフェイスのメソッドを呼び出します。

コード内で実装する必要がある 2 つのメソッドが含まれています。 これらは **、コールバック イベント**と**コールバック イベントを取得します**。

**イベントは**文字列を引数として受け取り、何も返しません。 文字列引数は、クライアント側の呼び出しから Web\_フォームの DoCallback に渡されます。 この場合、その値は ddlCompany と呼ばれるドロップダウンの*値*属性です。 サーバー側のコードは、メソッドに配置する必要があります。 たとえば、コールバックが外部リソースに対して WebRequest を作成している場合、そのコードを RaiseCallbackEvent に配置する必要があります。

**コールバック**のコールバックのクライアントへの戻り値を処理する役割を持つイベントです。 引数を受け取らず、文字列を返します。 返される文字列は、引数としてクライアント側の関数に渡*されます。*

上記の手順を完了したら、スクリプトコールバックを ASP.NET 2.0 で実行する準備が整いました。

![](the-asp-net-2-0-page-model/_static/image4.png)

[フルスクリーンビデオを開く](the-asp-net-2-0-page-model/_static/callback1.wmv)

ASP.NETのスクリプト コールバックは、XMLHttp 呼び出しをサポートするすべてのブラウザーでサポートされています。 これには、現在使用されているすべての最新のブラウザが含まれます。 インターネット エクスプローラは XMLHttp ActiveX オブジェクトを使用し、他の最新のブラウザ (今後の IE 7 を含む) は組み込みの XMLHttp オブジェクトを使用します。 ブラウザーがコールバックをサポートしているかどうかをプログラムで判断するには **、Request.Browser.SupportCallback**プロパティを使用できます。 要求元のクライアントがスクリプト コールバックをサポートしている場合、このプロパティは**true**を返します。

## <a name="working-with-client-script-in-aspnet-20"></a>ASP.NET 2.0 でのクライアント スクリプトの操作

ASP.NET 2.0 のクライアント スクリプトは、ClientScriptManager クラスを使用して管理されます。 クラスは、型と名前を使用してクライアント スクリプトを追跡します。 これにより、同じスクリプトがプログラムによってページに複数回挿入されるのを防ぎます。

> [!NOTE]
> スクリプトがページに正常に登録された後、同じスクリプトを登録しようとすると、スクリプトが 2 回目に登録されなくなるだけです。 重複するスクリプトは追加されず、例外も発生しません。 不要な計算を避けるために、スクリプトが既に登録されているかどうかを判断して、スクリプトを複数回登録しないようにする方法があります。

ClientScriptManager のメソッドは、現在のすべてのASP.NET開発者に精通している必要があります。

## <a name="registerclientscriptblock"></a>クライアント スクリプト ブロックを登録します。

このメソッドは、レンダリングされたページの先頭にスクリプトを追加します。 これは、クライアントで明示的に呼び出される関数を追加する場合に便利です。

このメソッドには、2 つのオーバーロードされたバージョンがあります。 4つの引数のうち3つは、その中で一般的です。 これらは次のとおりです。

`type (string)`

***型***引数は、スクリプトの型を識別します。 一般的には、ページの型 (this.型の GetType())。

`key (string)`

***キー***引数は、スクリプトのユーザー定義キーです。 これは、スクリプトごとに一意である必要があります。 既に追加されたスクリプトと同じキーと種類のスクリプトを追加しようとしても、スクリプトは追加されません。

`script (string)`

***script***引数は、追加する実際のスクリプトを含む文字列です。 スクリプトを作成するには、文字列ビルダーを使用し、***スクリプト引数を***割り当てるには、StringBuilder の ToString() メソッドを使用することをお勧めします。

3 つの引数しか取りませんが、オーバーロードされた RegisterClientScriptBlock を使用する場合は&lt;、&gt;スクリプト&lt;にスクリプト&gt;要素 ( スクリプトと /script ) を含める必要があります。

4 番目の引数を取る RegisterClientScriptBlock のオーバーロードを使用することもできます。 4 番目の引数は、スクリプト要素を追加するかどうかを指定ASP.NETブール型です。 この引数が**true の**場合、スクリプトにスクリプト要素を明示的に含めないようにします。

スクリプトが既に登録されているかどうかを確認するには、メソッドを使用します。 これにより、すでに登録されているスクリプトを再登録する試みを回避できます。

### <a name="registerclientscriptinclude-new-in-20"></a>登録クライアントスクリプトインクルード (2.0 で新しい)

タグは、外部スクリプト ファイルにリンクするスクリプト ブロックを作成します。 2 つのオーバーロードがあります。 1 つはキーと URL を受け取ります。 2 つ目は、型を指定する 3 番目の引数を追加します。

たとえば、次のコードは、アプリケーションのスクリプト フォルダーのルートにある jsfunctions.js にリンクするスクリプト ブロックを生成します。

[!code-csharp[Main](the-asp-net-2-0-page-model/samples/sample17.cs)]

このコードは、レンダリングされたページに次のコードを生成します。

[!code-html[Main](the-asp-net-2-0-page-model/samples/sample18.html)]

> [!NOTE]
> スクリプト ブロックはページの下部に表示されます。

スクリプトが既に登録されているかどうかを確認するには、メソッドを使用します。 これにより、スクリプトの再登録を回避できます。

## <a name="registerstartupscript"></a>登録スタートアップスクリプト

メソッドは、メソッドと同じ引数を受け取ります。 RegisterStartupScript に登録されたスクリプトは、ページの読み込み後、OnLoad クライアント側イベントの前に実行されます。 1.X では、RegisterStartupScript に登録された&lt;スクリプトは終了 /フォーム&gt;タグの直前に配置され、RegisterClientScriptBlock に登録&lt;された&gt;スクリプトは開始フォーム タグの直後に配置されました。 ASP.NET 2.0 では、両方とも /form&lt;&gt;タグの終了直前に配置されます。

> [!NOTE]
> RegisterStartupScript を使用して関数を登録した場合、クライアント側のコードで明示的に呼び出すまで、その関数は実行されません。

IsStartupScriptRegistered メソッドを使用して、スクリプトが既に登録されているかどうかを確認し、スクリプトの再登録を回避します。

## <a name="other-clientscriptmanager-methods"></a>その他のクライアントスクリプト マネージャー メソッド

クラスのその他の便利なメソッドのいくつかを次に示します。

|  <strong>イベントのリファレンス</strong>   |                                                 このモジュールの前のスクリプト コールバックを参照してください。                                                 |
|-----------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
|  <strong>クライアントハイパーリンク</strong>  |                クライアント側のイベントからポストバックするために使用&lt;できる&gt;JavaScript 参照 (javascript: call ) を取得します。                 |
|  <strong>イベントリファレンス</strong>   |                                   クライアントからポストバックを開始するために使用できる文字列を取得します。                                    |
|      <strong>をクリックします。</strong>       | アセンブリに埋め込まれているリソースへの URL を返します。 を使用して使用<strong>する</strong>必要があります。 |
| <strong>リソースを登録します。</strong> |     Web リソースをページに登録します。 これらは、アセンブリに埋め込まれ、新しい WebResource.axd ハンドラーによって処理されるリソースです。      |
|     <strong>隠されたフィールドを登録します。</strong>      |                                                 非表示フォーム フィールドをページに登録します。                                                 |
|  <strong>ステートメントを登録します。</strong>   |                                  HTML フォームが送信されたときに実行されるクライアント側のコードを登録します。                                   |
