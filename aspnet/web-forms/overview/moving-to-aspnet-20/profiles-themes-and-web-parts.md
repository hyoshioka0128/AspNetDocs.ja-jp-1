---
uid: web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
title: プロファイル、テーマ、および Web パーツ |Microsoft Docs
author: microsoft
description: ASP.NET 2.0 では、構成とインストルメンテーションに大きな変更が加えられています。 新しい ASP.NET configuration API を使用して、構成の変更を pr...
ms.author: riande
ms.date: 02/20/2005
ms.assetid: 92df4051-77c6-492c-bd34-23d24189cea4
msc.legacyurl: /web-forms/overview/moving-to-aspnet-20/profiles-themes-and-web-parts
msc.type: authoredcontent
ms.openlocfilehash: cf5c45781be6d003d28c6aa27efa08032579a6dd
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/06/2020
ms.locfileid: "78474640"
---
# <a name="profiles-themes-and-web-parts"></a>プロファイル、テーマ、Web パーツ

[Microsoft](https://github.com/microsoft)

> ASP.NET 2.0 では、構成とインストルメンテーションに大きな変更が加えられています。 新しい ASP.NET configuration API では、構成の変更をプログラムで行うことができます。 さらに、新しい構成設定の多くは、新しい構成とインストルメンテーションを可能にします。

ASP.NET 2.0 は、パーソナライズされた Web サイトの領域の大幅な改善を表します。 既に説明したメンバーシップ機能に加えて、ASP.NET のプロファイル、テーマ、および Web パーツは、Web サイトの個人用設定を大幅に強化します。

## <a name="aspnet-profiles"></a>ASP.NET プロファイル

ASP.NET プロファイルは、セッションに似ています。 違いは、プロファイルが永続的であるのに対し、ブラウザーを閉じたときにセッションが失われることです。 セッションとプロファイルの大きな違いは、プロファイルが厳密に型指定されているため、開発プロセス中に IntelliSense が提供されることです。

プロファイルは、コンピューターの構成ファイルまたはアプリケーションの web.config ファイルのいずれかで定義されます。 (サブフォルダーの web.config ファイルでプロファイルを定義することはできません)。次のコードは、Web サイトの訪問者の氏名を格納するためのプロファイルを定義します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample1.xml)]

プロファイルプロパティの既定のデータ型は System.string です。 上の例では、データ型が指定されていませんでした。 そのため、FirstName プロパティと LastName プロパティは両方とも String 型です。 既に説明したように、プロファイルプロパティは厳密に型指定されています。 次のコードは、Int32 型の age の新しいプロパティを追加します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample2.xml)]

プロファイルは、一般に ASP.NET フォーム認証で使用されます。 フォーム認証と組み合わせて使用する場合、各ユーザーにはユーザー ID に関連付けられた個別のプロファイルがあります。 ただし、次に示すように、構成ファイルの &lt;anonymousIdentification&gt; 要素を**Allowanonymous**属性と共に使用して、匿名アプリケーションでのプロファイルの使用を許可することもできます。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample3.xml)]

匿名ユーザーがサイトを参照すると、ASP.NET はユーザーの**ProfileCommon**のインスタンスを作成します。 このプロファイルは、ブラウザーの cookie に格納されている一意の ID を使用して、ユーザーを一意の訪問者として識別します。 このようにして、匿名で参照しているユーザーのプロファイル情報を格納できます。

## <a name="profile-groups"></a>プロファイルグループ

プロファイルのプロパティをグループ化することができます。 プロパティをグループ化することにより、特定のアプリケーションに対して複数のプロファイルをシミュレートすることができます。

次の構成では、2つのグループの FirstName と LastName プロパティを構成します。購入者と見込顧客。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample4.xml)]

次のように、特定のグループのプロパティを設定できます。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample5.cs)]

## <a name="storing-complex-objects"></a>複合オブジェクトの格納

ここまでに説明した例では、単純なデータ型をプロファイルに格納しています。 **SerializeAs**属性を使用して、次のようにシリアル化の方法を指定することにより、プロファイルに複合データ型を格納することもできます。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample6.xml)]

この場合、型は PurchaseInvoice です。 PurchaseInvoice クラスはシリアル化可能としてマークする必要があり、任意の数のプロパティを含めることができます。 たとえば、PurchaseInvoice に**NumItemsPurchased**というプロパティがある場合、次のようにコードでそのプロパティを参照できます。

[!code-css[Main](profiles-themes-and-web-parts/samples/sample7.css)]

## <a name="profile-inheritance"></a>プロファイルの継承

複数のアプリケーションで使用するプロファイルを作成することができます。 ProfileBase から派生したプロファイルクラスを作成することにより、次に示すように、**継承**属性を使用して複数のアプリケーションでプロファイルを再利用できます。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample8.xml)]

この場合、クラス**PurchasingProfile**は次のようになります。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample9.cs)]

## <a name="profile-providers"></a>プロファイルプロバイダー

ASP.NET プロファイルでは、プロバイダーモデルが使用されます。 既定のプロバイダーは、SqlProfileProvider プロバイダーを使用して、Web アプリケーションのアプリ\_データフォルダー内の SQL Server Express データベースに情報を格納します。 データベースが存在しない場合は、プロファイルが情報を格納しようとすると、ASP.NET によって自動的に作成されます。

ただし、場合によっては、独自のプロファイルプロバイダーを開発する必要があります。 ASP.NET プロファイル機能を使用すると、さまざまなプロバイダーを簡単に使用できます。

カスタムプロファイルプロバイダーは、次の場合に作成します。

- プロファイル情報は、.NET Framework に含まれているプロファイルプロバイダーでサポートされていない、FoxPro データベース、Oracle データベースなどのデータソースに格納する必要があります。
- .NET Framework に含まれるプロバイダーによって使用されるデータベーススキーマとは異なるデータベーススキーマを使用して、プロファイル情報を管理する必要があります。 一般的な例として、既存の SQL Server データベースのユーザーデータにプロファイル情報を統合することが挙げられます。

### <a name="required-classes"></a>必須クラス

プロファイルプロバイダーを実装するには、System.web クラスを継承するクラスを作成します。 その後、 **Profileprovider**抽象クラスは、system.servicemodel プロバイダー抽象クラスを継承します。このクラスは、System. Configuration. providerbase 抽象クラスを継承します。 この継承チェーンにより、 **profileprovider**クラスの必須メンバーに加えて、 **settingsprovider**クラスおよび**providerbase**クラスの必須メンバーを実装する必要があります。

次の表では、 **Providerbase**、 **Settingsprovider**、および**profileprovider**抽象クラスから実装する必要があるプロパティとメソッドについて説明します。

### <a name="providerbase-members"></a>ProviderBase メンバー

| **メンバー** | **説明** |
| --- | --- |
| Initialize メソッド | プロバイダーインスタンスの名前と構成設定の NameValueCollection を入力として受け取ります。 プロバイダーインスタンスのオプションとプロパティ値を設定するために使用します。これには、マシン構成または web.config ファイルで指定された実装固有の値やオプションも含まれます。 |

### <a name="settingsprovider-members"></a>SettingsProvider メンバー

| **メンバー** | **説明** |
| --- | --- |
| ApplicationName プロパティ | 各プロファイルに格納されているアプリケーション名。 プロファイルプロバイダーは、アプリケーション名を使用して、アプリケーションごとにプロファイル情報を個別に格納します。 これにより、複数の ASP.NET アプリケーションで、同じユーザー名が異なるアプリケーションで作成された場合に、競合することなく同じデータソースを使用できます。 また、同じアプリケーション名を指定することで、複数の ASP.NET アプリケーションでプロファイルデータソースを共有することもできます。 |
| GetPropertyValues メソッド | SettingsContext とカスタムオブジェクトを入力として受け取ります。 **Settingscontext**は、ユーザーに関する情報を提供します。 この情報を主キーとして使用して、ユーザーのプロファイルプロパティ情報を取得できます。 **Settingscontext**オブジェクトを使用してユーザー名を取得し、ユーザーが認証されているか匿名であるかを確認します。 **カスタム**には、settingsproperty オブジェクトのコレクションが含まれています。 各**settingsproperty**オブジェクトは、プロパティの名前と型、およびプロパティが読み取り専用かどうかなどの追加情報を提供します。 **Getpropertyvalues**メソッドは、入力として指定された**settingsproperty**オブジェクトに基づいて、Settingspropertyvaluecollection に settingspropertyvalue オブジェクトを設定します。 指定されたユーザーのデータソースからの値は、各**Settingspropertyvalue**オブジェクトの propertyvalue プロパティに割り当てられ、コレクション全体が返されます。 メソッドを呼び出すと、指定したユーザープロファイルの LastActivityDate 値も現在の日付と時刻に更新されます。 |
| SetPropertyValues メソッド | **Settingscontext**と**Settingspropertyvaluecollection**オブジェクトを入力として受け取ります。 **Settingscontext**は、ユーザーに関する情報を提供します。 この情報を主キーとして使用して、ユーザーのプロファイルプロパティ情報を取得できます。 **Settingscontext**オブジェクトを使用してユーザー名を取得し、ユーザーが認証されているか匿名であるかを確認します。 **Settingspropertyvaluecollection**には、 **settingspropertyvalue**オブジェクトのコレクションが含まれています。 各**Settingspropertyvalue**オブジェクトは、プロパティの名前、型、および値に加えて、プロパティの既定値やプロパティが読み取り専用かどうかなどの追加情報を提供します。 **Setpropertyvalues**メソッドは、指定されたユーザーのデータソース内のプロファイルプロパティ値を更新します。 メソッドを呼び出すと、指定したユーザープロファイルの**Lastactivitydate**値と LastUpdatedDate 値も現在の日付と時刻に更新されます。 |

### <a name="profileprovider-members"></a>ProfileProvider のメンバー

| **メンバー** | **説明** |
| --- | --- |
| DeleteProfiles メソッド | は、入力としてユーザー名の文字列配列を受け取り、指定した名前のプロファイル情報とプロパティ値をすべてデータソースから削除します。アプリケーション名は**ApplicationName**プロパティ値と一致します。 データソースでトランザクションがサポートされている場合は、すべての削除操作をトランザクションに含め、トランザクションをロールバックして、削除操作が失敗した場合に例外をスローすることをお勧めします。 |
| DeleteProfiles メソッド | は、ProfileInfo オブジェクトのコレクションを入力として受け取り、アプリケーション名が**ApplicationName**プロパティ値と一致する各プロファイルのプロファイル情報とプロパティ値をすべてデータソースから削除します。 データソースでトランザクションがサポートされている場合は、すべての削除操作をトランザクションに含め、トランザクションをロールバックして、削除操作が失敗した場合に例外をスローすることをお勧めします。 |
| DeleteInactiveProfiles メソッド | は、入力として ProfileAuthenticationOption 値と DateTime オブジェクトを受け取り、最後のアクティビティの日付が指定した日付と時刻以下で、アプリケーション名が**ApplicationName**プロパティ値と一致するすべてのプロファイル情報とプロパティ値をデータソースから削除します。 **Profileauthenticationoption**パラメーターでは、匿名プロファイルのみ、認証されたプロファイルのみ、またはすべてのプロファイルのみを削除するかどうかを指定します。 データソースでトランザクションがサポートされている場合は、すべての削除操作をトランザクションに含め、トランザクションをロールバックして、削除操作が失敗した場合に例外をスローすることをお勧めします。 |
| GetAllProfiles メソッド | は、入力として、 **Profileauthenticationoption**値、ページインデックスを指定する整数、ページサイズを指定する整数、およびプロファイルの合計数に設定される整数への参照を受け取ります。 アプリケーション名が**ApplicationName**プロパティ値と一致するデータソース内のすべてのプロファイルについて、 **profileinfo**オブジェクトを含む profileinfocollection を返します。 **Profileauthenticationoption**パラメーターは、匿名プロファイル、認証されたプロファイル、またはすべてのプロファイルのみを返すかどうかを指定します。 **GetAllProfiles**メソッドによって返される結果は、ページインデックスとページサイズの値によって制限されます。 [ページサイズ] の値は、 **Profileinfocollection**で返される**profileinfo**オブジェクトの最大数を指定します。 ページインデックス値は、返される結果のページを指定します。1は最初のページを示します。 合計レコードのパラメーターは、プロファイルの合計数に設定されている out パラメーターです (Visual Basic で**ByRef**を使用できます)。 たとえば、データストアにアプリケーション用に13のプロファイルが含まれており、ページのインデックス値が 2 (ページサイズ 5) の場合、返される**Profileinfocollection**には6番目のプロファイルが含まれます。 メソッドから制御が戻った場合、total records の値は13に設定されます。 |
| GetAllInactiveProfiles メソッド | は、入力として、 **Profileauthenticationoption**値、 **DateTime**オブジェクト、ページインデックスを指定する整数、ページサイズを指定する整数、およびプロファイルの合計数に設定される整数への参照を受け取ります。 最後のアクティビティの日付**が指定された**日時以下で、アプリケーション名が**ApplicationName**プロパティ値と一致するデータソース内のすべてのプロファイルに対して、 **Profileinfo**オブジェクトを含む**profileinfocollection**を返します。 **Profileauthenticationoption**パラメーターは、匿名プロファイル、認証されたプロファイル、またはすべてのプロファイルのみを返すかどうかを指定します。 **Getallinactiveprofiles**メソッドによって返される結果は、ページインデックスとページサイズの値によって制限されます。 [ページサイズ] の値は、 **Profileinfocollection**で返される**profileinfo**オブジェクトの最大数を指定します。 ページインデックス値は、返される結果のページを指定します。1は最初のページを示します。 合計レコードのパラメーターは、プロファイルの合計数に設定されている out パラメーターです (Visual Basic で**ByRef**を使用できます)。 たとえば、データストアにアプリケーション用に13のプロファイルが含まれており、ページのインデックス値が 2 (ページサイズ 5) の場合、返される**Profileinfocollection**には6番目のプロファイルが含まれます。 メソッドから制御が戻った場合、total records の値は13に設定されます。 |
| Findプロファイル Byusername メソッド | は、入力として、 **Profileauthenticationoption**値、ユーザー名を含む文字列、ページインデックスを指定する整数、ページサイズを指定する整数、およびプロファイルの合計数に設定される整数への参照を受け取ります。 ユーザー名が指定されたユーザー名と一致し、アプリケーション名が**ApplicationName**プロパティ値と一致する、データソース内のすべてのプロファイルの**profileinfo**オブジェクトを含む**profileinfocollection**を返します。 **Profileauthenticationoption**パラメーターは、匿名プロファイル、認証されたプロファイル、またはすべてのプロファイルのみを返すかどうかを指定します。 データソースでワイルドカード文字などの追加の検索機能がサポートされている場合は、ユーザー名に対してより広範な検索機能を提供できます。 **Findプロファイル Byusername**メソッドによって返される結果は、ページインデックスとページサイズの値によって制限されます。 [ページサイズ] の値は、 **Profileinfocollection**で返される**profileinfo**オブジェクトの最大数を指定します。 ページインデックス値は、返される結果のページを指定します。1は最初のページを示します。 合計レコードのパラメーターは、プロファイルの合計数に設定されている out パラメーターです (Visual Basic で**ByRef**を使用できます)。 たとえば、データストアにアプリケーション用に13のプロファイルが含まれており、ページのインデックス値が 2 (ページサイズ 5) の場合、返される**Profileinfocollection**には6番目のプロファイルが含まれます。 メソッドから制御が戻った場合、total records の値は13に設定されます。 |
| Findinactiveプロファイル Byusername メソッド | は、入力として、 **Profileauthenticationoption**値、ユーザー名を含む文字列、 **DateTime**オブジェクト、ページインデックスを指定する整数、ページサイズを指定する整数、およびプロファイルの合計数に設定される整数への参照を受け取ります。 ユーザー名が指定されたユーザー名と一致し、最後のアクティビティの日付**が指定された**日時以下である場合、およびアプリケーション名が**ApplicationName**プロパティ値と一致する場合に、データソース内のすべてのプロファイルの**Profileinfo**オブジェクトを含む**profileinfocollection**を返します。 **Profileauthenticationoption**パラメーターは、匿名プロファイル、認証されたプロファイル、またはすべてのプロファイルのみを返すかどうかを指定します。 データソースでワイルドカード文字などの追加の検索機能がサポートされている場合は、ユーザー名に対してより広範な検索機能を提供できます。 **Findinactiveプロファイル Byusername**メソッドによって返される結果は、ページインデックスとページサイズの値によって制限されます。 [ページサイズ] の値は、 **Profileinfocollection**で返される**profileinfo**オブジェクトの最大数を指定します。 ページインデックス値は、返される結果のページを指定します。1は最初のページを示します。 合計レコードのパラメーターは、プロファイルの合計数に設定されている out パラメーターです (Visual Basic で**ByRef**を使用できます)。 たとえば、データストアにアプリケーション用に13のプロファイルが含まれており、ページのインデックス値が 2 (ページサイズ 5) の場合、返される**Profileinfocollection**には6番目のプロファイルが含まれます。 メソッドから制御が戻った場合、total records の値は13に設定されます。 |
| Getnumber Ofinactiveprofiles メソッド | は、 **Profileauthenticationoption**値と**DateTime**オブジェクトを入力として受け取り、最後のアクティビティの日付が指定した**日時**以下で、アプリケーション名が**ApplicationName**プロパティ値と一致するデータソース内のすべてのプロファイルの数を返します。 **Profileauthenticationoption**パラメーターは、匿名プロファイル、認証されたプロファイル、またはすべてのプロファイルのみをカウントするかどうかを指定します。 |

### <a name="applicationname"></a>ApplicationName

プロファイルプロバイダーは、アプリケーションごとにプロファイル情報を個別に格納するので、データスキーマにアプリケーション名が含まれていること、およびクエリと更新プログラムにアプリケーション名が含まれていることを確認する必要があります。 たとえば、次のコマンドは、ユーザー名に基づいてデータベースからプロパティ値を取得し、プロファイルが匿名であるかどうかを確認するために使用され、 **ApplicationName**値がクエリに含まれていることを確認します。

[!code-sql[Main](profiles-themes-and-web-parts/samples/sample10.sql)]

## <a name="aspnet-themes"></a>ASP.NET のテーマ

## <a name="what-are-aspnet-20-themes"></a>ASP.NET 2.0 のテーマとは

Web アプリケーションの最も重要な側面の1つは、サイト全体の一貫したルックアンドフィールです。 ASP.NET 1.x 開発者は、通常、カスケードスタイルシート (CSS) を使用して一貫したルックアンドフィールを実装します。 ASP.NET 2.0 のテーマは、ASP.NET 開発者が ASP.NET サーバーコントロールと HTML 要素の外観を定義できるようにするため、CSS に対して大幅に改善されています。 ASP.NET テーマは、個々のコントロール、特定の Web ページ、または Web アプリケーション全体に適用できます。 テーマでは、イメージが必要な場合に、CSS ファイル、オプションのスキンファイル、およびオプションの Images ディレクトリの組み合わせを使用します。 スキンファイルは、ASP.NET サーバーコントロールの外観を制御します。

## <a name="where-are-themes-stored"></a>テーマはどこに格納されますか。

テーマが格納される場所は、そのスコープによって異なります。 任意のアプリケーションに適用できるテーマは、次のフォルダーに格納されます。

`C:\WINDOWS\Microsoft.NET\Framework\v2.x.xxxxx\ASP.NETClientFiles\Themes\<Theme_Name>`

特定のアプリケーションに固有のテーマは、Web サイトのルートにある `App\_Themes\<Theme\_Name>` ディレクトリに格納されます。

> [!NOTE]
> スキンファイルは、外観に影響を与えるサーバーコントロールのプロパティのみを変更する必要があります。

グローバルテーマは、Web サーバーで実行されている任意のアプリケーションまたは Web サイトに適用できるテーマです。 これらのテーマは、既定では、NETClientfiles\Themes ディレクトリに格納されています。 または、テーマファイルを、Web サイトのルートにある クライアント/システム\_web/[バージョン]/[\_]/[テーマ\_名] フォルダーの aspnet に移動することもできます。

アプリケーション固有のテーマは、ファイルが存在するアプリケーションにのみ適用できます。 これらのファイルは、Web サイトのルートにある `App\_Themes/<theme\_name>` ディレクトリに格納されます。

## <a name="the-components-of-a-theme"></a>テーマのコンポーネント

テーマは、1つ以上の CSS ファイル、オプションのスキンファイル、およびオプションの Images フォルダーで構成されます。 CSS ファイルには任意の名前を指定できます (例: .css または theme など)。また、テーマフォルダーのルートにある必要があります。 CSS ファイルは、特定のセレクターに対して通常の CSS クラスおよび属性を定義するために使用されます。 いずれかの CSS クラスを page 要素に適用するには、 **CSSClass**プロパティを使用します。

スキンファイルは、ASP.NET サーバーコントロールのプロパティ定義を含む XML ファイルです。 次に示すコードは、スキンファイルの例です。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample11.aspx)]

次の**図 1**は、テーマが適用されていない小さな ASP.NET ページを示しています。 **図 2**は、テーマが適用された同じファイルを示しています。 背景色とテキストの色は、CSS ファイルによって構成されます。 ボタンとテキストボックスの外観は、上に示したスキンファイルを使用して構成されます。

![テーマがありません](profiles-themes-and-web-parts/_static/image1.gif)

**図 1**: テーマなし

![適用されたテーマ](profiles-themes-and-web-parts/_static/image2.gif)

**図 2**: テーマの適用

上に示したスキンファイルは、すべてのテキストボックスコントロールとボタンコントロールの既定のスキンを定義しています。 これは、ページに挿入されたすべてのテキストボックスコントロールとボタンコントロールが、この外観になることを意味します。 コントロールの**SkinID**プロパティを使用して、これらのコントロールの特定のインスタンスに適用できるスキンを定義することもできます。

次のコードでは、ボタンコントロールのスキンを定義しています。 **Gobutton**の**SkinID**プロパティを持つボタンコントロールのみが、スキンの外観になります。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample12.aspx)]

既定のスキンは、サーバーコントロールの種類ごとに1つだけ指定できます。 追加のスキンが必要な場合は、SkinID プロパティを使用する必要があります。

## <a name="applying-themes-to-pages"></a>ページへのテーマの適用

テーマは、次のいずれかの方法を使用して適用できます。

- Web.config ファイルの &lt;pages&gt; 要素
- ページの @Page ディレクティブ内
- プログラムを使用する

## <a name="applying-a-theme-in-the-configuration-file"></a>構成ファイルでのテーマの適用

アプリケーション構成ファイルにテーマを適用するには、次の構文を使用します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample13.xml)]

ここで指定するテーマ名は、テーマフォルダーの名前と一致している必要があります。 このフォルダーは、このコースで前述した場所のいずれかに存在することができます。 存在しないテーマを適用しようとすると、構成エラーが発生します。

## <a name="applying-a-theme-in-the-page-directive"></a>Page ディレクティブでのテーマの適用

また、@ Page ディレクティブでテーマを適用することもできます。 このメソッドを使用すると、特定のページに対してテーマを使用できます。

@Page ディレクティブにテーマを適用するには、次の構文を使用します。

[!code-aspx[Main](profiles-themes-and-web-parts/samples/sample14.aspx)]

ここでも、ここで指定するテーマは、前述のテーマフォルダーと一致している必要があります。 存在しないテーマを適用しようとすると、ビルドエラーが発生します。 また、Visual Studio は属性を強調表示し、そのようなテーマが存在しないことを通知します。

## <a name="applying-a-theme-programmatically"></a>プログラムによるテーマの適用

プログラムを使用してテーマを適用するには、ページ **\_PreInit**メソッドでページの**テーマ**プロパティを指定する必要があります。

プログラムを使用してテーマを適用するには、次の構文を使用します。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample15.cs)]

ページのライフサイクルが原因で、PreInit メソッドにテーマを適用する必要があります。 その後に適用した場合、ページのテーマはランタイムによって既に適用されており、その時点での変更はライフサイクルにおいて遅すぎます。 存在しないテーマを適用すると、 **Httpexception**が発生します。 テーマがプログラムによって適用されると、いずれかのサーバーコントロールに SkinID プロパティが指定されている場合、ビルド警告が発生します。 この警告は、テーマが宣言されていないことを通知するためのものであり、無視してもかまいません。

## <a name="exercise-1--applying-a-theme"></a>演習 1: テーマの適用

この演習では、Web サイトに ASP.NET テーマを適用します。

> [!IMPORTANT]
> Microsoft Word を使用してスキンファイルに情報を入力する場合は、通常の引用符をスマート引用符で置き換えることがないようにしてください。 スマートクォートを使用すると、スキンファイルに問題が発生します。

1. 新しい ASP.NET Web サイトの作成
2. ソリューションエクスプローラーでプロジェクトを右クリックし、[新しい項目の追加] を選択します。
3. ファイルの一覧から [Web 構成ファイル] を選択し、[追加] をクリックします。
4. ソリューションエクスプローラーでプロジェクトを右クリックし、[新しい項目の追加] を選択します。
5. [スキンファイル] を選択し、[追加] をクリックします。
6. アプリ\_テーマフォルダー内にファイルを配置するかどうかを確認するメッセージが表示されたら、[はい] をクリックします。
7. ソリューションエクスプローラーで、アプリ\_テーマフォルダー内の SkinFile フォルダーを右クリックし、[新しい項目の追加] を選択します。
8. ファイルの一覧から [スタイルシート] を選択し、[追加] をクリックします。 これで、新しいテーマを実装するために必要なすべてのファイルが作成されました。 ただし、Visual Studio では、テーマフォルダー SkinFile という名前が付けられています。 そのフォルダーを右クリックし、名前を CoolTheme に変更します。
9. SkinFile ファイルを開き、ファイルの末尾に次のコードを追加します。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample16.aspx)]
10. SkinFile ファイルを保存します。
11. StyleSheet を開きます。
12. その中のすべてのテキストを次の内容に置き換えます。 

    [!code-css[Main](profiles-themes-and-web-parts/samples/sample17.css)]
13. スタイルシートの .css ファイルを保存します。
14. Default.aspx ページを開きます。
15. TextBox コントロールと Button コントロールを追加します。
16. ページを保存します。 次に default.aspx ページを参照します。 通常の Web フォームとして表示されます。
17. Web.config ファイルを開きます。
18. 開始 `<system.web>` タグのすぐ下に次のを追加します。 

    [!code-xml[Main](profiles-themes-and-web-parts/samples/sample18.xml)]
19. Web.config ファイルを保存します。 次に default.aspx ページを参照します。 テーマが適用された状態で表示されます。
20. まだ開いていない場合は、Visual Studio の default.aspx ページを開きます。
21. [] ボタンを選択します。
22. **SkinID**プロパティを gobutton に変更します。 Visual Studio には、ボタンコントロールに対して有効な SkinID 値を含むドロップダウンが用意されています。
23. ページを保存します。 次に、ブラウザーでページをもう一度プレビューします。 ボタンが "進む" と表示され、より広い外観になります。

**SkinID**プロパティを使用すると、特定の種類のサーバーコントロールの異なるインスタンスに対して異なるスキンを簡単に構成できます。

## <a name="the-stylesheettheme-property"></a>StyleSheetTheme プロパティ

ここまでは、テーマプロパティを使用したテーマの適用についてのみ説明しました。 Theme プロパティを使用すると、スキンファイルによって、サーバーコントロールの宣言型の設定が上書きされます。 たとえば、演習1では、ボタンコントロールに対して "goButton" という SkinID を指定し、ボタンのテキストを "進む" に変更しました。 デザイナーのボタンの Text プロパティが "Button" に設定されていることに気付いたかもしれませんが、テーマはそれをオーバーライドしています。 テーマは、常にデザイナーのプロパティ設定をオーバーライドします。

テーマのスキンファイルで定義されているプロパティをデザイナーで指定されたプロパティでオーバーライドできるようにする場合は、Theme プロパティの代わりに**StyleSheetTheme**プロパティを使用できます。 StyleSheetTheme プロパティは Theme プロパティと同じですが、Theme プロパティと同様に、明示的なプロパティ設定がすべてオーバーライドされる点が異なります。

実際の動作を確認するには、演習1でプロジェクトの web.config ファイルを開き、`<pages>` 要素を次のように変更します。

[!code-xml[Main](profiles-themes-and-web-parts/samples/sample19.xml)]

Default.aspx ページを参照します。ボタンコントロールの Text プロパティが "Button" になっていることがわかります。 これは、デザイナーの明示的なプロパティ設定によって、goButton SkinID によって設定された Text プロパティがオーバーライドされるためです。

## <a name="overriding-themes"></a>テーマのオーバーライド

グローバルテーマをオーバーライドするには、アプリケーションの [アプリ\_テーマ] フォルダーにある同じ名前のテーマを適用します。 ただし、このテーマは、真のオーバーライドシナリオでは適用されません。 ランタイムがアプリの\_theme フォルダー内のテーマファイルを検出すると、それらのファイルを使用してテーマが適用され、グローバルテーマは無視されます。

StyleSheetTheme プロパティはオーバーライド可能で、次のようにコードでオーバーライドできます。

[!code-csharp[Main](profiles-themes-and-web-parts/samples/sample20.cs)]

## <a name="web-parts"></a>Web パーツ

ASP.NET Web パーツは、エンドユーザーがブラウザーから直接 Web ページのコンテンツ、外観、および動作を変更できるようにする Web サイトを作成するためのコントロールの統合されたセットです。 この変更は、サイト上のすべてのユーザーに適用することも、個々のユーザーに適用することもできます。 ユーザーがページとコントロールを変更すると、その設定を保存して、今後のブラウザーセッション (パーソナル化と呼ばれます) の間にユーザーの個人設定を保持することができます。 これらの Web パーツ機能は、開発者や管理者の介入なしに、エンドユーザーが Web アプリケーションを動的にカスタマイズできるようにすることを意味します。

開発者は、Web パーツコントロールセットを使用して、次の操作を行うことができます。

- ページコンテンツをカスタマイズします。 ユーザーは、新しい Web パーツコントロールをページに追加したり、削除したり、非表示にしたり、通常のウィンドウのように最小化したりすることができます。
- ページレイアウトを個人用に設定します。 ユーザーは、Web パーツコントロールをページ上の別のゾーンにドラッグしたり、外観、プロパティ、動作を変更したりできます。
- コントロールをエクスポートおよびインポートします。 ユーザーは、他のページやサイトで使用するために Web パーツコントロールの設定をインポートまたはエクスポートできます。また、コントロールのプロパティ、外観、データも保持できます。 これにより、エンドユーザーに対するデータ入力と構成の要求が減少します。
- 接続を作成します。 ユーザーはコントロール間の接続を確立できます。たとえば、グラフコントロールでは、株価情報コントロールのデータのグラフを表示できます。 ユーザーは、接続自体だけでなく、グラフコントロールでデータを表示する方法の外観と詳細をカスタマイズすることもできます。
- サイトレベルの設定を管理およびカスタマイズします。 承認されたユーザーは、サイトレベルの設定を構成したり、サイトまたはページにアクセスできるユーザーを特定したり、コントロールへのロールベースのアクセスを設定したりできます。 たとえば、管理者ロールのユーザーは、Web パーツコントロールをすべてのユーザーが共有するように設定し、管理者以外のユーザーが共有コントロールを個人用に設定するのを防ぐことができます。

通常は、次の3つの方法のいずれかで Web パーツ操作を行います。 Web パーツコントロールを使用するページの作成、個別の Web パーツコントロールの作成、またはポータルなどの完全なパーソナル化された Web アプリケーションの作成です。

## <a name="page-development"></a>ページ開発

ページ開発者は、Microsoft Visual Studio 2005 などのビジュアルデザインツールを使用して、Web パーツを使用するページを作成できます。 Visual Studio などのツールを使用する利点の1つとして、Web パーツコントロールセットによって、ビジュアルデザイナーでのドラッグアンドドロップによる Web パーツコントロールの作成と構成を行う機能が用意されています。 たとえば、デザイナーを使用して Web パーツゾーンまたは Web パーツエディターコントロールをデザイン画面にドラッグし、Web パーツコントロールセットによって提供される UI を使用してデザイナーでコントロールを構成できます。 これにより、Web パーツアプリケーションの開発を高速化し、記述する必要のあるコードの量を減らすことができます。

## <a name="control-development"></a>開発の制御

標準の Web サーバーコントロール、カスタムサーバーコントロール、ユーザーコントロールなど、既存の ASP.NET コントロールを Web パーツコントロールとして使用できます。 環境のプログラムによる制御を最大限に活用するために、WebPart クラスから派生するカスタム Web パーツコントロールを作成することもできます。 Web パーツコントロールを個別に開発する場合は、通常、ユーザーコントロールを作成し、それを Web パーツコントロールとして使用するか、カスタム Web パーツコントロールを開発します。

カスタム Web パーツコントロールを開発する例として、コントロールを作成して、他の ASP.NET サーバーコントロールによって提供される機能を提供することができます。これは、カスタマイズ可能な Web パーツコントロールとしてパッケージ化する場合に便利です。カレンダー、リスト、財務情報、コンテンツを更新するためのニュース、電卓、リッチテキストコントロール、データベースに接続する編集可能なグリッド、表示を動的に更新するグラフ、気象情報、旅行情報などがあります。 コントロールにビジュアルデザイナーを提供する場合、Visual Studio を使用するすべてのページ開発者は、コントロールを単に Web パーツゾーンにドラッグして、追加のコードを記述することなくデザイン時に構成できます。

個人用設定は、Web パーツ機能の基盤です。 これにより、ユーザーは、ページ上の Web パーツコントロールのレイアウト、外観、および動作を変更またはカスタマイズすることができます。 個人用に設定された設定は有効期間が長くなります。つまり、現在のブラウザーセッション (ビューステートの場合) だけでなく、長期的なストレージでも保持されるので、今後のブラウザーセッションでもユーザーの設定が保存されます。 Web パーツページでは、個人用設定が既定で有効になっています。

UI 構造コンポーネントは、パーソナル化に依存しており、すべての Web パーツコントロールで必要なコア構造とサービスを提供します。 すべての Web パーツページに必要な1つの UI 構造コンポーネントが、WebPartManager コントロールです。 このコントロールには表示されませんが、ページ上のすべての Web パーツコントロールを調整するための重要なタスクがあります。 たとえば、すべての個別 Web パーツコントロールを追跡します。 Web パーツゾーン (ページ上の Web パーツコントロールを含む領域) と、どのコントロールがどのゾーンにあるかを管理します。 また、参照、接続、編集、カタログモードなど、ページが持つさまざまな表示モードや、個人用設定の変更をすべてのユーザーに適用するか、個々のユーザーに適用するかを追跡および制御します。 最後に、Web パーツコントロール間の接続と通信を開始して追跡します。

UI 構造コンポーネントの2つ目の種類は、ゾーンです。 ゾーンは、Web パーツページのレイアウトマネージャーとして機能します。 パートクラス (パーツコントロール) から派生したコントロールを格納して整理し、水平方向または垂直方向の両方でモジュール式のページレイアウトを行う機能を提供します。 また、ゾーンは、含まれるコントロールごとに共通の一貫した UI 要素 (ヘッダー、フッターのスタイル、タイトル、罫線のスタイル、アクションボタンなど) を提供します。これらの共通要素は、コントロールの chrome として知られています。 いくつかの特殊な種類のゾーンは、さまざまな表示モードおよびさまざまなコントロールで使用されます。 さまざまな種類のゾーンについては、以下の「Web パーツの重要なコントロール」で説明しています。

Web パーツ UI コントロールは、**パート**クラスから派生したものであり、Web パーツページのプライマリ ui を構成します。 Web パーツコントロールセットは柔軟であり、パーツコントロールを作成するために使用できるオプションを含みます。 独自のカスタム Web パーツコントロールを作成するだけでなく、既存の ASP.NET サーバーコントロール、ユーザーコントロール、またはカスタムサーバーコントロールを Web パーツコントロールとして使用することもできます。 Web パーツページを作成するために最も一般的に使用される基本コントロールについては、次のセクションで説明します。

## <a name="web-parts-essential-controls"></a>Web パーツの重要なコントロール

Web パーツコントロールセットは広く使用されていますが、Web パーツが動作するために必要なコントロールや、Web パーツページで最も頻繁に使用されるコントロールであるため、いくつかのコントロールが不可欠です。 Web パーツの使用と基本的な Web パーツページの作成を開始する際には、次の表に記載されている基本的な Web パーツコントロールについて理解しておくことをお勧めします。

| **Web パーツコントロール** | **説明** |
| --- | --- |
| WebPartManager | ページ上のすべての Web パーツコントロールを管理します。 すべての Web パーツページに1つ (1 つだけ) の**WebPartManager**コントロールが必要です。 |
| CatalogZone | CatalogPart コントロールを含みます。 このゾーンを使用して、ユーザーがページに追加するコントロールを選択できる Web パーツコントロールのカタログを作成します。 |
| EditorZone | EditorPart コントロールを含みます。 このゾーンを使用して、ユーザーがページ上のコントロールを編集およびカスタマイズ Web パーツできるようにします。 |
| WebPartZone | には、ページのメイン UI を構成する WebPart コントロールの全体的なレイアウトが含まれています。 Web パーツコントロールを使用してページを作成するたびに、このゾーンを使用します。 ページには、1つまたは複数のゾーンを含めることができます。 |
| ConnectionsZone | WebPartConnection コントロールを含み、接続を管理するための UI を提供します。 |
| WebPart (GenericWebPart) | プライマリ UI をレンダリングします。ほとんどの Web パーツ UI コントロールは、このカテゴリに分類されます。 プログラムによる制御を最大限にするために、基本の**WebPart**コントロールから派生するカスタム Web パーツコントロールを作成できます。 また、既存のサーバーコントロール、ユーザーコントロール、またはカスタムコントロールを Web パーツコントロールとして使用することもできます。 これらのコントロールのいずれかがゾーン内に配置されている場合、 **WebPartManager**コントロールは、 **GenericWebPart**コントロールを実行時に自動的にラップして、Web パーツ機能と共に使用できるようにします。 |
| CatalogPart | ユーザーがページに追加できる、使用可能な Web パーツコントロールの一覧が含まれています。 |
| WebPartConnection | ページ上の2つの Web パーツコントロール間の接続を作成します。 この接続では、Web パーツコントロールの1つをプロバイダー (データの) として定義し、もう一方をコンシューマーとして定義します。 |
| EditorPart | 特殊なエディターコントロールの基本クラスとして機能します。 |
| EditorPart コントロール (外観、LayoutEditorPart、PropertyGridEditorPart、および) | ページ上の Web パーツ UI コントロールのさまざまな側面をユーザーがカスタマイズできるようにする |

## <a name="lab-create-a-web-part-page"></a>ラボ: Web パーツページの作成

このラボでは、ASP.NET プロファイルを使用して情報を保持する Web パーツページを作成します。

### <a name="creating-a-simple-page-with-web-parts"></a>Web パーツを使用した簡単なページの作成

チュートリアルのこの部分では、Web パーツコントロールを使用して静的コンテンツを表示するページを作成します。 Web パーツを操作するための最初の手順は、2つの必須の構造要素を持つページを作成することです。 まず、Web パーツページには、すべての Web パーツコントロールを追跡して調整するための WebPartManager コントロールが必要です。 次に、Web パーツページには1つ以上のゾーンが必要です。これは、WebPart コントロールまたは他のサーバーコントロールを含み、ページの指定された領域を占める複合コントロールです。

> [!NOTE]
> Web パーツ個人用設定を有効にするために何もする必要はありません。これは、Web パーツコントロールセットに対して既定で有効になっています。 サイトで最初に Web パーツページを実行すると、ASP.NET は、ユーザーの個人用設定を格納するための既定のパーソナル化プロバイダーを設定します。 パーソナル化の詳細については、「Web パーツパーソナル化の概要」を参照してください。

### <a name="to-create-a-page-for-containing-web-parts-controls"></a>Web パーツコントロールを含むページを作成するには

1. 既定のページを閉じ、WebPartsDemo .aspx という名前のサイトに新しいページを追加します。
2. **デザイン**ビューに切り替えます。
3. **[表示]** メニューで、 **[非ビジュアルコントロール]** オプションと **[詳細]** オプションが選択されていることを確認します。これにより、UI を持たないレイアウトタグとコントロールが表示されます。
4. デザインサーフェイスの `<div>` タグの前に挿入ポイントを置き、ENTER キーを押して新しい行を追加します。 挿入ポイントを改行文字の前に配置し、メニューの **[ブロックの書式]** ドロップダウンリストコントロールをクリックして、**見出し 1**オプションを選択します。 見出しに、テキスト**Web パーツのデモページ**を追加します。
5. ツールボックス の  **Web パーツ** タブで、 **WebPartManager**コントロールをページにドラッグし、新しい行文字の直後と `<div>`タグの前に配置します。   
  
   **WebPartManager**コントロールは出力を表示しないので、デザイナー画面に灰色のボックスとして表示されます。
6. `<div>` タグ内に挿入ポイントを配置します。
7. **[レイアウト]** メニューの **[テーブルの挿入]** をクリックし、1行と3つの列を含む新しいテーブルを作成します。 **[セルのプロパティ]** ボタンをクリックし、 **[垂直方向の配置]** ドロップダウンリストから **[上]** を選択します。 **[ok]** をクリックし、もう一度 **[ok]** をクリックしてテーブルを作成します。
8. WebPartZone コントロールを左テーブルの列にドラッグします。 **WebPartZone**コントロールを右クリックし、 **[プロパティ]** を選択して、次のプロパティを設定します。   
  
   ID: SidebarZone   
  
   HeaderText: サイドバー
9. 2つ目の**WebPartZone**コントロールを中央のテーブル列にドラッグし、次のプロパティを設定します。   
  
   ID: MainZone   
  
   HeaderText: Main
10. ファイルを保存します。

ページには、個別に制御できる2つの個別のゾーンがあります。 ただし、どのゾーンにもコンテンツがないため、コンテンツを作成するのは次の手順です。 このチュートリアルでは、静的コンテンツのみを表示する Web パーツコントロールを操作します。

Web パーツゾーンのレイアウトは、&lt;zonetemplate&gt; 要素によって指定されます。 ゾーンテンプレート内では、カスタム Web パーツコントロール、ユーザーコントロール、または既存のサーバーコントロールのいずれであるかにかかわらず、任意の ASP.NET コントロールを追加できます。 ここでは、ラベルコントロールを使用しており、静的テキストを追加するだけであることに注意してください。 通常のサーバーコントロールを**WebPartZone**ゾーンに配置すると、ASP.NET はそのコントロールを実行時に Web パーツコントロールとして扱います。これにより、コントロールの機能が有効 Web パーツになります。

**メインゾーンのコンテンツを作成するには**

1. **[デザイン]** ビューで、ツールボックス の **[標準]** タブの **[ラベル]** コントロールを、 **ID**プロパティが [mainzone] に設定されているゾーンの [コンテンツ] 領域にドラッグします。
2. **ソース**ビューに切り替えます。 MainZone で**ラベル**コントロールをラップするために &lt;zonetemplate&gt; 要素が追加されていることに注目してください。
3. **Title**という名前の属性を &lt;asp: label&gt; 要素に追加し、その値を Content に設定します。 &lt;asp: label&gt; 要素から Text = "Label" 属性を削除します。 &lt;asp: label&gt; 要素の開始タグと終了タグの間に、&lt;h2&gt; 要素タグのペア内の**ホームページへようこそ**などのテキストを追加します。 コードは次のようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample21.aspx)]
4. ファイルを保存します。

次に、Web パーツコントロールとしてページに追加することもできるユーザーコントロールを作成します。

### <a name="to-create-a-user-control"></a>ユーザー コントロールを作成するには

1. 検索コントロールとして機能する新しい Web ユーザーコントロールをサイトに追加します。 **ソースコードを別のファイルに配置する場合**は、このオプションをオフにします。 それを WebPartsDemo .aspx ページと同じディレクトリに追加し、「SearchUserControl .ascx」という名前を付けます。   
  
    > [!NOTE]
    > このチュートリアルのユーザーコントロールは、実際の検索機能を実装していません。Web パーツの機能を示すためにのみ使用されます。
2. **デザイン**ビューに切り替えます。 ツールボックス の **標準** タブで、テキストボックスコントロールをページにドラッグします。
3. 追加したテキストボックスの後に挿入ポイントを置き、ENTER キーを押して新しい行を追加します。
4. 追加したテキストボックスの下の新しい行で、ボタンコントロールをページにドラッグします。
5. **ソース**ビューに切り替えます。 ユーザーコントロールのソースコードが次の例のようになっていることを確認します。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample22.aspx)]
6. ファイルを保存して閉じます。

これで、Web パーツコントロールをサイドバーゾーンに追加できるようになりました。 2つのコントロールをサイドバーゾーンに追加します。1つはリンクのリストを含み、もう1つは前の手順で作成したユーザーコントロールです。 メインゾーンの静的テキストを作成した場合と同様に、リンクは標準の**ラベル**サーバーコントロールとして追加されます。 ただし、ユーザーコントロールに含まれる個々のサーバーコントロールは、(ラベルコントロールのように) ゾーンに直接含めることができますが、この場合はそうではありません。 代わりに、前の手順で作成したユーザーコントロールの一部になります。 これは、ユーザーコントロールに必要なコントロールや追加機能をパッケージ化し、そのコントロールを Web パーツコントロールとしてゾーンで参照するための一般的な方法を示しています。

実行時に Web パーツコントロールセットは、両方のコントロールを GenericWebPart コントロールでラップします。 **GenericWebPart**コントロールが Web サーバーコントロールをラップする場合、ジェネリックパーツコントロールは親コントロールであり、親コントロールの childcontrol プロパティを使用してサーバーコントロールにアクセスできます。 このジェネリックパーツコントロールの使用により、標準の Web サーバーコントロールに、 **WebPart**クラスから派生したコントロール Web パーツと同じ基本動作および属性を持たせることができます。

### <a name="to-add-web-parts-controls-to-the-sidebar-zone"></a>サイドバーゾーンに Web パーツコントロールを追加するには

1. WebPartsDemo .aspx ページを開きます。
2. **デザイン**ビューに切り替えます。
3. 作成したユーザーコントロールページ (SearchUserControl. .ascx) を**ソリューションエクスプローラー**から、 **ID**プロパティが sidebarzone に設定されているゾーンにドラッグし、そこにドロップします。
4. WebPartsDemo .aspx ページを保存します。
5. **ソース**ビューに切り替えます。
6. 次の例に示すように、ユーザーコントロールへの参照のすぐ上にある、SidebarZone の &lt;asp: webpartzone&gt; 要素内で、&lt;asp: label&gt; 要素に含まれるリンクを追加します。 また、表示されているように、ユーザーコントロールタグに**Title**属性を追加します。このとき、値は**Search**になります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample23.aspx)]
7. ファイルを保存して閉じます。

ブラウザーでページを参照して、ページをテストできるようになりました。 このページには、2つのゾーンが表示されます。 次のスクリーンショットは、このページを示しています。

**2つのゾーンを含む Web パーツデモページ**

![Web パーツ VS チュートリアル1のスクリーンショット](profiles-themes-and-web-parts/_static/image3.gif)

**図 3**: Web パーツ VS チュートリアル1のスクリーンショット

各コントロールのタイトルバーには、コントロールに対して実行できる操作の動詞メニューへのアクセスを提供する下向きの矢印が表示されます。 コントロールの1つの動詞メニューをクリックし、 **[最小化]** 動詞をクリックして、コントロールが最小化されていることを確認します。 動詞メニューの **[復元]** をクリックすると、コントロールが通常のサイズに戻ります。

### <a name="enabling-users-to-edit-pages-and-change-layout"></a>ユーザーがページを編集してレイアウトを変更できるようにする

Web パーツには、ユーザーがコントロールを1つのゾーンから別のゾーンにドラッグすることによって、Web パーツコントロールのレイアウトを変更する機能が用意されています。 ユーザーが**Web パーツ**コントロールをあるゾーンから別のゾーンに移動できるようにするだけでなく、外観、レイアウト、動作など、コントロールのさまざまな特性をユーザーが編集できるようにすることができます。 Web パーツコントロールセットは、 **WebPart**コントロールの基本的な編集機能を提供します。 このチュートリアルではこれを行いませんが、カスタムエディターコントロールを作成して、ユーザーが**WebPart**コントロールの機能を編集できるようにすることもできます。 **WebPart**コントロールの場所を変更する場合と同様に、コントロールのプロパティを編集するには、ユーザーが行った変更を保存するために、ASP.NET のパーソナル化に依存します。

チュートリアルのこの部分では、ユーザーがページ上の**WebPart**コントロールの基本的な特性を編集する機能を追加します。 これらの機能を有効にするには、&lt;asp: editorzone&gt; 要素と2つの編集コントロールと共に、別のカスタムユーザーコントロールをページに追加します。

### <a name="to-create-a-user-control-that-enables-changing-page-layout"></a>ページレイアウトの変更を可能にするユーザーコントロールを作成するには

1. Visual Studio の **[ファイル]** メニューで、 **[新規]** サブメニューを選択し、 **[ファイル]** オプションをクリックします。
2. **[新しい項目の追加]** ダイアログで、 **[Web ユーザーコントロール]** を選択します。 新しいファイルに DisplayModeMenu .ascx という名前を指定します。 **ソースコードを別のファイルに配置**する場合は、このオプションをオフにします。
3. [追加] をクリックして、新しいコントロールを作成します。
4. **ソース**ビューに切り替えます。
5. 新しいファイルの既存のコードをすべて削除し、次のコードを貼り付けます。 このユーザーコントロールコードでは、Web パーツコントロールセットの機能を使用して、ページでビューモードまたは表示モードを変更できるようにします。また、特定の表示モードでページの物理的な外観とレイアウトを変更することもできます。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample24.aspx)]
6. ツールバーの 保存 アイコンをクリックするか、**ファイル** メニューの **保存** を選択して、ファイルを保存します。

### <a name="to-enable-users-to-change-the-layout"></a>ユーザーがレイアウトを変更できるようにするには

1. WebPartsDemo ページを開き、**デザイン** ビューに切り替えます。
2. 前の手順で追加した**WebPartManager**コントロールの直後に、**デザイン**ビューに挿入ポイントを配置します。 **WebPartManager**コントロールの後に空白行が表示されるように、テキストの後にハードリターンを追加します。 空白行に挿入ポイントを配置します。
3. 先ほど作成したユーザーコントロール (DisplayModeMenu. .ascx という名前のファイル) を、WebPartsDemo .aspx ページにドラッグし、空白行にドロップします。
4. ツールボックス の  **Web パーツ** セクションから、EditorZone コントロールを WebPartsDemo ページの その他の開いているテーブル セルにドラッグします。
5. ツールボックスの **[Web パーツ]** セクションから、LayoutEditorPart コントロールを**EditorZone**コントロールにドラッグします。
6. **ソース**ビューに切り替えます。 テーブルセル内の結果のコードは、次のコードのようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample25.aspx)]
7. WebPartsDemo .aspx ファイルを保存します。 表示モードの変更とページレイアウトの変更を行うことができるユーザーコントロールを作成し、プライマリ Web ページでコントロールを参照しました。

ページを編集してレイアウトを変更する機能をテストできるようになりました。

### <a name="to-test-layout-changes"></a>レイアウトの変更をテストするには

1. ブラウザーにページを読み込みます。
2. **[表示モード]** ドロップダウンメニューをクリックし、 **[編集]** を選択します。 ゾーンタイトルが表示されます。
3. タイトルバーからメインゾーンの下部に**マイリンク**コントロールをドラッグします。 ページは次のスクリーンショットのようになります。

### <a name="web-parts-demo-page-with-my-links-control-moved"></a>マイリンクコントロールを移動した Web パーツデモページ

![Web パーツ VS チュートリアル2のスクリーンショット](profiles-themes-and-web-parts/_static/image4.gif)

**図 4**: Web パーツ VS チュートリアル2のスクリーンショット

1. **[表示モード]** ドロップダウンメニューをクリックし、 **[参照]** を選択します。 ページが更新され、ゾーン名が消え、 **[マイリンク**] コントロールが配置されたままになります。
2. 個人用設定が機能していることを示すには、ブラウザーを閉じてから、再度ページを読み込みます。 行った変更は、今後のブラウザーセッションのために保存されます。
3. **[表示モード]** メニューの **[編集]** をクリックします。   
  
   ページ上の各コントロールは、動詞のドロップダウンメニューを含む、タイトルバーに下向きの矢印付きで表示されるようになりました。
4. 矢印をクリックすると、 **[マイリンク**] コントロールに動詞メニューが表示されます。 **編集**動詞をクリックします。   
  
   **EditorZone**コントロールが表示され、追加した editorpart コントロールが表示されます。
5. 編集コントロールの **[外観]** セクションで、 **[タイトル]** を お気に入り に変更し、 **[Chrome の種類]** ドロップダウンリストを使用して **[タイトルのみ]** を選択し、 **[適用]** をクリックします。 次のスクリーンショットは、編集モードのページを示しています。

### <a name="web-parts-demo-page-in-edit-mode"></a>編集モードの Web パーツデモページ

![Web パーツ VS チュートリアル3スクリーンショット](profiles-themes-and-web-parts/_static/image5.gif)

**図 5**: Web パーツ VS チュートリアル3のスクリーンショット

1. **[表示モード]** メニューをクリックし、 **[参照]** を選択してブラウズモードに戻ります。
2. 次のスクリーンショットに示すように、コントロールのタイトルが更新され、境界線が表示されなくなりました。

### <a name="edited-web-parts-demo-page"></a>編集 Web パーツデモページ

![Web パーツ VS チュートリアル4のスクリーンショット](profiles-themes-and-web-parts/_static/image6.gif)

**図 4**: Web パーツ VS チュートリアル4のスクリーンショット

### <a name="adding-web-parts-at-run-time"></a>実行時の Web パーツの追加

また、ユーザーが実行時に Web パーツコントロールをページに追加できるようにすることもできます。 これを行うには、Web パーツカタログを使用してページを構成します。このページには、ユーザーが使用できるようにする Web パーツコントロールの一覧が含まれています。

**実行時にユーザーが Web パーツを追加できるようにするには**

1. WebPartsDemo ページを開き、**デザイン** ビューに切り替えます。
2. ツールボックスの **[Web パーツ]** タブから、CatalogZone コントロールをテーブルの右側の列 ( **EditorZone**コントロールの下) にドラッグします。   
  
   両方のコントロールは、同時に表示されないため、同じテーブルセル内に配置できます。
3. プロパティ ペインで、 **Add Web パーツ**を**CatalogZone**コントロールの HeaderText プロパティに割り当てます。
4. ツールボックスの **[Web パーツ]** セクションから、DeclarativeCatalogPart コントロールを**CatalogZone**コントロールのコンテンツ領域にドラッグします。
5. **DeclarativeCatalogPart**コントロールの右上隅にある矢印をクリックして タスク メニューを表示し、**テンプレートの編集** を選択します。
6. ツールボックスの **[標準]** セクションで、 **FileUpload**コントロールと**Calendar**コントロールを**DeclarativeCatalogPart**コントロールの**WebPartsTemplate**セクションにドラッグします。
7. **ソース**ビューに切り替えます。 &lt;asp: catalogzone&gt; 要素のソースコードを調べます。 **DeclarativeCatalogPart**コントロールには、カタログからページに追加できる2つの囲まれたサーバーコントロールを持つ &lt;webpartstemplate&gt; 要素が含まれていることに注意してください。
8. 次のコード例の各タイトルに対して表示される文字列値を使用して、カタログに追加した各コントロールに**title**プロパティを追加します。 タイトルはプロパティではありませんが、通常はデザイン時にこれら2つのサーバーコントロールに設定できますが、ユーザーがこれらのコントロールを実行時にカタログから**WebPartZone**ゾーンに追加すると、 **GenericWebPart**コントロールでラップされます。 これにより、Web パーツコントロールとして機能し、タイトルを表示できるようになります。   
  
   **DeclarativeCatalogPart**コントロールに含まれる2つのコントロールのコードは、次のようになります。 

    [!code-aspx[Main](profiles-themes-and-web-parts/samples/sample26.aspx)]
9. ページを保存します。

これで、カタログをテストできます。

### <a name="to-test-the-web-parts-catalog"></a>Web パーツカタログをテストするには

1. ブラウザーにページを読み込みます。
2. **[表示モード]** ドロップダウンメニューをクリックし、 **[カタログ]** を選択します。   
  
   Web パーツの**追加**というタイトルのカタログが表示されます。
3. メインゾーンの **[マイお気に入り**] コントロールをサイドバーゾーンの一番上にドラッグし、そこにドロップします。
4. Web パーツカタログの **[追加]** で、両方のチェックボックスをオンにし、使用可能なゾーンが含まれているドロップダウンリストから **[Main]** を選択します。
5. カタログの **[追加]** をクリックします。 コントロールがメインゾーンに追加されます。 必要に応じて、カタログからページにコントロールの複数のインスタンスを追加できます。   
  
   次のスクリーンショットは、ファイルアップロードコントロールがあるページとメインゾーンのカレンダーを示しています。 

![カタログからメインゾーンに追加されたコントロール](profiles-themes-and-web-parts/_static/image7.gif)

    **Figure 5**: Controls added to Main zone from the catalog
6. **[表示モード]** ドロップダウンメニューをクリックし、 **[参照]** を選択します。 カタログが表示されなくなり、ページが更新されます。
7. ブラウザーを閉じます。 ページを再度読み込みます。 行った変更は保持されます。
